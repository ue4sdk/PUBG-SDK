// PlayerUnknown's Battlegrounds SDK

#ifdef _MSC_VER
#pragma pack(push, 0x8)
#endif

#include "../SDK.hpp"

namespace Classes {
	//---------------------------------------------------------------------------
	//Functions
	//---------------------------------------------------------------------------

	// Function Engine.Actor.WasRecentlyRendered
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Tolerance                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::WasRecentlyRendered(float Tolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x71fedf7c);

		AActor_WasRecentlyRendered_Params params;
		params.Tolerance = Tolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.UserConstructionScript
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void AActor::UserConstructionScript() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x64585ca3);

		AActor_UserConstructionScript_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.TearOff
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AActor::TearOff() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6270e13b);

		AActor_TearOff_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SnapRootComponentTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  InParentActor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SnapRootComponentTo(class AActor* InParentActor, const struct FName& InSocketName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc103bb0a);

		AActor_SnapRootComponentTo_Params params;
		params.InParentActor = InParentActor;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetTickGroup
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ETickingGroup>     NewTickGroup                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetTickGroup(TEnumAsByte<ETickingGroup> NewTickGroup) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x330e335c);

		AActor_SetTickGroup_Params params;
		params.NewTickGroup = NewTickGroup;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetTickableWhenPaused
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bTickableWhenPaused            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetTickableWhenPaused(bool bTickableWhenPaused) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbce5411d);

		AActor_SetTickableWhenPaused_Params params;
		params.bTickableWhenPaused = bTickableWhenPaused;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetReplicates
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInReplicates                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetReplicates(bool bInReplicates) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85b88364);

		AActor_SetReplicates_Params params;
		params.bInReplicates = bInReplicates;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetReplicateMovement
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInReplicateMovement           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetReplicateMovement(bool bInReplicateMovement) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd26b792a);

		AActor_SetReplicateMovement_Params params;
		params.bInReplicateMovement = bInReplicateMovement;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetOwner
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  NewOwner                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetOwner(class AActor* NewOwner) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2b14c75);

		AActor_SetOwner_Params params;
		params.NewOwner = NewOwner;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetLifeSpan
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InLifespan                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetLifeSpan(float InLifespan) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96ca7566);

		AActor_SetLifeSpan_Params params;
		params.InLifespan = InLifespan;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetActorTickInterval
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          TickInterval                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetActorTickInterval(float TickInterval) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x91a59673);

		AActor_SetActorTickInterval_Params params;
		params.TickInterval = TickInterval;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetActorTickEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnabled                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetActorTickEnabled(bool bEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5d6df8b);

		AActor_SetActorTickEnabled_Params params;
		params.bEnabled = bEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetActorScale3D
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewScale3D                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetActorScale3D(const struct FVector& NewScale3D) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc895aa86);

		AActor_SetActorScale3D_Params params;
		params.NewScale3D = NewScale3D;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetActorRelativeScale3D
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewRelativeScale               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetActorRelativeScale3D(const struct FVector& NewRelativeScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3d5223e6);

		AActor_SetActorRelativeScale3D_Params params;
		params.NewRelativeScale = NewRelativeScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetActorHiddenInGame
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewHidden                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetActorHiddenInGame(bool bNewHidden) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3c488e4c);

		AActor_SetActorHiddenInGame_Params params;
		params.bNewHidden = bNewHidden;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.SetActorEnableCollision
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewActorEnableCollision       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::SetActorEnableCollision(bool bNewActorEnableCollision) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xad244e2e);

		AActor_SetActorEnableCollision_Params params;
		params.bNewActorEnableCollision = bNewActorEnableCollision;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.RemoveTickPrerequisiteComponent
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UActorComponent*         PrerequisiteComponent          (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void AActor::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3403f2a);

		AActor_RemoveTickPrerequisiteComponent_Params params;
		params.PrerequisiteComponent = PrerequisiteComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.RemoveTickPrerequisiteActor
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  PrerequisiteActor              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5bdbfd8);

		AActor_RemoveTickPrerequisiteActor_Params params;
		params.PrerequisiteActor = PrerequisiteActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveTick
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// float                          DeltaSeconds                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveTick(float DeltaSeconds) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x74be2234);

		AActor_ReceiveTick_Params params;
		params.DeltaSeconds = DeltaSeconds;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveRadialDamage
	// (FUNC_BlueprintAuthorityOnly, FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// float                          DamageReceived                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDamageType*             DamageType                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              HitInfo                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class AController*             InstigatedBy                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  DamageCauser                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveRadialDamage(float DamageReceived, class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x63fd58d9);

		AActor_ReceiveRadialDamage_Params params;
		params.DamageReceived = DamageReceived;
		params.DamageType = DamageType;
		params.Origin = Origin;
		params.HitInfo = HitInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceivePointDamage
	// (FUNC_BlueprintAuthorityOnly, FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// float                          Damage                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDamageType*             DamageType                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitNormal                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     HitComponent                   (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ShotFromDirection              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AController*             InstigatedBy                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  DamageCauser                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              HitInfo                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void AActor::ReceivePointDamage(float Damage, class UDamageType* DamageType, const struct FVector& HitLocation, const struct FVector& HitNormal, class UPrimitiveComponent* HitComponent, const struct FName& BoneName, const struct FVector& ShotFromDirection, class AController* InstigatedBy, class AActor* DamageCauser, const struct FHitResult& HitInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdd4c51ec);

		AActor_ReceivePointDamage_Params params;
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.HitLocation = HitLocation;
		params.HitNormal = HitNormal;
		params.HitComponent = HitComponent;
		params.BoneName = BoneName;
		params.ShotFromDirection = ShotFromDirection;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.HitInfo = HitInfo;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveHit
	// (FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// class UPrimitiveComponent*     MyComp                         (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// class AActor*                  Other                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     OtherComp                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// bool                           bSelfMoved                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitNormal                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NormalImpulse                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              Hit                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void AActor::ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8feb18b6);

		AActor_ReceiveHit_Params params;
		params.MyComp = MyComp;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.bSelfMoved = bSelfMoved;
		params.HitLocation = HitLocation;
		params.HitNormal = HitNormal;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveEndPlay
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<EEndPlayReason>    EndPlayReason                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveEndPlay(TEnumAsByte<EEndPlayReason> EndPlayReason) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf69b4904);

		AActor_ReceiveEndPlay_Params params;
		params.EndPlayReason = EndPlayReason;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveDestroyed
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void AActor::ReceiveDestroyed() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x205da6fc);

		AActor_ReceiveDestroyed_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveBeginPlay
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void AActor::ReceiveBeginPlay() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf09c1a48);

		AActor_ReceiveBeginPlay_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveAnyDamage
	// (FUNC_BlueprintAuthorityOnly, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// float                          Damage                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDamageType*             DamageType                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AController*             InstigatedBy                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  DamageCauser                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveAnyDamage(float Damage, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x39ef17b0);

		AActor_ReceiveAnyDamage_Params params;
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorOnReleased
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// struct FKey                    ButtonReleased                 (CPF_Parm)

	void AActor::ReceiveActorOnReleased(const struct FKey& ButtonReleased) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26ffbcdc);

		AActor_ReceiveActorOnReleased_Params params;
		params.ButtonReleased = ButtonReleased;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorOnInputTouchLeave
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<ETouchIndex>       FingerIndex                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveActorOnInputTouchLeave(TEnumAsByte<ETouchIndex> FingerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c67d589);

		AActor_ReceiveActorOnInputTouchLeave_Params params;
		params.FingerIndex = FingerIndex;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorOnInputTouchEnter
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<ETouchIndex>       FingerIndex                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveActorOnInputTouchEnter(TEnumAsByte<ETouchIndex> FingerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc9e0941e);

		AActor_ReceiveActorOnInputTouchEnter_Params params;
		params.FingerIndex = FingerIndex;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorOnInputTouchEnd
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<ETouchIndex>       FingerIndex                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveActorOnInputTouchEnd(TEnumAsByte<ETouchIndex> FingerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9be9cdd3);

		AActor_ReceiveActorOnInputTouchEnd_Params params;
		params.FingerIndex = FingerIndex;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorOnInputTouchBegin
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<ETouchIndex>       FingerIndex                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveActorOnInputTouchBegin(TEnumAsByte<ETouchIndex> FingerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4069f903);

		AActor_ReceiveActorOnInputTouchBegin_Params params;
		params.FingerIndex = FingerIndex;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorOnClicked
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// struct FKey                    ButtonPressed                  (CPF_Parm)

	void AActor::ReceiveActorOnClicked(const struct FKey& ButtonPressed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf14cc4ec);

		AActor_ReceiveActorOnClicked_Params params;
		params.ButtonPressed = ButtonPressed;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorEndOverlap
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AActor*                  OtherActor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveActorEndOverlap(class AActor* OtherActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xff29b09e);

		AActor_ReceiveActorEndOverlap_Params params;
		params.OtherActor = OtherActor;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorEndCursorOver
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void AActor::ReceiveActorEndCursorOver() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd2a5055);

		AActor_ReceiveActorEndCursorOver_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorBeginOverlap
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AActor*                  OtherActor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::ReceiveActorBeginOverlap(class AActor* OtherActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xac25bc36);

		AActor_ReceiveActorBeginOverlap_Params params;
		params.OtherActor = OtherActor;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.ReceiveActorBeginCursorOver
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void AActor::ReceiveActorBeginCursorOver() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x47697e9d);

		AActor_ReceiveActorBeginCursorOver_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.OnRep_ReplicateMovement
	// (FUNC_Native, FUNC_Public)

	void AActor::OnRep_ReplicateMovement() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16344927);

		AActor_OnRep_ReplicateMovement_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.OnRep_ReplicatedMovement
	// (FUNC_Native, FUNC_Public)

	void AActor::OnRep_ReplicatedMovement() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x82dad65b);

		AActor_OnRep_ReplicatedMovement_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.OnRep_Owner
	// (FUNC_Native, FUNC_Protected)

	void AActor::OnRep_Owner() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x224cd208);

		AActor_OnRep_Owner_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.OnRep_Instigator
	// (FUNC_Native, FUNC_Public)

	void AActor::OnRep_Instigator() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb32e42eb);

		AActor_OnRep_Instigator_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.OnRep_AttachmentReplication
	// (FUNC_Native, FUNC_Public)

	void AActor::OnRep_AttachmentReplication() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x568f2636);

		AActor_OnRep_AttachmentReplication_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.MakeNoise
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Loudness                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APawn*                   NoiseInstigator                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NoiseLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxRange                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   Tag                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::MakeNoise(float Loudness, class APawn* NoiseInstigator, const struct FVector& NoiseLocation, float MaxRange, const struct FName& Tag) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7bbac1bc);

		AActor_MakeNoise_Params params;
		params.Loudness = Loudness;
		params.NoiseInstigator = NoiseInstigator;
		params.NoiseLocation = NoiseLocation;
		params.MaxRange = MaxRange;
		params.Tag = Tag;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.MakeMIDForMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      Parent                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInstanceDynamic* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInstanceDynamic* AActor::MakeMIDForMaterial(class UMaterialInterface* Parent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x581f9d82);

		AActor_MakeMIDForMaterial_Params params;
		params.Parent = Parent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_TeleportTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 DestLocation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                DestRotation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::K2_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2905e9c);

		AActor_K2_TeleportTo_Params params;
		params.DestLocation = DestLocation;
		params.DestRotation = DestRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_SetActorTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              NewTransform                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::K2_SetActorTransform(const struct FTransform& NewTransform, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4c7ef9f);

		AActor_K2_SetActorTransform_Params params;
		params.NewTransform = NewTransform;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_SetActorRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTeleportPhysics               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::K2_SetActorRotation(const struct FRotator& NewRotation, bool bTeleportPhysics) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x74882097);

		AActor_K2_SetActorRotation_Params params;
		params.NewRotation = NewRotation;
		params.bTeleportPhysics = bTeleportPhysics;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_SetActorRelativeTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              NewRelativeTransform           (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_SetActorRelativeTransform(const struct FTransform& NewRelativeTransform, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xced053f7);

		AActor_K2_SetActorRelativeTransform_Params params;
		params.NewRelativeTransform = NewRelativeTransform;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.K2_SetActorRelativeRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                NewRelativeRotation            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_SetActorRelativeRotation(const struct FRotator& NewRelativeRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x66d06fcf);

		AActor_K2_SetActorRelativeRotation_Params params;
		params.NewRelativeRotation = NewRelativeRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.K2_SetActorRelativeLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewRelativeLocation            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_SetActorRelativeLocation(const struct FVector& NewRelativeLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x69816ef4);

		AActor_K2_SetActorRelativeLocation_Params params;
		params.NewRelativeLocation = NewRelativeLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.K2_SetActorLocationAndRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::K2_SetActorLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7ac7a34d);

		AActor_K2_SetActorLocationAndRotation_Params params;
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_SetActorLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::K2_SetActorLocation(const struct FVector& NewLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x432757ec);

		AActor_K2_SetActorLocation_Params params;
		params.NewLocation = NewLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_OnReset
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void AActor::K2_OnReset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c0d266e);

		AActor_K2_OnReset_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_OnEndViewTarget
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       PC                             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_OnEndViewTarget(class APlayerController* PC) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x36b04a64);

		AActor_K2_OnEndViewTarget_Params params;
		params.PC = PC;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_OnBecomeViewTarget
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       PC                             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_OnBecomeViewTarget(class APlayerController* PC) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdce07a0a);

		AActor_K2_OnBecomeViewTarget_Params params;
		params.PC = PC;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_GetRootComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class USceneComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class USceneComponent* AActor::K2_GetRootComponent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd40cde4b);

		AActor_K2_GetRootComponent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_GetActorRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator AActor::K2_GetActorRotation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79bead8b);

		AActor_K2_GetActorRotation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_GetActorLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AActor::K2_GetActorLocation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6c39a630);

		AActor_K2_GetActorLocation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.K2_DetachFromActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EDetachmentRule>   LocationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EDetachmentRule>   RotationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EDetachmentRule>   ScaleRule                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_DetachFromActor(TEnumAsByte<EDetachmentRule> LocationRule, TEnumAsByte<EDetachmentRule> RotationRule, TEnumAsByte<EDetachmentRule> ScaleRule) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x654907ee);

		AActor_K2_DetachFromActor_Params params;
		params.LocationRule = LocationRule;
		params.RotationRule = RotationRule;
		params.ScaleRule = ScaleRule;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_DestroyComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UActorComponent*         Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void AActor::K2_DestroyComponent(class UActorComponent* Component) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6375d8e1);

		AActor_K2_DestroyComponent_Params params;
		params.Component = Component;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_DestroyActor
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AActor::K2_DestroyActor() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe77cf1ef);

		AActor_K2_DestroyActor_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_AttachToComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         Parent                         (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   SocketName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   LocationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   RotationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   ScaleRule                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bWeldSimulatedBodies           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AttachToComponent(class USceneComponent* Parent, const struct FName& SocketName, TEnumAsByte<EAttachmentRule> LocationRule, TEnumAsByte<EAttachmentRule> RotationRule, TEnumAsByte<EAttachmentRule> ScaleRule, bool bWeldSimulatedBodies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4e59d8cf);

		AActor_K2_AttachToComponent_Params params;
		params.Parent = Parent;
		params.SocketName = SocketName;
		params.LocationRule = LocationRule;
		params.RotationRule = RotationRule;
		params.ScaleRule = ScaleRule;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_AttachToActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  ParentActor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   SocketName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   LocationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   RotationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   ScaleRule                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bWeldSimulatedBodies           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AttachToActor(class AActor* ParentActor, const struct FName& SocketName, TEnumAsByte<EAttachmentRule> LocationRule, TEnumAsByte<EAttachmentRule> RotationRule, TEnumAsByte<EAttachmentRule> ScaleRule, bool bWeldSimulatedBodies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef0e679d);

		AActor_K2_AttachToActor_Params params;
		params.ParentActor = ParentActor;
		params.SocketName = SocketName;
		params.LocationRule = LocationRule;
		params.RotationRule = RotationRule;
		params.ScaleRule = ScaleRule;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_AttachRootComponentToActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  InParentActor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachLocation>   AttachLocationType             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bWeldSimulatedBodies           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AttachRootComponentToActor(class AActor* InParentActor, const struct FName& InSocketName, TEnumAsByte<EAttachLocation> AttachLocationType, bool bWeldSimulatedBodies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2c084c);

		AActor_K2_AttachRootComponentToActor_Params params;
		params.InParentActor = InParentActor;
		params.InSocketName = InSocketName;
		params.AttachLocationType = AttachLocationType;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_AttachRootComponentTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         InParent                       (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachLocation>   AttachLocationType             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bWeldSimulatedBodies           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AttachRootComponentTo(class USceneComponent* InParent, const struct FName& InSocketName, TEnumAsByte<EAttachLocation> AttachLocationType, bool bWeldSimulatedBodies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb145355);

		AActor_K2_AttachRootComponentTo_Params params;
		params.InParent = InParent;
		params.InSocketName = InSocketName;
		params.AttachLocationType = AttachLocationType;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.K2_AddActorWorldTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              DeltaTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AddActorWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe0ab1b06);

		AActor_K2_AddActorWorldTransform_Params params;
		params.DeltaTransform = DeltaTransform;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.K2_AddActorWorldRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                DeltaRotation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AddActorWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3a9bc8b8);

		AActor_K2_AddActorWorldRotation_Params params;
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.K2_AddActorWorldOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 DeltaLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AddActorWorldOffset(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd760a9b7);

		AActor_K2_AddActorWorldOffset_Params params;
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.K2_AddActorLocalTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              NewTransform                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AddActorLocalTransform(const struct FTransform& NewTransform, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa446ae69);

		AActor_K2_AddActorLocalTransform_Params params;
		params.NewTransform = NewTransform;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.K2_AddActorLocalRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                DeltaRotation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AddActorLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb1bfcb15);

		AActor_K2_AddActorLocalRotation_Params params;
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.K2_AddActorLocalOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 DeltaLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::K2_AddActorLocalOffset(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89cda6d6);

		AActor_K2_AddActorLocalOffset_Params params;
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.Actor.IsOverlappingActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  Other                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::IsOverlappingActor(class AActor* Other) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb085939c);

		AActor_IsOverlappingActor_Params params;
		params.Other = Other;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.IsChildActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::IsChildActor() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6555d425);

		AActor_IsChildActor_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.IsActorTickEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::IsActorTickEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc04240c3);

		AActor_IsActorTickEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.IsActorBeingDestroyed
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::IsActorBeingDestroyed() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x745141d);

		AActor_IsActorBeingDestroyed_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.HasAuthority
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::HasAuthority() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x806e2727);

		AActor_HasAuthority_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetVerticalDistanceTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  OtherActor                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetVerticalDistanceTo(class AActor* OtherActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x49fa1464);

		AActor_GetVerticalDistanceTo_Params params;
		params.OtherActor = OtherActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetVelocity
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AActor::GetVelocity() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbf4b935);

		AActor_GetVelocity_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform AActor::GetTransform() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xce78358);

		AActor_GetTransform_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetTickableWhenPaused
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::GetTickableWhenPaused() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37573169);

		AActor_GetTickableWhenPaused_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetSquaredDistanceTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  OtherActor                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetSquaredDistanceTo(class AActor* OtherActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc6c9b3d);

		AActor_GetSquaredDistanceTo_Params params;
		params.OtherActor = OtherActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetRemoteRole
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ENetRole>          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<ENetRole> AActor::GetRemoteRole() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c379aae);

		AActor_GetRemoteRole_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetParentComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UChildActorComponent*    ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UChildActorComponent* AActor::GetParentComponent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6e663ee9);

		AActor_GetParentComponent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetParentActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* AActor::GetParentActor() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1f29cfd7);

		AActor_GetParentActor_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetOwner
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* AActor::GetOwner() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x750df491);

		AActor_GetOwner_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetOverlappingComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<class UPrimitiveComponent*> OverlappingComponents          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void AActor::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* OverlappingComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xba49f55);

		AActor_GetOverlappingComponents_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OverlappingComponents != nullptr)
			*OverlappingComponents = params.OverlappingComponents;
	}


	// Function Engine.Actor.GetOverlappingActors
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<class AActor*>          OverlappingActors              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// class UClass*                  ClassFilter                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::GetOverlappingActors(class UClass* ClassFilter, TArray<class AActor*>* OverlappingActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x257a8fe3);

		AActor_GetOverlappingActors_Params params;
		params.ClassFilter = ClassFilter;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OverlappingActors != nullptr)
			*OverlappingActors = params.OverlappingActors;
	}


	// Function Engine.Actor.GetLifeSpan
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetLifeSpan() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1ac525a);

		AActor_GetLifeSpan_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetInstigatorController
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AController*             ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AController* AActor::GetInstigatorController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8059b794);

		AActor_GetInstigatorController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetInstigator
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APawn*                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APawn* AActor::GetInstigator() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x23008d24);

		AActor_GetInstigator_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetInputVectorAxisValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    InputAxisKey                   (CPF_ConstParm, CPF_Parm)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AActor::GetInputVectorAxisValue(const struct FKey& InputAxisKey) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x87cf0fe9);

		AActor_GetInputVectorAxisValue_Params params;
		params.InputAxisKey = InputAxisKey;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetInputAxisValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InputAxisName                  (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetInputAxisValue(const struct FName& InputAxisName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8e9a971a);

		AActor_GetInputAxisValue_Params params;
		params.InputAxisName = InputAxisName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetInputAxisKeyValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    InputAxisKey                   (CPF_ConstParm, CPF_Parm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetInputAxisKeyValue(const struct FKey& InputAxisKey) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xba096e8b);

		AActor_GetInputAxisKeyValue_Params params;
		params.InputAxisKey = InputAxisKey;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetHorizontalDotProductTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  OtherActor                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetHorizontalDotProductTo(class AActor* OtherActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb94e1ce5);

		AActor_GetHorizontalDotProductTo_Params params;
		params.OtherActor = OtherActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetHorizontalDistanceTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  OtherActor                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetHorizontalDistanceTo(class AActor* OtherActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7a61468e);

		AActor_GetHorizontalDistanceTo_Params params;
		params.OtherActor = OtherActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetGameTimeSinceCreation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetGameTimeSinceCreation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2a1af042);

		AActor_GetGameTimeSinceCreation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetDotProductTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  OtherActor                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetDotProductTo(class AActor* OtherActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18ba972d);

		AActor_GetDotProductTo_Params params;
		params.OtherActor = OtherActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetDistanceTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  OtherActor                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetDistanceTo(class AActor* OtherActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2cd6f296);

		AActor_GetDistanceTo_Params params;
		params.OtherActor = OtherActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetComponentsByTag
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UClass*                  ComponentClass                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   Tag                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class UActorComponent*> ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<class UActorComponent*> AActor::GetComponentsByTag(class UClass* ComponentClass, const struct FName& Tag) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x35dc6339);

		AActor_GetComponentsByTag_Params params;
		params.ComponentClass = ComponentClass;
		params.Tag = Tag;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetComponentsByClass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UClass*                  ComponentClass                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class UActorComponent*> ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<class UActorComponent*> AActor::GetComponentsByClass(class UClass* ComponentClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9b5fe25d);

		AActor_GetComponentsByClass_Params params;
		params.ComponentClass = ComponentClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetComponentByClass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UClass*                  ComponentClass                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UActorComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UActorComponent* AActor::GetComponentByClass(class UClass* ComponentClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x849d9e32);

		AActor_GetComponentByClass_Params params;
		params.ComponentClass = ComponentClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetAttachedActors
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void AActor::GetAttachedActors(TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xee421f5a);

		AActor_GetAttachedActors_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}


	// Function Engine.Actor.GetAllChildActors
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<class AActor*>          ChildActors                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIncludeDescendants            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::GetAllChildActors(bool bIncludeDescendants, TArray<class AActor*>* ChildActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe764deef);

		AActor_GetAllChildActors_Params params;
		params.bIncludeDescendants = bIncludeDescendants;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (ChildActors != nullptr)
			*ChildActors = params.ChildActors;
	}


	// Function Engine.Actor.GetActorUpVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AActor::GetActorUpVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9e27fcd);

		AActor_GetActorUpVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetActorTimeDilation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetActorTimeDilation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x273a275a);

		AActor_GetActorTimeDilation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetActorTickInterval
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AActor::GetActorTickInterval() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x795d578f);

		AActor_GetActorTickInterval_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetActorScale3D
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AActor::GetActorScale3D() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x388e6ba2);

		AActor_GetActorScale3D_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetActorRightVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AActor::GetActorRightVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x542027b6);

		AActor_GetActorRightVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetActorRelativeScale3D
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AActor::GetActorRelativeScale3D() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89b9814a);

		AActor_GetActorRelativeScale3D_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetActorForwardVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AActor::GetActorForwardVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf36044b3);

		AActor_GetActorForwardVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetActorEyesViewPoint
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 OutLocation                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                OutRotation                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::GetActorEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x161f6ca0);

		AActor_GetActorEyesViewPoint_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}


	// Function Engine.Actor.GetActorEnableCollision
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::GetActorEnableCollision() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6aaf527a);

		AActor_GetActorEnableCollision_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.GetActorBounds
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           bOnlyCollidingComponents       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxExtent                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::GetActorBounds(bool bOnlyCollidingComponents, struct FVector* Origin, struct FVector* BoxExtent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc7dadc68);

		AActor_GetActorBounds_Params params;
		params.bOnlyCollidingComponents = bOnlyCollidingComponents;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Origin != nullptr)
			*Origin = params.Origin;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
	}


	// Function Engine.Actor.ForceNetUpdate
	// (FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AActor::ForceNetUpdate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd9054d6d);

		AActor_ForceNetUpdate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.FlushNetDormancy
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AActor::FlushNetDormancy() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x623cff4a);

		AActor_FlushNetDormancy_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.EnableInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class APlayerController*       PlayerController               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::EnableInput(class APlayerController* PlayerController) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef08e057);

		AActor_EnableInput_Params params;
		params.PlayerController = PlayerController;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.DisableInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class APlayerController*       PlayerController               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::DisableInput(class APlayerController* PlayerController) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x22addf90);

		AActor_DisableInput_Params params;
		params.PlayerController = PlayerController;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.DetachRootComponentFromParent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bMaintainWorldPosition         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::DetachRootComponentFromParent(bool bMaintainWorldPosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x56c9125e);

		AActor_DetachRootComponentFromParent_Params params;
		params.bMaintainWorldPosition = bMaintainWorldPosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.AddTickPrerequisiteComponent
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UActorComponent*         PrerequisiteComponent          (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void AActor::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd2ec0891);

		AActor_AddTickPrerequisiteComponent_Params params;
		params.PrerequisiteComponent = PrerequisiteComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.AddTickPrerequisiteActor
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  PrerequisiteActor              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AActor::AddTickPrerequisiteActor(class AActor* PrerequisiteActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb434ee5f);

		AActor_AddTickPrerequisiteActor_Params params;
		params.PrerequisiteActor = PrerequisiteActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Actor.AddComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   TemplateName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bManualAttachment              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              RelativeTransform              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class UObject*                 ComponentTemplateContext       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UActorComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UActorComponent* AActor::AddComponent(const struct FName& TemplateName, bool bManualAttachment, const struct FTransform& RelativeTransform, class UObject* ComponentTemplateContext) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf4a7db1a);

		AActor_AddComponent_Params params;
		params.TemplateName = TemplateName;
		params.bManualAttachment = bManualAttachment;
		params.RelativeTransform = RelativeTransform;
		params.ComponentTemplateContext = ComponentTemplateContext;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Actor.ActorHasTag
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   Tag                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AActor::ActorHasTag(const struct FName& Tag) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3d94a37);

		AActor_ActorHasTag_Params params;
		params.Tag = Tag;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HUD.ShowHUD
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void AHUD::ShowHUD() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef737e02);

		AHUD_ShowHUD_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.ShowDebugToggleSubCategory
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   Category                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::ShowDebugToggleSubCategory(const struct FName& Category) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x603d19ca);

		AHUD_ShowDebugToggleSubCategory_Params params;
		params.Category = Category;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.ShowDebugForReticleTargetToggle
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// class UClass*                  DesiredClass                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::ShowDebugForReticleTargetToggle(class UClass* DesiredClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x74bcbe74);

		AHUD_ShowDebugForReticleTargetToggle_Params params;
		params.DesiredClass = DesiredClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.ShowDebug
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   DebugType                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::ShowDebug(const struct FName& DebugType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3ded83d8);

		AHUD_ShowDebug_Params params;
		params.DebugType = DebugType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.RemoveDebugText
	// (FUNC_Final, FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class AActor*                  SrcActor                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLeaveDurationText             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::RemoveDebugText(class AActor* SrcActor, bool bLeaveDurationText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x84240a24);

		AHUD_RemoveDebugText_Params params;
		params.SrcActor = SrcActor;
		params.bLeaveDurationText = bLeaveDurationText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.RemoveAllDebugStrings
	// (FUNC_Final, FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void AHUD::RemoveAllDebugStrings() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb8426da4);

		AHUD_RemoveAllDebugStrings_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.ReceiveHitBoxRelease
	// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// struct FName                   BoxName                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::ReceiveHitBoxRelease(const struct FName& BoxName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe97ee760);

		AHUD_ReceiveHitBoxRelease_Params params;
		params.BoxName = BoxName;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.ReceiveHitBoxEndCursorOver
	// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// struct FName                   BoxName                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::ReceiveHitBoxEndCursorOver(const struct FName& BoxName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1f236230);

		AHUD_ReceiveHitBoxEndCursorOver_Params params;
		params.BoxName = BoxName;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.ReceiveHitBoxClick
	// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// struct FName                   BoxName                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::ReceiveHitBoxClick(const struct FName& BoxName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb7304e9f);

		AHUD_ReceiveHitBoxClick_Params params;
		params.BoxName = BoxName;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.ReceiveHitBoxBeginCursorOver
	// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// struct FName                   BoxName                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::ReceiveHitBoxBeginCursorOver(const struct FName& BoxName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa6b92834);

		AHUD_ReceiveHitBoxBeginCursorOver_Params params;
		params.BoxName = BoxName;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.ReceiveDrawHUD
	// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// int                            SizeX                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            SizeY                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::ReceiveDrawHUD(int SizeX, int SizeY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4c9f6ee4);

		AHUD_ReceiveDrawHUD_Params params;
		params.SizeX = SizeX;
		params.SizeY = SizeY;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.Project
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector AHUD::Project(const struct FVector& Location) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4afb4ca3);

		AHUD_Project_Params params;
		params.Location = Location;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HUD.GetTextSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FString                 Text                           (CPF_Parm, CPF_ZeroConstructor)
	// float                          OutWidth                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutHeight                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UFont*                   Font                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::GetTextSize(const struct FString& Text, class UFont* Font, float Scale, float* OutWidth, float* OutHeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x693b6dd2);

		AHUD_GetTextSize_Params params;
		params.Text = Text;
		params.Font = Font;
		params.Scale = Scale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutWidth != nullptr)
			*OutWidth = params.OutWidth;
		if (OutHeight != nullptr)
			*OutHeight = params.OutHeight;
	}


	// Function Engine.HUD.GetOwningPlayerController
	// (FUNC_Final, FUNC_Native, FUNC_Protected, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APlayerController*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APlayerController* AHUD::GetOwningPlayerController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5e928a43);

		AHUD_GetOwningPlayerController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HUD.GetOwningPawn
	// (FUNC_Final, FUNC_Native, FUNC_Protected, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APawn*                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APawn* AHUD::GetOwningPawn() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7a399d02);

		AHUD_GetOwningPawn_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HUD.GetActorsInSelectionRectangle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UClass*                  ClassFilter                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               FirstPoint                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector2D               SecondPoint                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIncludeNonCollidingComponents (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bActorMustBeFullyEnclosed      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::GetActorsInSelectionRectangle(class UClass* ClassFilter, const struct FVector2D& FirstPoint, const struct FVector2D& SecondPoint, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7da784be);

		AHUD_GetActorsInSelectionRectangle_Params params;
		params.ClassFilter = ClassFilter;
		params.FirstPoint = FirstPoint;
		params.SecondPoint = SecondPoint;
		params.bIncludeNonCollidingComponents = bIncludeNonCollidingComponents;
		params.bActorMustBeFullyEnclosed = bActorMustBeFullyEnclosed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}


	// Function Engine.HUD.DrawTextureSimple
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture*                Texture                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenX                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenY                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bScalePosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::DrawTextureSimple(class UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96145699);

		AHUD_DrawTextureSimple_Params params;
		params.Texture = Texture;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.DrawTexture
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture*                Texture                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenX                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenY                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenW                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenH                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TextureU                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TextureV                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TextureUWidth                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TextureVHeight                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TintColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBlendMode>        BlendMode                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bScalePosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               RotPivot                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::DrawTexture(class UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, const struct FLinearColor& TintColor, TEnumAsByte<EBlendMode> BlendMode, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcaccda73);

		AHUD_DrawTexture_Params params;
		params.Texture = Texture;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.ScreenW = ScreenW;
		params.ScreenH = ScreenH;
		params.TextureU = TextureU;
		params.TextureV = TextureV;
		params.TextureUWidth = TextureUWidth;
		params.TextureVHeight = TextureVHeight;
		params.TintColor = TintColor;
		params.BlendMode = BlendMode;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;
		params.Rotation = Rotation;
		params.RotPivot = RotPivot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.DrawText
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 Text                           (CPF_Parm, CPF_ZeroConstructor)
	// struct FLinearColor            TextColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenX                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenY                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UFont*                   Font                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bScalePosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::DrawText(const struct FString& Text, const struct FLinearColor& TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3013d707);

		AHUD_DrawText_Params params;
		params.Text = Text;
		params.TextColor = TextColor;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.Font = Font;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.DrawRect
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            RectColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenX                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenY                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenW                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenH                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::DrawRect(const struct FLinearColor& RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x10f5b564);

		AHUD_DrawRect_Params params;
		params.RectColor = RectColor;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.ScreenW = ScreenW;
		params.ScreenH = ScreenH;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.DrawMaterialTriangle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               V0_Pos                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               V1_Pos                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               V2_Pos                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               V0_UV                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               V1_UV                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               V2_UV                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            V0_Color                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            V1_Color                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            V2_Color                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::DrawMaterialTriangle(class UMaterialInterface* Material, const struct FVector2D& V0_Pos, const struct FVector2D& V1_Pos, const struct FVector2D& V2_Pos, const struct FVector2D& V0_UV, const struct FVector2D& V1_UV, const struct FVector2D& V2_UV, const struct FLinearColor& V0_Color, const struct FLinearColor& V1_Color, const struct FLinearColor& V2_Color) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf4ace9cd);

		AHUD_DrawMaterialTriangle_Params params;
		params.Material = Material;
		params.V0_Pos = V0_Pos;
		params.V1_Pos = V1_Pos;
		params.V2_Pos = V2_Pos;
		params.V0_UV = V0_UV;
		params.V1_UV = V1_UV;
		params.V2_UV = V2_UV;
		params.V0_Color = V0_Color;
		params.V1_Color = V1_Color;
		params.V2_Color = V2_Color;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.DrawMaterialSimple
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenX                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenY                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenW                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenH                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bScalePosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::DrawMaterialSimple(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2979a5a3);

		AHUD_DrawMaterialSimple_Params params;
		params.Material = Material;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.ScreenW = ScreenW;
		params.ScreenH = ScreenH;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.DrawMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenX                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenY                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenW                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenH                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaterialU                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaterialV                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaterialUWidth                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaterialVHeight                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bScalePosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               RotPivot                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::DrawMaterial(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd6f3ae99);

		AHUD_DrawMaterial_Params params;
		params.Material = Material;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.ScreenW = ScreenW;
		params.ScreenH = ScreenH;
		params.MaterialU = MaterialU;
		params.MaterialV = MaterialV;
		params.MaterialUWidth = MaterialUWidth;
		params.MaterialVHeight = MaterialVHeight;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;
		params.Rotation = Rotation;
		params.RotPivot = RotPivot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.DrawLine
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// float                          StartScreenX                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartScreenY                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          EndScreenX                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          EndScreenY                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LineThickness                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, const struct FLinearColor& LineColor, float LineThickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb442401c);

		AHUD_DrawLine_Params params;
		params.StartScreenX = StartScreenX;
		params.StartScreenY = StartScreenY;
		params.EndScreenX = EndScreenX;
		params.EndScreenY = EndScreenY;
		params.LineColor = LineColor;
		params.LineThickness = LineThickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.Deproject
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ScreenX                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenY                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldPosition                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldDirection                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::Deproject(float ScreenX, float ScreenY, struct FVector* WorldPosition, struct FVector* WorldDirection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3e99b52c);

		AHUD_Deproject_Params params;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (WorldPosition != nullptr)
			*WorldPosition = params.WorldPosition;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;
	}


	// Function Engine.HUD.AddHitBox
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               Position                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               Size                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bConsumesInput                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Priority                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::AddHitBox(const struct FVector2D& Position, const struct FVector2D& Size, const struct FName& InName, bool bConsumesInput, int Priority) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1a0015a3);

		AHUD_AddHitBox_Params params;
		params.Position = Position;
		params.Size = Size;
		params.InName = InName;
		params.bConsumesInput = bConsumesInput;
		params.Priority = Priority;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HUD.AddDebugText
	// (FUNC_Final, FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// struct FString                 DebugText                      (CPF_Parm, CPF_ZeroConstructor)
	// class AActor*                  SrcActor                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Offset                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 DesiredOffset                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FColor                  TextColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSkipOverwriteCheck            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAbsoluteLocation              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bKeepAttachedToActor           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UFont*                   InFont                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FontScale                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bDrawShadow                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AHUD::AddDebugText(const struct FString& DebugText, class AActor* SrcActor, float Duration, const struct FVector& Offset, const struct FVector& DesiredOffset, const struct FColor& TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont, float FontScale, bool bDrawShadow) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x532b127f);

		AHUD_AddDebugText_Params params;
		params.DebugText = DebugText;
		params.SrcActor = SrcActor;
		params.Duration = Duration;
		params.Offset = Offset;
		params.DesiredOffset = DesiredOffset;
		params.TextColor = TextColor;
		params.bSkipOverwriteCheck = bSkipOverwriteCheck;
		params.bAbsoluteLocation = bAbsoluteLocation;
		params.bKeepAttachedToActor = bKeepAttachedToActor;
		params.InFont = InFont;
		params.FontScale = FontScale;
		params.bDrawShadow = bDrawShadow;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimNotify.Received_Notify
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// class USkeletalMeshComponent*  MeshComp                       (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// class UAnimSequenceBase*       Animation                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimNotify::Received_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2fe334c2);

		UAnimNotify_Received_Notify_Params params;
		params.MeshComp = MeshComp;
		params.Animation = Animation;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimNotify.GetNotifyName
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UAnimNotify::GetNotifyName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd3d01877);

		UAnimNotify_GetNotifyName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ActorComponent.ToggleActive
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UActorComponent::ToggleActive() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcbbbfc71);

		UActorComponent_ToggleActive_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.SetTickGroup
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ETickingGroup>     NewTickGroup                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::SetTickGroup(TEnumAsByte<ETickingGroup> NewTickGroup) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb346aa93);

		UActorComponent_SetTickGroup_Params params;
		params.NewTickGroup = NewTickGroup;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.SetTickableWhenPaused
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bTickableWhenPaused            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::SetTickableWhenPaused(bool bTickableWhenPaused) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x149aa818);

		UActorComponent_SetTickableWhenPaused_Params params;
		params.bTickableWhenPaused = bTickableWhenPaused;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.SetIsReplicated
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ShouldReplicate                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::SetIsReplicated(bool ShouldReplicate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x292f0742);

		UActorComponent_SetIsReplicated_Params params;
		params.ShouldReplicate = ShouldReplicate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.SetComponentTickInterval
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          TickInterval                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::SetComponentTickInterval(float TickInterval) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xabbb645a);

		UActorComponent_SetComponentTickInterval_Params params;
		params.TickInterval = TickInterval;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.SetComponentTickEnabled
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnabled                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::SetComponentTickEnabled(bool bEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdb85b98c);

		UActorComponent_SetComponentTickEnabled_Params params;
		params.bEnabled = bEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.SetActive
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewActive                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bReset                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::SetActive(bool bNewActive, bool bReset) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x94b6c473);

		UActorComponent_SetActive_Params params;
		params.bNewActive = bNewActive;
		params.bReset = bReset;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.RemoveTickPrerequisiteComponent
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UActorComponent*         PrerequisiteComponent          (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void UActorComponent::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc76fc72f);

		UActorComponent_RemoveTickPrerequisiteComponent_Params params;
		params.PrerequisiteComponent = PrerequisiteComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.RemoveTickPrerequisiteActor
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  PrerequisiteActor              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x42f68cfd);

		UActorComponent_RemoveTickPrerequisiteActor_Params params;
		params.PrerequisiteActor = PrerequisiteActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.ReceiveTick
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// float                          DeltaSeconds                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::ReceiveTick(float DeltaSeconds) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x332a95c1);

		UActorComponent_ReceiveTick_Params params;
		params.DeltaSeconds = DeltaSeconds;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.ReceiveEndPlay
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<EEndPlayReason>    EndPlayReason                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::ReceiveEndPlay(TEnumAsByte<EEndPlayReason> EndPlayReason) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb9058b33);

		UActorComponent_ReceiveEndPlay_Params params;
		params.EndPlayReason = EndPlayReason;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.ReceiveBeginPlay
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void UActorComponent::ReceiveBeginPlay() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9f33652b);

		UActorComponent_ReceiveBeginPlay_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.OnRep_IsActive
	// (FUNC_Final, FUNC_Native, FUNC_Public)

	void UActorComponent::OnRep_IsActive() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa04da486);

		UActorComponent_OnRep_IsActive_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.K2_DestroyComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::K2_DestroyComponent(class UObject* Object) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x28485444);

		UActorComponent_K2_DestroyComponent_Params params;
		params.Object = Object;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.IsComponentTickEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UActorComponent::IsComponentTickEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4a3c676);

		UActorComponent_IsComponentTickEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ActorComponent.IsBeingDestroyed
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UActorComponent::IsBeingDestroyed() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x194c9ced);

		UActorComponent_IsBeingDestroyed_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ActorComponent.IsActive
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UActorComponent::IsActive() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xad8fc231);

		UActorComponent_IsActive_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ActorComponent.GetOwner
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* UActorComponent::GetOwner() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x493cfdca);

		UActorComponent_GetOwner_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ActorComponent.GetComponentTickInterval
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UActorComponent::GetComponentTickInterval() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f8d36ae);

		UActorComponent_GetComponentTickInterval_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ActorComponent.Deactivate
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UActorComponent::Deactivate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4aa98375);

		UActorComponent_Deactivate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.ComponentHasTag
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   Tag                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UActorComponent::ComponentHasTag(const struct FName& Tag) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3cb26664);

		UActorComponent_ComponentHasTag_Params params;
		params.Tag = Tag;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ActorComponent.AddTickPrerequisiteComponent
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UActorComponent*         PrerequisiteComponent          (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void UActorComponent::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x41871822);

		UActorComponent_AddTickPrerequisiteComponent_Params params;
		params.PrerequisiteComponent = PrerequisiteComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.AddTickPrerequisiteActor
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  PrerequisiteActor              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::AddTickPrerequisiteActor(class AActor* PrerequisiteActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb1c94290);

		UActorComponent_AddTickPrerequisiteActor_Params params;
		params.PrerequisiteActor = PrerequisiteActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ActorComponent.Activate
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bReset                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UActorComponent::Activate(bool bReset) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdd4c2c7c);

		UActorComponent_Activate_Params params;
		params.bReset = bReset;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.ToggleVisibility
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bPropagateToChildren           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::ToggleVisibility(bool bPropagateToChildren) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76bc913c);

		USceneComponent_ToggleVisibility_Params params;
		params.bPropagateToChildren = bPropagateToChildren;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.SnapTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         InParent                       (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USceneComponent::SnapTo(class USceneComponent* InParent, const struct FName& InSocketName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7c5b0c93);

		USceneComponent_SnapTo_Params params;
		params.InParent = InParent;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.SetWorldScale3D
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewScale                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::SetWorldScale3D(const struct FVector& NewScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf555967f);

		USceneComponent_SetWorldScale3D_Params params;
		params.NewScale = NewScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.SetVisibility
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewVisibility                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPropagateToChildren           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::SetVisibility(bool bNewVisibility, bool bPropagateToChildren) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x646e90a8);

		USceneComponent_SetVisibility_Params params;
		params.bNewVisibility = bNewVisibility;
		params.bPropagateToChildren = bPropagateToChildren;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.SetRelativeScale3D
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewScale3D                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::SetRelativeScale3D(const struct FVector& NewScale3D) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x65b0e7bb);

		USceneComponent_SetRelativeScale3D_Params params;
		params.NewScale3D = NewScale3D;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.SetIsAttachmentReplicated
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ShouldReplicate                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::SetIsAttachmentReplicated(bool ShouldReplicate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x125f0574);

		USceneComponent_SetIsAttachmentReplicated_Params params;
		params.ShouldReplicate = ShouldReplicate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.SetIsAttachmentReferenceReplicated
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ShouldReplicate                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::SetIsAttachmentReferenceReplicated(bool ShouldReplicate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3110e3cd);

		USceneComponent_SetIsAttachmentReferenceReplicated_Params params;
		params.ShouldReplicate = ShouldReplicate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.SetHiddenInGame
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           NewHidden                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPropagateToChildren           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::SetHiddenInGame(bool NewHidden, bool bPropagateToChildren) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x35eaa197);

		USceneComponent_SetHiddenInGame_Params params;
		params.NewHidden = NewHidden;
		params.bPropagateToChildren = bPropagateToChildren;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.SetAbsolute
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewAbsoluteLocation           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bNewAbsoluteRotation           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bNewAbsoluteScale              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa51f52d3);

		USceneComponent_SetAbsolute_Params params;
		params.bNewAbsoluteLocation = bNewAbsoluteLocation;
		params.bNewAbsoluteRotation = bNewAbsoluteRotation;
		params.bNewAbsoluteScale = bNewAbsoluteScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.ResetRelativeTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USceneComponent::ResetRelativeTransform() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd60625ef);

		USceneComponent_ResetRelativeTransform_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.OnRep_Visibility
	// (FUNC_Final, FUNC_Native, FUNC_Private)
	// Parameters:
	// bool                           OldValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::OnRep_Visibility(bool OldValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x404a0e07);

		USceneComponent_OnRep_Visibility_Params params;
		params.OldValue = OldValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.OnRep_Transform
	// (FUNC_Final, FUNC_Native, FUNC_Private)

	void USceneComponent::OnRep_Transform() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf9094a9);

		USceneComponent_OnRep_Transform_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.OnRep_AttachSocketName
	// (FUNC_Final, FUNC_Native, FUNC_Private)

	void USceneComponent::OnRep_AttachSocketName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x660c6a7a);

		USceneComponent_OnRep_AttachSocketName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.OnRep_AttachParent
	// (FUNC_Final, FUNC_Native, FUNC_Private)

	void USceneComponent::OnRep_AttachParent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa503188c);

		USceneComponent_OnRep_AttachParent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.OnRep_AttachChildren
	// (FUNC_Final, FUNC_Native, FUNC_Private)

	void USceneComponent::OnRep_AttachChildren() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf46a991);

		USceneComponent_OnRep_AttachChildren_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.K2_SetWorldTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              NewTransform                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_SetWorldTransform(const struct FTransform& NewTransform, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa5e89f36);

		USceneComponent_K2_SetWorldTransform_Params params;
		params.NewTransform = NewTransform;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_SetWorldRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_SetWorldRotation(const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x31e32e8);

		USceneComponent_K2_SetWorldRotation_Params params;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_SetWorldLocationAndRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_SetWorldLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcb823150);

		USceneComponent_K2_SetWorldLocationAndRotation_Params params;
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_SetWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_SetWorldLocation(const struct FVector& NewLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x81da1c7b);

		USceneComponent_K2_SetWorldLocation_Params params;
		params.NewLocation = NewLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_SetRelativeTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              NewTransform                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_SetRelativeTransform(const struct FTransform& NewTransform, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x554ba4e2);

		USceneComponent_K2_SetRelativeTransform_Params params;
		params.NewTransform = NewTransform;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_SetRelativeRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_SetRelativeRotation(const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x98c4982c);

		USceneComponent_K2_SetRelativeRotation_Params params;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_SetRelativeLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x34d07cf4);

		USceneComponent_K2_SetRelativeLocationAndRotation_Params params;
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_SetRelativeLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_SetRelativeLocation(const struct FVector& NewLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x390f1e6f);

		USceneComponent_K2_SetRelativeLocation_Params params;
		params.NewLocation = NewLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_GetComponentToWorld
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform USceneComponent::K2_GetComponentToWorld() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79c50844);

		USceneComponent_K2_GetComponentToWorld_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.K2_GetComponentScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USceneComponent::K2_GetComponentScale() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x42e21727);

		USceneComponent_K2_GetComponentScale_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.K2_GetComponentRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator USceneComponent::K2_GetComponentRotation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x49b8d511);

		USceneComponent_K2_GetComponentRotation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.K2_GetComponentLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USceneComponent::K2_GetComponentLocation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaa5a6d36);

		USceneComponent_K2_GetComponentLocation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.K2_DetachFromComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EDetachmentRule>   LocationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EDetachmentRule>   RotationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EDetachmentRule>   ScaleRule                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bCallModify                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_DetachFromComponent(TEnumAsByte<EDetachmentRule> LocationRule, TEnumAsByte<EDetachmentRule> RotationRule, TEnumAsByte<EDetachmentRule> ScaleRule, bool bCallModify) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8fb6da94);

		USceneComponent_K2_DetachFromComponent_Params params;
		params.LocationRule = LocationRule;
		params.RotationRule = RotationRule;
		params.ScaleRule = ScaleRule;
		params.bCallModify = bCallModify;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneComponent.K2_AttachToComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         Parent                         (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   SocketName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   LocationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   RotationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   ScaleRule                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bWeldSimulatedBodies           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USceneComponent::K2_AttachToComponent(class USceneComponent* Parent, const struct FName& SocketName, TEnumAsByte<EAttachmentRule> LocationRule, TEnumAsByte<EAttachmentRule> RotationRule, TEnumAsByte<EAttachmentRule> ScaleRule, bool bWeldSimulatedBodies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3988da3);

		USceneComponent_K2_AttachToComponent_Params params;
		params.Parent = Parent;
		params.SocketName = SocketName;
		params.LocationRule = LocationRule;
		params.RotationRule = RotationRule;
		params.ScaleRule = ScaleRule;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.K2_AttachTo
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         InParent                       (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachLocation>   AttachType                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bWeldSimulatedBodies           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USceneComponent::K2_AttachTo(class USceneComponent* InParent, const struct FName& InSocketName, TEnumAsByte<EAttachLocation> AttachType, bool bWeldSimulatedBodies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb26d5396);

		USceneComponent_K2_AttachTo_Params params;
		params.InParent = InParent;
		params.InSocketName = InSocketName;
		params.AttachType = AttachType;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.K2_AddWorldTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              DeltaTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_AddWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7ca7e017);

		USceneComponent_K2_AddWorldTransform_Params params;
		params.DeltaTransform = DeltaTransform;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_AddWorldRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                DeltaRotation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_AddWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xddf95b6f);

		USceneComponent_K2_AddWorldRotation_Params params;
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_AddWorldOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 DeltaLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_AddWorldOffset(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x618d6e88);

		USceneComponent_K2_AddWorldOffset_Params params;
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_AddRelativeRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                DeltaRotation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_AddRelativeRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdc47c1dd);

		USceneComponent_K2_AddRelativeRotation_Params params;
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_AddRelativeLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 DeltaLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_AddRelativeLocation(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7057a1e2);

		USceneComponent_K2_AddRelativeLocation_Params params;
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_AddLocalTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              DeltaTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_AddLocalTransform(const struct FTransform& DeltaTransform, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6580ad84);

		USceneComponent_K2_AddLocalTransform_Params params;
		params.DeltaTransform = DeltaTransform;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_AddLocalRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                DeltaRotation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_AddLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x93f287d2);

		USceneComponent_K2_AddLocalRotation_Params params;
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.K2_AddLocalOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 DeltaLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepHitResult                 (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::K2_AddLocalOffset(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x57c92379);

		USceneComponent_K2_AddLocalOffset_Params params;
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SweepHitResult != nullptr)
			*SweepHitResult = params.SweepHitResult;
	}


	// Function Engine.SceneComponent.IsVisible
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USceneComponent::IsVisible() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbe97abd2);

		USceneComponent_IsVisible_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.IsSimulatingPhysics
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USceneComponent::IsSimulatingPhysics(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x90a89562);

		USceneComponent_IsSimulatingPhysics_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.IsAnySimulatingPhysics
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USceneComponent::IsAnySimulatingPhysics() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbd1b8714);

		USceneComponent_IsAnySimulatingPhysics_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetUpVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USceneComponent::GetUpVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x715ea986);

		USceneComponent_GetUpVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetSocketTransform
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ERelativeTransformSpace> TransformSpace                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform USceneComponent::GetSocketTransform(const struct FName& InSocketName, TEnumAsByte<ERelativeTransformSpace> TransformSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26e3f765);

		USceneComponent_GetSocketTransform_Params params;
		params.InSocketName = InSocketName;
		params.TransformSpace = TransformSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetSocketRotation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator USceneComponent::GetSocketRotation(const struct FName& InSocketName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16c56599);

		USceneComponent_GetSocketRotation_Params params;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetSocketQuaternion
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FQuat                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FQuat USceneComponent::GetSocketQuaternion(const struct FName& InSocketName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c0bc62b);

		USceneComponent_GetSocketQuaternion_Params params;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetSocketLocation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USceneComponent::GetSocketLocation(const struct FName& InSocketName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9db160ae);

		USceneComponent_GetSocketLocation_Params params;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetRightVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USceneComponent::GetRightVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa17a2213);

		USceneComponent_GetRightVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetRelativeTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform USceneComponent::GetRelativeTransform() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaeb92ba4);

		USceneComponent_GetRelativeTransform_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetPhysicsVolume
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APhysicsVolume*          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APhysicsVolume* USceneComponent::GetPhysicsVolume() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa68207c9);

		USceneComponent_GetPhysicsVolume_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetParentComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<class USceneComponent*> Parents                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void USceneComponent::GetParentComponents(TArray<class USceneComponent*>* Parents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdaf4c3c4);

		USceneComponent_GetParentComponents_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Parents != nullptr)
			*Parents = params.Parents;
	}


	// Function Engine.SceneComponent.GetNumChildrenComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int USceneComponent::GetNumChildrenComponents() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30554999);

		USceneComponent_GetNumChildrenComponents_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetForwardVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USceneComponent::GetForwardVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf5648326);

		USceneComponent_GetForwardVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetComponentVelocity
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USceneComponent::GetComponentVelocity() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x92f8cc80);

		USceneComponent_GetComponentVelocity_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetChildrenComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           bIncludeAllDescendants         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class USceneComponent*> Children                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void USceneComponent::GetChildrenComponents(bool bIncludeAllDescendants, TArray<class USceneComponent*>* Children) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3f987b89);

		USceneComponent_GetChildrenComponents_Params params;
		params.bIncludeAllDescendants = bIncludeAllDescendants;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Children != nullptr)
			*Children = params.Children;
	}


	// Function Engine.SceneComponent.GetChildComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ChildIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USceneComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class USceneComponent* USceneComponent::GetChildComponent(int ChildIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1dce38e7);

		USceneComponent_GetChildComponent_Params params;
		params.ChildIndex = ChildIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetAttachSocketName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName USceneComponent::GetAttachSocketName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30bf6a4d);

		USceneComponent_GetAttachSocketName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetAttachParent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class USceneComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class USceneComponent* USceneComponent::GetAttachParent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x61a976df);

		USceneComponent_GetAttachParent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.GetAllSocketNames
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<struct FName>           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<struct FName> USceneComponent::GetAllSocketNames() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3f6a0942);

		USceneComponent_GetAllSocketNames_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.DoesSocketExist
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USceneComponent::DoesSocketExist(const struct FName& InSocketName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x52adf2a1);

		USceneComponent_DoesSocketExist_Params params;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneComponent.DetachFromParent
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bMaintainWorldPosition         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bCallModify                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneComponent::DetachFromParent(bool bMaintainWorldPosition, bool bCallModify) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfe44b0c5);

		USceneComponent_DetachFromParent_Params params;
		params.bMaintainWorldPosition = bMaintainWorldPosition;
		params.bCallModify = bCallModify;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.WakeRigidBody
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::WakeRigidBody(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75377030);

		UPrimitiveComponent_WakeRigidBody_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.WakeAllRigidBodies
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UPrimitiveComponent::WakeAllRigidBodies() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x62420e15);

		UPrimitiveComponent_WakeAllRigidBodies_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetWalkableSlopeOverride
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FWalkableSlopeOverride  NewOverride                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UPrimitiveComponent::SetWalkableSlopeOverride(const struct FWalkableSlopeOverride& NewOverride) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x987931e7);

		UPrimitiveComponent_SetWalkableSlopeOverride_Params params;
		params.NewOverride = NewOverride;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetTranslucentSortPriority
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            NewTranslucentSortPriority     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetTranslucentSortPriority(int NewTranslucentSortPriority) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfca6e12a);

		UPrimitiveComponent_SetTranslucentSortPriority_Params params;
		params.NewTranslucentSortPriority = NewTranslucentSortPriority;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetSimulatePhysics
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bSimulate                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetSimulatePhysics(bool bSimulate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf46bf1d2);

		UPrimitiveComponent_SetSimulatePhysics_Params params;
		params.bSimulate = bSimulate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetRenderInMainPass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bValue                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetRenderInMainPass(bool bValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4154514);

		UPrimitiveComponent_SetRenderInMainPass_Params params;
		params.bValue = bValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetRenderCustomDepth
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bValue                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetRenderCustomDepth(bool bValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x245f45db);

		UPrimitiveComponent_SetRenderCustomDepth_Params params;
		params.bValue = bValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetPhysMaterialOverride
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UPhysicalMaterial*       NewPhysMaterial                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7a43d8fa);

		UPrimitiveComponent_SetPhysMaterialOverride_Params params;
		params.NewPhysMaterial = NewPhysMaterial;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewMaxAngVel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAddToCurrent                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetPhysicsMaxAngularVelocity(float NewMaxAngVel, bool bAddToCurrent, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa576abdd);

		UPrimitiveComponent_SetPhysicsMaxAngularVelocity_Params params;
		params.NewMaxAngVel = NewMaxAngVel;
		params.bAddToCurrent = bAddToCurrent;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewVel                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAddToCurrent                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3aa45622);

		UPrimitiveComponent_SetPhysicsLinearVelocity_Params params;
		params.NewVel = NewVel;
		params.bAddToCurrent = bAddToCurrent;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewAngVel                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAddToCurrent                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetPhysicsAngularVelocity(const struct FVector& NewAngVel, bool bAddToCurrent, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2096c46f);

		UPrimitiveComponent_SetPhysicsAngularVelocity_Params params;
		params.NewAngVel = NewAngVel;
		params.bAddToCurrent = bAddToCurrent;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetOwnerNoSee
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewOwnerNoSee                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetOwnerNoSee(bool bNewOwnerNoSee) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x39070510);

		UPrimitiveComponent_SetOwnerNoSee_Params params;
		params.bNewOwnerNoSee = bNewOwnerNoSee;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetOnlyOwnerSee
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewOnlyOwnerSee               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetOnlyOwnerSee(bool bNewOnlyOwnerSee) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdcd5be05);

		UPrimitiveComponent_SetOnlyOwnerSee_Params params;
		params.bNewOnlyOwnerSee = bNewOnlyOwnerSee;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewNotifyRigidBodyCollision   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x65d3e0f5);

		UPrimitiveComponent_SetNotifyRigidBodyCollision_Params params;
		params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetMaterialByName
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   MaterialSlotName               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetMaterialByName(const struct FName& MaterialSlotName, class UMaterialInterface* Material) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8e62c8c8);

		UPrimitiveComponent_SetMaterialByName_Params params;
		params.MaterialSlotName = MaterialSlotName;
		params.Material = Material;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetMaterial
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ElementIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetMaterial(int ElementIndex, class UMaterialInterface* Material) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xde5bb0be);

		UPrimitiveComponent_SetMaterial_Params params;
		params.ElementIndex = ElementIndex;
		params.Material = Material;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetMassScale
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InMassScale                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetMassScale(const struct FName& BoneName, float InMassScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcdc4c12d);

		UPrimitiveComponent_SetMassScale_Params params;
		params.BoneName = BoneName;
		params.InMassScale = InMassScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetMassOverrideInKg
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MassInKg                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bOverrideMass                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetMassOverrideInKg(const struct FName& BoneName, float MassInKg, bool bOverrideMass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x86d8003a);

		UPrimitiveComponent_SetMassOverrideInKg_Params params;
		params.BoneName = BoneName;
		params.MassInKg = MassInKg;
		params.bOverrideMass = bOverrideMass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetLockedAxis
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EDOFMode>          LockedAxis                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetLockedAxis(TEnumAsByte<EDOFMode> LockedAxis) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2e4d35b4);

		UPrimitiveComponent_SetLockedAxis_Params params;
		params.LockedAxis = LockedAxis;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetLinearDamping
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InDamping                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetLinearDamping(float InDamping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xce809588);

		UPrimitiveComponent_SetLinearDamping_Params params;
		params.InDamping = InDamping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetEnableGravity
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bGravityEnabled                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetEnableGravity(bool bGravityEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeeae5ffe);

		UPrimitiveComponent_SetEnableGravity_Params params;
		params.bGravityEnabled = bGravityEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCustomDepthStencilValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCustomDepthStencilValue(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd061e7d0);

		UPrimitiveComponent_SetCustomDepthStencilValue_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCullDistance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewCullDistance                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCullDistance(float NewCullDistance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb4fb6748);

		UPrimitiveComponent_SetCullDistance_Params params;
		params.NewCullDistance = NewCullDistance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetConstraintMode
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EDOFMode>          ConstraintMode                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetConstraintMode(TEnumAsByte<EDOFMode> ConstraintMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1c59559);

		UPrimitiveComponent_SetConstraintMode_Params params;
		params.ConstraintMode = ConstraintMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCollisionResponseToChannel
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ECollisionChannel> Channel                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionResponse> NewResponse                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCollisionResponseToChannel(TEnumAsByte<ECollisionChannel> Channel, TEnumAsByte<ECollisionResponse> NewResponse) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2db9514e);

		UPrimitiveComponent_SetCollisionResponseToChannel_Params params;
		params.Channel = Channel;
		params.NewResponse = NewResponse;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ECollisionResponse> NewResponse                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCollisionResponseToAllChannels(TEnumAsByte<ECollisionResponse> NewResponse) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x923db682);

		UPrimitiveComponent_SetCollisionResponseToAllChannels_Params params;
		params.NewResponse = NewResponse;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCollisionProfileName
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InCollisionProfileName         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCollisionProfileName(const struct FName& InCollisionProfileName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x299612a7);

		UPrimitiveComponent_SetCollisionProfileName_Params params;
		params.InCollisionProfileName = InCollisionProfileName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCollisionObjectType
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ECollisionChannel> Channel                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCollisionObjectType(TEnumAsByte<ECollisionChannel> Channel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8bd6efde);

		UPrimitiveComponent_SetCollisionObjectType_Params params;
		params.Channel = Channel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCollisionEnabled
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ECollisionEnabled> NewType                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCollisionEnabled(TEnumAsByte<ECollisionEnabled> NewType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x44c634ca);

		UPrimitiveComponent_SetCollisionEnabled_Params params;
		params.NewType = NewType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCenterOfMass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 CenterOfMassOffset             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCenterOfMass(const struct FVector& CenterOfMassOffset, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ab9d651);

		UPrimitiveComponent_SetCenterOfMass_Params params;
		params.CenterOfMassOffset = CenterOfMassOffset;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetCastShadow
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           NewCastShadow                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetCastShadow(bool NewCastShadow) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85d2af58);

		UPrimitiveComponent_SetCastShadow_Params params;
		params.NewCastShadow = NewCastShadow;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetBoundsScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewBoundsScale                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetBoundsScale(float NewBoundsScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b3b7444);

		UPrimitiveComponent_SetBoundsScale_Params params;
		params.NewBoundsScale = NewBoundsScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetAngularDamping
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InDamping                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetAngularDamping(float InDamping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xad5f4571);

		UPrimitiveComponent_SetAngularDamping_Params params;
		params.InDamping = InDamping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewVel                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAddToCurrent                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetAllPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd71e92db);

		UPrimitiveComponent_SetAllPhysicsLinearVelocity_Params params;
		params.NewVel = NewVel;
		params.bAddToCurrent = bAddToCurrent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.SetAllMassScale
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InMassScale                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::SetAllMassScale(float InMassScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdb1d4514);

		UPrimitiveComponent_SetAllMassScale_Params params;
		params.InMassScale = InMassScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.ScaleByMomentOfInertia
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 InputVector                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPrimitiveComponent::ScaleByMomentOfInertia(const struct FVector& InputVector, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xae54774b);

		UPrimitiveComponent_ScaleByMomentOfInertia_Params params;
		params.InputVector = InputVector;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.PutRigidBodyToSleep
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::PutRigidBodyToSleep(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xacbe8dfd);

		UPrimitiveComponent_PutRigidBodyToSleep_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.K2_LineTraceComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 TraceStart                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 TraceEnd                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShowTrace                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitLocation                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitNormal                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::K2_LineTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, bool bTraceComplex, bool bShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, struct FName* BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8ee410c9);

		UPrimitiveComponent_K2_LineTraceComponent_Params params;
		params.TraceStart = TraceStart;
		params.TraceEnd = TraceEnd;
		params.bTraceComplex = bTraceComplex;
		params.bShowTrace = bShowTrace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HitLocation != nullptr)
			*HitLocation = params.HitLocation;
		if (HitNormal != nullptr)
			*HitNormal = params.HitNormal;
		if (BoneName != nullptr)
			*BoneName = params.BoneName;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.K2_IsQueryCollisionEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::K2_IsQueryCollisionEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf2df7d4a);

		UPrimitiveComponent_K2_IsQueryCollisionEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.K2_IsPhysicsCollisionEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::K2_IsPhysicsCollisionEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3d37241d);

		UPrimitiveComponent_K2_IsPhysicsCollisionEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.K2_IsCollisionEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::K2_IsCollisionEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4cab504c);

		UPrimitiveComponent_K2_IsCollisionEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.IsOverlappingComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UPrimitiveComponent*     OtherComp                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::IsOverlappingComponent(class UPrimitiveComponent* OtherComp) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7df9e21d);

		UPrimitiveComponent_IsOverlappingComponent_Params params;
		params.OtherComp = OtherComp;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.IsOverlappingActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  Other                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::IsOverlappingActor(class AActor* Other) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd63cb7e3);

		UPrimitiveComponent_IsOverlappingActor_Params params;
		params.Other = Other;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.IsGravityEnabled
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::IsGravityEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8bef36da);

		UPrimitiveComponent_IsGravityEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.IsAnyRigidBodyAwake
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::IsAnyRigidBodyAwake() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x749c9bb9);

		UPrimitiveComponent_IsAnyRigidBodyAwake_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.IgnoreComponentWhenMoving
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// bool                           bShouldIgnore                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::IgnoreComponentWhenMoving(class UPrimitiveComponent* Component, bool bShouldIgnore) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf5bdb324);

		UPrimitiveComponent_IgnoreComponentWhenMoving_Params params;
		params.Component = Component;
		params.bShouldIgnore = bShouldIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.IgnoreActorWhenMoving
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  Actor                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShouldIgnore                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::IgnoreActorWhenMoving(class AActor* Actor, bool bShouldIgnore) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x28aec712);

		UPrimitiveComponent_IgnoreActorWhenMoving_Params params;
		params.Actor = Actor;
		params.bShouldIgnore = bShouldIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.GetWalkableSlopeOverride
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FWalkableSlopeOverride  ReturnValue                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_ReferenceParm)

	struct FWalkableSlopeOverride UPrimitiveComponent::GetWalkableSlopeOverride() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x800bc12b);

		UPrimitiveComponent_GetWalkableSlopeOverride_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Point                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPrimitiveComponent::GetPhysicsLinearVelocityAtPoint(const struct FVector& Point, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc37260d);

		UPrimitiveComponent_GetPhysicsLinearVelocityAtPoint_Params params;
		params.Point = Point;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPrimitiveComponent::GetPhysicsLinearVelocity(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfa727876);

		UPrimitiveComponent_GetPhysicsLinearVelocity_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPrimitiveComponent::GetPhysicsAngularVelocity(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3100063);

		UPrimitiveComponent_GetPhysicsAngularVelocity_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetOverlappingComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<class UPrimitiveComponent*> InOverlappingComponents        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UPrimitiveComponent::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* InOverlappingComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24a6429a);

		UPrimitiveComponent_GetOverlappingComponents_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (InOverlappingComponents != nullptr)
			*InOverlappingComponents = params.InOverlappingComponents;
	}


	// Function Engine.PrimitiveComponent.GetOverlappingActors
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<class AActor*>          OverlappingActors              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// class UClass*                  ClassFilter                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::GetOverlappingActors(class UClass* ClassFilter, TArray<class AActor*>* OverlappingActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x503fa0f8);

		UPrimitiveComponent_GetOverlappingActors_Params params;
		params.ClassFilter = ClassFilter;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OverlappingActors != nullptr)
			*OverlappingActors = params.OverlappingActors;
	}


	// Function Engine.PrimitiveComponent.GetOverlapInfos
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<struct FOverlapInfo>    ReturnValue                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_ReferenceParm)

	TArray<struct FOverlapInfo> UPrimitiveComponent::GetOverlapInfos() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc10491);

		UPrimitiveComponent_GetOverlapInfos_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetNumMaterials
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UPrimitiveComponent::GetNumMaterials() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbecae7fb);

		UPrimitiveComponent_GetNumMaterials_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetMaterial
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ElementIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInterface* UPrimitiveComponent::GetMaterial(int ElementIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x59cf56da);

		UPrimitiveComponent_GetMaterial_Params params;
		params.ElementIndex = ElementIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetMassScale
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPrimitiveComponent::GetMassScale(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfde777d9);

		UPrimitiveComponent_GetMassScale_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetMass
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPrimitiveComponent::GetMass() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6345e711);

		UPrimitiveComponent_GetMass_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetLinearDamping
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPrimitiveComponent::GetLinearDamping() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24a9fb64);

		UPrimitiveComponent_GetLinearDamping_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetInertiaTensor
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPrimitiveComponent::GetInertiaTensor(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf8b1dd6a);

		UPrimitiveComponent_GetInertiaTensor_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetCollisionResponseToChannel
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ECollisionChannel> Channel                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionResponse> ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<ECollisionResponse> UPrimitiveComponent::GetCollisionResponseToChannel(TEnumAsByte<ECollisionChannel> Channel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x83c8dfb2);

		UPrimitiveComponent_GetCollisionResponseToChannel_Params params;
		params.Channel = Channel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetCollisionProfileName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName UPrimitiveComponent::GetCollisionProfileName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc70654a3);

		UPrimitiveComponent_GetCollisionProfileName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetCollisionObjectType
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ECollisionChannel> ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<ECollisionChannel> UPrimitiveComponent::GetCollisionObjectType() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x975b9832);

		UPrimitiveComponent_GetCollisionObjectType_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetCollisionEnabled
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ECollisionEnabled> ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<ECollisionEnabled> UPrimitiveComponent::GetCollisionEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe150f136);

		UPrimitiveComponent_GetCollisionEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetClosestPointOnCollision
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 Point                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 OutPointOnBody                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPrimitiveComponent::GetClosestPointOnCollision(const struct FVector& Point, const struct FName& BoneName, struct FVector* OutPointOnBody) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8008ccd);

		UPrimitiveComponent_GetClosestPointOnCollision_Params params;
		params.Point = Point;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutPointOnBody != nullptr)
			*OutPointOnBody = params.OutPointOnBody;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetCenterOfMass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPrimitiveComponent::GetCenterOfMass(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ee72895);

		UPrimitiveComponent_GetCenterOfMass_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.GetAngularDamping
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPrimitiveComponent::GetAngularDamping() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa012058d);

		UPrimitiveComponent_GetAngularDamping_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ElementIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      SourceMaterial                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInstanceDynamic* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInstanceDynamic* UPrimitiveComponent::CreateDynamicMaterialInstance(int ElementIndex, class UMaterialInterface* SourceMaterial) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2cc8b6b8);

		UPrimitiveComponent_CreateDynamicMaterialInstance_Params params;
		params.ElementIndex = ElementIndex;
		params.SourceMaterial = SourceMaterial;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ElementIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      Parent                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInstanceDynamic* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamicFromMaterial(int ElementIndex, class UMaterialInterface* Parent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x14ce95e4);

		UPrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial_Params params;
		params.ElementIndex = ElementIndex;
		params.Parent = Parent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ElementIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInstanceDynamic* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic(int ElementIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b80364b);

		UPrimitiveComponent_CreateAndSetMaterialInstanceDynamic_Params params;
		params.ElementIndex = ElementIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<class UPrimitiveComponent*> ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<class UPrimitiveComponent*> UPrimitiveComponent::CopyArrayOfMoveIgnoreComponents() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd82b3b79);

		UPrimitiveComponent_CopyArrayOfMoveIgnoreComponents_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<class AActor*>          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<class AActor*> UPrimitiveComponent::CopyArrayOfMoveIgnoreActors() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6e61559f);

		UPrimitiveComponent_CopyArrayOfMoveIgnoreActors_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.ClearMoveIgnoreComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UPrimitiveComponent::ClearMoveIgnoreComponents() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x52225d5b);

		UPrimitiveComponent_ClearMoveIgnoreComponents_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.ClearMoveIgnoreActors
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UPrimitiveComponent::ClearMoveIgnoreActors() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xac9bc441);

		UPrimitiveComponent_ClearMoveIgnoreActors_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.CanCharacterStepUp
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APawn*                   Pawn                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPrimitiveComponent::CanCharacterStepUp(class APawn* Pawn) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x690eba8d);

		UPrimitiveComponent_CanCharacterStepUp_Params params;
		params.Pawn = Pawn;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PrimitiveComponent.AddTorque
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Torque                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAccelChange                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::AddTorque(const struct FVector& Torque, const struct FName& BoneName, bool bAccelChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3cc2946);

		UPrimitiveComponent_AddTorque_Params params;
		params.Torque = Torque;
		params.BoneName = BoneName;
		params.bAccelChange = bAccelChange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.AddRadialImpulse
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Origin                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Strength                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ERadialImpulseFalloff> Falloff                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bVelChange                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff, bool bVelChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe968c0fa);

		UPrimitiveComponent_AddRadialImpulse_Params params;
		params.Origin = Origin;
		params.Radius = Radius;
		params.Strength = Strength;
		params.Falloff = Falloff;
		params.bVelChange = bVelChange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.AddRadialForce
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Origin                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Strength                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ERadialImpulseFalloff> Falloff                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAccelChange                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::AddRadialForce(const struct FVector& Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff, bool bAccelChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef8f9976);

		UPrimitiveComponent_AddRadialForce_Params params;
		params.Origin = Origin;
		params.Radius = Radius;
		params.Strength = Strength;
		params.Falloff = Falloff;
		params.bAccelChange = bAccelChange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.AddImpulseAtLocation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Impulse                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::AddImpulseAtLocation(const struct FVector& Impulse, const struct FVector& Location, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8f4f7f4b);

		UPrimitiveComponent_AddImpulseAtLocation_Params params;
		params.Impulse = Impulse;
		params.Location = Location;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.AddImpulse
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Impulse                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bVelChange                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::AddImpulse(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x844a5e1d);

		UPrimitiveComponent_AddImpulse_Params params;
		params.Impulse = Impulse;
		params.BoneName = BoneName;
		params.bVelChange = bVelChange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.AddForceAtLocation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Force                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::AddForceAtLocation(const struct FVector& Force, const struct FVector& Location, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb940b213);

		UPrimitiveComponent_AddForceAtLocation_Params params;
		params.Force = Force;
		params.Location = Location;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.AddForce
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Force                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAccelChange                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::AddForce(const struct FVector& Force, const struct FName& BoneName, bool bAccelChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe7e13f95);

		UPrimitiveComponent_AddForce_Params params;
		params.Force = Force;
		params.BoneName = BoneName;
		params.bAccelChange = bAccelChange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PrimitiveComponent.AddAngularImpulse
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Impulse                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bVelChange                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPrimitiveComponent::AddAngularImpulse(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4e5bdd47);

		UPrimitiveComponent_AddAngularImpulse_Params params;
		params.Impulse = Impulse;
		params.BoneName = BoneName;
		params.bVelChange = bVelChange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MeshComponent.SetVectorParameterValueOnMaterials
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ParameterValue                 (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMeshComponent::SetVectorParameterValueOnMaterials(const struct FName& ParameterName, const struct FVector& ParameterValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x382f0815);

		UMeshComponent_SetVectorParameterValueOnMaterials_Params params;
		params.ParameterName = ParameterName;
		params.ParameterValue = ParameterValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MeshComponent.SetScalarParameterValueOnMaterials
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ParameterValue                 (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMeshComponent::SetScalarParameterValueOnMaterials(const struct FName& ParameterName, float ParameterValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb59e336a);

		UMeshComponent_SetScalarParameterValueOnMaterials_Params params;
		params.ParameterName = ParameterName;
		params.ParameterValue = ParameterValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MeshComponent.IsMaterialSlotNameValid
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   MaterialSlotName               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UMeshComponent::IsMaterialSlotNameValid(const struct FName& MaterialSlotName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcccce20f);

		UMeshComponent_IsMaterialSlotNameValid_Params params;
		params.MaterialSlotName = MaterialSlotName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MeshComponent.GetMaterialSlotNames
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<struct FName>           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<struct FName> UMeshComponent::GetMaterialSlotNames() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ac8ea14);

		UMeshComponent_GetMaterialSlotNames_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MeshComponent.GetMaterials
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<class UMaterialInterface*> ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<class UMaterialInterface*> UMeshComponent::GetMaterials() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef2e746b);

		UMeshComponent_GetMaterials_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MeshComponent.GetMaterialIndex
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   MaterialSlotName               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UMeshComponent::GetMaterialIndex(const struct FName& MaterialSlotName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x64759314);

		UMeshComponent_GetMaterialIndex_Params params;
		params.MaterialSlotName = MaterialSlotName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StaticMeshComponent.SetStaticMesh
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UStaticMesh*             NewMesh                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UStaticMeshComponent::SetStaticMesh(class UStaticMesh* NewMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x361b1a50);

		UStaticMeshComponent_SetStaticMesh_Params params;
		params.NewMesh = NewMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StaticMeshComponent.SetForcedLodModel
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            NewForcedLodModel              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStaticMeshComponent::SetForcedLodModel(int NewForcedLodModel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa8e02f36);

		UStaticMeshComponent_SetForcedLodModel_Params params;
		params.NewForcedLodModel = NewForcedLodModel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StaticMeshComponent.OnRep_StaticMesh
	// (FUNC_Final, FUNC_Native, FUNC_Public)
	// Parameters:
	// class UStaticMesh*             OldStaticMesh                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStaticMeshComponent::OnRep_StaticMesh(class UStaticMesh* OldStaticMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5d302d61);

		UStaticMeshComponent_OnRep_StaticMesh_Params params;
		params.OldStaticMesh = OldStaticMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StaticMeshComponent.GetLocalBounds
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 Min                            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Max                            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStaticMeshComponent::GetLocalBounds(struct FVector* Min, struct FVector* Max) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8aed0905);

		UStaticMeshComponent_GetLocalBounds_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Min != nullptr)
			*Min = params.Min;
		if (Max != nullptr)
			*Max = params.Max;
	}


	// Function Engine.Controller.UnPossess
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AController::UnPossess() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb0ba87f2);

		AController_UnPossess_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.StopMovement
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AController::StopMovement() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf683676c);

		AController_StopMovement_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.SetInitialLocationAndRotation
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                NewRotation                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void AController::SetInitialLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1fa3d753);

		AController_SetInitialLocationAndRotation_Params params;
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.SetIgnoreMoveInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewMoveInput                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AController::SetIgnoreMoveInput(bool bNewMoveInput) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9d7a3570);

		AController_SetIgnoreMoveInput_Params params;
		params.bNewMoveInput = bNewMoveInput;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.SetIgnoreLookInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewLookInput                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AController::SetIgnoreLookInput(bool bNewLookInput) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcb69c866);

		AController_SetIgnoreLookInput_Params params;
		params.bNewLookInput = bNewLookInput;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.SetControlRotation
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                NewRotation                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void AController::SetControlRotation(const struct FRotator& NewRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x63a1cb5a);

		AController_SetControlRotation_Params params;
		params.NewRotation = NewRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.ResetIgnoreMoveInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AController::ResetIgnoreMoveInput() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe303920b);

		AController_ResetIgnoreMoveInput_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.ResetIgnoreLookInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AController::ResetIgnoreLookInput() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9b0848c1);

		AController_ResetIgnoreLookInput_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.ResetIgnoreInputFlags
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AController::ResetIgnoreInputFlags() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd38cf017);

		AController_ResetIgnoreInputFlags_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.ReceiveInstigatedAnyDamage
	// (FUNC_BlueprintAuthorityOnly, FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent)
	// Parameters:
	// float                          Damage                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDamageType*             DamageType                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  DamagedActor                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  DamageCauser                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AController::ReceiveInstigatedAnyDamage(float Damage, class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf4a87f);

		AController_ReceiveInstigatedAnyDamage_Params params;
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.DamagedActor = DamagedActor;
		params.DamageCauser = DamageCauser;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.Possess
	// (FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class APawn*                   InPawn                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AController::Possess(class APawn* InPawn) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1b2c2e99);

		AController_Possess_Params params;
		params.InPawn = InPawn;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.OnRep_PlayerState
	// (FUNC_Native, FUNC_Public)

	void AController::OnRep_PlayerState() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x988607ea);

		AController_OnRep_PlayerState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.OnRep_Pawn
	// (FUNC_Native, FUNC_Public)

	void AController::OnRep_Pawn() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ed9cba);

		AController_OnRep_Pawn_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.LineOfSightTo
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  Other                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ViewPoint                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAlternateChecks               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AController::LineOfSightTo(class AActor* Other, const struct FVector& ViewPoint, bool bAlternateChecks) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5693fb2);

		AController_LineOfSightTo_Params params;
		params.Other = Other;
		params.ViewPoint = ViewPoint;
		params.bAlternateChecks = bAlternateChecks;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.K2_GetPawn
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APawn*                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APawn* AController::K2_GetPawn() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2a5f4fcb);

		AController_K2_GetPawn_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.IsPlayerController
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AController::IsPlayerController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e104d14);

		AController_IsPlayerController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.IsMoveInputIgnored
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AController::IsMoveInputIgnored() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe57c5ff2);

		AController_IsMoveInputIgnored_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.IsLookInputIgnored
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AController::IsLookInputIgnored() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x97f0c0d4);

		AController_IsLookInputIgnored_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.IsLocalPlayerController
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AController::IsLocalPlayerController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc7bd5b87);

		AController_IsLocalPlayerController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.IsLocalController
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AController::IsLocalController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6d5eeb7c);

		AController_IsLocalController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.GetViewTarget
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* AController::GetViewTarget() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x670d3095);

		AController_GetViewTarget_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.GetDesiredRotation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator AController::GetDesiredRotation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x833814fb);

		AController_GetDesiredRotation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.GetControlRotation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator AController::GetControlRotation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9b0ab346);

		AController_GetControlRotation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Controller.ClientSetRotation
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bResetCamera                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AController::ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x445b1e78);

		AController_ClientSetRotation_Params params;
		params.NewRotation = NewRotation;
		params.bResetCamera = bResetCamera;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.ClientSetLocation
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AController::ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d4ccacb);

		AController_ClientSetLocation_Params params;
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Controller.CastToPlayerController
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class APlayerController*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APlayerController* AController::CastToPlayerController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8ca20122);

		AController_CastToPlayerController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.WasInputKeyJustReleased
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::WasInputKeyJustReleased(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf1264607);

		APlayerController_WasInputKeyJustReleased_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.WasInputKeyJustPressed
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::WasInputKeyJustPressed(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5917b850);

		APlayerController_WasInputKeyJustPressed_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.ToggleSpeaking
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// bool                           bInSpeaking                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ToggleSpeaking(bool bInSpeaking) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4c14e0e0);

		APlayerController_ToggleSpeaking_Params params;
		params.bInSpeaking = bInSpeaking;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SwitchLevel
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 URL                            (CPF_Parm, CPF_ZeroConstructor)

	void APlayerController::SwitchLevel(const struct FString& URL) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f0be54);

		APlayerController_SwitchLevel_Params params;
		params.URL = URL;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.StopHapticEffect
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EControllerHand>   Hand                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::StopHapticEffect(TEnumAsByte<EControllerHand> Hand) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1fbe2964);

		APlayerController_StopHapticEffect_Params params;
		params.Hand = Hand;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.StartFire
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// unsigned char                  FireModeNum                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::StartFire(unsigned char FireModeNum) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xda0fa7de);

		APlayerController_StartFire_Params params;
		params.FireModeNum = FireModeNum;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SetVirtualJoystickVisibility
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bVisible                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::SetVirtualJoystickVisibility(bool bVisible) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe6709bc9);

		APlayerController_SetVirtualJoystickVisibility_Params params;
		params.bVisible = bVisible;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SetViewTargetWithBlend
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  NewViewTarget                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EViewTargetBlendFunction> BlendFunc                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendExp                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLockOutgoing                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, TEnumAsByte<EViewTargetBlendFunction> BlendFunc, float BlendExp, bool bLockOutgoing) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x110c74b7);

		APlayerController_SetViewTargetWithBlend_Params params;
		params.NewViewTarget = NewViewTarget;
		params.BlendTime = BlendTime;
		params.BlendFunc = BlendFunc;
		params.BlendExp = BlendExp;
		params.bLockOutgoing = bLockOutgoing;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SetName
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 S                              (CPF_Parm, CPF_ZeroConstructor)

	void APlayerController::SetName(const struct FString& S) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf7c6777);

		APlayerController_SetName_Params params;
		params.S = S;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SetMouseLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            X                              (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Y                              (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::SetMouseLocation(int X, int Y) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x987987e2);

		APlayerController_SetMouseLocation_Params params;
		params.X = X;
		params.Y = Y;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SetHapticsByValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Frequency                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Amplitude                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EControllerHand>   Hand                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::SetHapticsByValue(float Frequency, float Amplitude, TEnumAsByte<EControllerHand> Hand) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf9c71f80);

		APlayerController_SetHapticsByValue_Params params;
		params.Frequency = Frequency;
		params.Amplitude = Amplitude;
		params.Hand = Hand;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SetControllerLightColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FColor                  Color                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::SetControllerLightColor(const struct FColor& Color) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdda672bf);

		APlayerController_SetControllerLightColor_Params params;
		params.Color = Color;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SetCinematicMode
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInCinematicMode               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bHidePlayer                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsHUD                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsMovement               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsTurning                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf55f524c);

		APlayerController_SetCinematicMode_Params params;
		params.bInCinematicMode = bInCinematicMode;
		params.bHidePlayer = bHidePlayer;
		params.bAffectsHUD = bAffectsHUD;
		params.bAffectsMovement = bAffectsMovement;
		params.bAffectsTurning = bAffectsTurning;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SetAudioListenerOverride
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         AttachToComponent              (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::SetAudioListenerOverride(class USceneComponent* AttachToComponent, const struct FVector& Location, const struct FRotator& Rotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x45607df0);

		APlayerController_SetAudioListenerOverride_Params params;
		params.AttachToComponent = AttachToComponent;
		params.Location = Location;
		params.Rotation = Rotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerViewSelf
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// struct FViewTargetTransitionParams TransitionParams               (CPF_Parm)

	void APlayerController::ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd634cb2a);

		APlayerController_ServerViewSelf_Params params;
		params.TransitionParams = TransitionParams;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerViewPrevPlayer
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerViewPrevPlayer() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54b5cb0c);

		APlayerController_ServerViewPrevPlayer_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerViewNextPlayer
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerViewNextPlayer() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x568536c0);

		APlayerController_ServerViewNextPlayer_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerVerifyViewTarget
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerVerifyViewTarget() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x427aa724);

		APlayerController_ServerVerifyViewTarget_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerUpdateLevelVisibility
	// (FUNC_Final, FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// struct FName                   PackageName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIsVisible                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ServerUpdateLevelVisibility(const struct FName& PackageName, bool bIsVisible) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x19129192);

		APlayerController_ServerUpdateLevelVisibility_Params params;
		params.PackageName = PackageName;
		params.bIsVisible = bIsVisible;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerUpdateCamera
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// struct FVector_NetQuantize     CamLoc                         (CPF_Parm)
	// int                            CamPitchAndYaw                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ServerUpdateCamera(const struct FVector_NetQuantize& CamLoc, int CamPitchAndYaw) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x13da6e8d);

		APlayerController_ServerUpdateCamera_Params params;
		params.CamLoc = CamLoc;
		params.CamPitchAndYaw = CamPitchAndYaw;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerUnmutePlayer
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// struct FUniqueNetIdRepl        PlayerId                       (CPF_Parm)

	void APlayerController::ServerUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc6a44822);

		APlayerController_ServerUnmutePlayer_Params params;
		params.PlayerId = PlayerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerToggleAILogging
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerToggleAILogging() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb8f1c23c);

		APlayerController_ServerToggleAILogging_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerShortTimeout
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerShortTimeout() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2d145c);

		APlayerController_ServerShortTimeout_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerSetSpectatorWaiting
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// bool                           bWaiting                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ServerSetSpectatorWaiting(bool bWaiting) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x93c7facd);

		APlayerController_ServerSetSpectatorWaiting_Params params;
		params.bWaiting = bWaiting;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerSetSpectatorLocation
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_HasDefaults, FUNC_NetValidate)
	// Parameters:
	// struct FVector                 NewLoc                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewRot                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ServerSetSpectatorLocation(const struct FVector& NewLoc, const struct FRotator& NewRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc15669c5);

		APlayerController_ServerSetSpectatorLocation_Params params;
		params.NewLoc = NewLoc;
		params.NewRot = NewRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerRestartPlayer
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerRestartPlayer() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1225bfd7);

		APlayerController_ServerRestartPlayer_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerPause
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerPause() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb71d62d3);

		APlayerController_ServerPause_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerNotifyLoadedWorld
	// (FUNC_Final, FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// struct FName                   WorldPackageName               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ServerNotifyLoadedWorld(const struct FName& WorldPackageName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdca00269);

		APlayerController_ServerNotifyLoadedWorld_Params params;
		params.WorldPackageName = WorldPackageName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerMutePlayer
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// struct FUniqueNetIdRepl        PlayerId                       (CPF_Parm)

	void APlayerController::ServerMutePlayer(const struct FUniqueNetIdRepl& PlayerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x62ed706f);

		APlayerController_ServerMutePlayer_Params params;
		params.PlayerId = PlayerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerCheckClientPossessionReliable
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerCheckClientPossessionReliable() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x69202008);

		APlayerController_ServerCheckClientPossessionReliable_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerCheckClientPossession
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void APlayerController::ServerCheckClientPossession() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfbfa53e6);

		APlayerController_ServerCheckClientPossession_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerChangeName
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// struct FString                 S                              (CPF_Parm, CPF_ZeroConstructor)

	void APlayerController::ServerChangeName(const struct FString& S) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4b0ed13e);

		APlayerController_ServerChangeName_Params params;
		params.S = S;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerCamera
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// struct FName                   NewMode                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ServerCamera(const struct FName& NewMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe11f46ae);

		APlayerController_ServerCamera_Params params;
		params.NewMode = NewMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ServerAcknowledgePossession
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// class APawn*                   P                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ServerAcknowledgePossession(class APawn* P) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe28d7fd3);

		APlayerController_ServerAcknowledgePossession_Params params;
		params.P = P;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.SendToConsole
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 Command                        (CPF_Parm, CPF_ZeroConstructor)

	void APlayerController::SendToConsole(const struct FString& Command) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x60d82ede);

		APlayerController_SendToConsole_Params params;
		params.Command = Command;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.RestartLevel
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void APlayerController::RestartLevel() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x158aa7b3);

		APlayerController_RestartLevel_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ProjectWorldLocationToScreen
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenLocation                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPlayerViewportRelative        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::ProjectWorldLocationToScreen(const struct FVector& WorldLocation, bool bPlayerViewportRelative, struct FVector2D* ScreenLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x117b2b5);

		APlayerController_ProjectWorldLocationToScreen_Params params;
		params.WorldLocation = WorldLocation;
		params.bPlayerViewportRelative = bPlayerViewportRelative;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (ScreenLocation != nullptr)
			*ScreenLocation = params.ScreenLocation;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.PlayHapticEffect
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UHapticFeedbackEffect_Base* HapticEffect                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EControllerHand>   Hand                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLoop                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::PlayHapticEffect(class UHapticFeedbackEffect_Base* HapticEffect, TEnumAsByte<EControllerHand> Hand, float Scale, bool bLoop) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x28b16cba);

		APlayerController_PlayHapticEffect_Params params;
		params.HapticEffect = HapticEffect;
		params.Hand = Hand;
		params.Scale = Scale;
		params.bLoop = bLoop;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.PlayDynamicForceFeedback
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Intensity                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsLeftLarge              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsLeftSmall              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsRightLarge             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsRightSmall             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EDynamicForceFeedbackAction> Action                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLatentActionInfo       LatentInfo                     (CPF_Parm)

	void APlayerController::PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, TEnumAsByte<EDynamicForceFeedbackAction> Action, const struct FLatentActionInfo& LatentInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x32d363cd);

		APlayerController_PlayDynamicForceFeedback_Params params;
		params.Intensity = Intensity;
		params.Duration = Duration;
		params.bAffectsLeftLarge = bAffectsLeftLarge;
		params.bAffectsLeftSmall = bAffectsLeftSmall;
		params.bAffectsRightLarge = bAffectsRightLarge;
		params.bAffectsRightSmall = bAffectsRightSmall;
		params.Action = Action;
		params.LatentInfo = LatentInfo;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.Pause
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void APlayerController::Pause() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x724d0600);

		APlayerController_Pause_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.OnServerStartedVisualLogger
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// bool                           bIsLogging                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::OnServerStartedVisualLogger(bool bIsLogging) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb68c93ef);

		APlayerController_OnServerStartedVisualLogger_Params params;
		params.bIsLogging = bIsLogging;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.LocalTravel
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 URL                            (CPF_Parm, CPF_ZeroConstructor)

	void APlayerController::LocalTravel(const struct FString& URL) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xecaebad3);

		APlayerController_LocalTravel_Params params;
		params.URL = URL;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.IsInputKeyDown
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::IsInputKeyDown(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8ee3c45f);

		APlayerController_IsInputKeyDown_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetViewportSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            SizeX                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            SizeY                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::GetViewportSize(int* SizeX, int* SizeY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x53f913e7);

		APlayerController_GetViewportSize_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SizeX != nullptr)
			*SizeX = params.SizeX;
		if (SizeY != nullptr)
			*SizeY = params.SizeY;
	}


	// Function Engine.PlayerController.GetSpectatorPawn
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class ASpectatorPawn*          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class ASpectatorPawn* APlayerController::GetSpectatorPawn() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb122f43);

		APlayerController_GetSpectatorPawn_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetMousePosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          LocationX                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LocationY                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::GetMousePosition(float* LocationX, float* LocationY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xffbbc342);

		APlayerController_GetMousePosition_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (LocationX != nullptr)
			*LocationX = params.LocationX;
		if (LocationY != nullptr)
			*LocationY = params.LocationY;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetInputVectorKeyState
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector APlayerController::GetInputVectorKeyState(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x232cac6b);

		APlayerController_GetInputVectorKeyState_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetInputTouchState
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ETouchIndex>       FingerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LocationX                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LocationY                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIsCurrentlyPressed            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::GetInputTouchState(TEnumAsByte<ETouchIndex> FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa90cd5e);

		APlayerController_GetInputTouchState_Params params;
		params.FingerIndex = FingerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (LocationX != nullptr)
			*LocationX = params.LocationX;
		if (LocationY != nullptr)
			*LocationY = params.LocationY;
		if (bIsCurrentlyPressed != nullptr)
			*bIsCurrentlyPressed = params.bIsCurrentlyPressed;
	}


	// Function Engine.PlayerController.GetInputMouseDelta
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          DeltaX                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaY                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::GetInputMouseDelta(float* DeltaX, float* DeltaY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4966e10b);

		APlayerController_GetInputMouseDelta_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (DeltaX != nullptr)
			*DeltaX = params.DeltaX;
		if (DeltaY != nullptr)
			*DeltaY = params.DeltaY;
	}


	// Function Engine.PlayerController.GetInputMotionState
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 Tilt                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 RotationRate                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Gravity                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Acceleration                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::GetInputMotionState(struct FVector* Tilt, struct FVector* RotationRate, struct FVector* Gravity, struct FVector* Acceleration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x23d929ab);

		APlayerController_GetInputMotionState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Tilt != nullptr)
			*Tilt = params.Tilt;
		if (RotationRate != nullptr)
			*RotationRate = params.RotationRate;
		if (Gravity != nullptr)
			*Gravity = params.Gravity;
		if (Acceleration != nullptr)
			*Acceleration = params.Acceleration;
	}


	// Function Engine.PlayerController.GetInputKeyTimeDown
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float APlayerController::GetInputKeyTimeDown(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4595248);

		APlayerController_GetInputKeyTimeDown_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetInputAnalogStickState
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<EControllerAnalogStick> WhichStick                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StickX                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StickY                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::GetInputAnalogStickState(TEnumAsByte<EControllerAnalogStick> WhichStick, float* StickX, float* StickY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x41ce591d);

		APlayerController_GetInputAnalogStickState_Params params;
		params.WhichStick = WhichStick;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (StickX != nullptr)
			*StickX = params.StickX;
		if (StickY != nullptr)
			*StickY = params.StickY;
	}


	// Function Engine.PlayerController.GetInputAnalogKeyState
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float APlayerController::GetInputAnalogKeyState(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe37dd0de);

		APlayerController_GetInputAnalogKeyState_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetHUD
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AHUD*                    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AHUD* APlayerController::GetHUD() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd1ef9fed);

		APlayerController_GetHUD_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetHitResultUnderFingerForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ETouchIndex>       FingerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              HitResult                      (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::GetHitResultUnderFingerForObjects(TEnumAsByte<ETouchIndex> FingerIndex, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x48c279c4);

		APlayerController_GetHitResultUnderFingerForObjects_Params params;
		params.FingerIndex = FingerIndex;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HitResult != nullptr)
			*HitResult = params.HitResult;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetHitResultUnderFingerByChannel
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ETouchIndex>       FingerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              HitResult                      (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::GetHitResultUnderFingerByChannel(TEnumAsByte<ETouchIndex> FingerIndex, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4daf1355);

		APlayerController_GetHitResultUnderFingerByChannel_Params params;
		params.FingerIndex = FingerIndex;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HitResult != nullptr)
			*HitResult = params.HitResult;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetHitResultUnderFinger
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ETouchIndex>       FingerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              HitResult                      (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::GetHitResultUnderFinger(TEnumAsByte<ETouchIndex> FingerIndex, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe30e5af);

		APlayerController_GetHitResultUnderFinger_Params params;
		params.FingerIndex = FingerIndex;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HitResult != nullptr)
			*HitResult = params.HitResult;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetHitResultUnderCursorForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              HitResult                      (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::GetHitResultUnderCursorForObjects(TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc5027621);

		APlayerController_GetHitResultUnderCursorForObjects_Params params;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HitResult != nullptr)
			*HitResult = params.HitResult;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetHitResultUnderCursorByChannel
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              HitResult                      (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::GetHitResultUnderCursorByChannel(TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x940b41d2);

		APlayerController_GetHitResultUnderCursorByChannel_Params params;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HitResult != nullptr)
			*HitResult = params.HitResult;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetHitResultUnderCursor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ECollisionChannel> TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              HitResult                      (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::GetHitResultUnderCursor(TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3c0b5e9a);

		APlayerController_GetHitResultUnderCursor_Params params;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HitResult != nullptr)
			*HitResult = params.HitResult;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.GetFocalLocation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector APlayerController::GetFocalLocation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6d93b2c);

		APlayerController_GetFocalLocation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.FOV
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// float                          NewFOV                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::FOV(float NewFOV) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3fa04ef3);

		APlayerController_FOV_Params params;
		params.NewFOV = NewFOV;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.EnableCheats
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void APlayerController::EnableCheats() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa4ef06a7);

		APlayerController_EnableCheats_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.DeprojectScreenPositionToWorld
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ScreenX                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScreenY                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldLocation                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldDirection                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, struct FVector* WorldLocation, struct FVector* WorldDirection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaea3cdd4);

		APlayerController_DeprojectScreenPositionToWorld_Params params;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (WorldLocation != nullptr)
			*WorldLocation = params.WorldLocation;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.DeprojectMousePositionToWorld
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldDirection                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerController::DeprojectMousePositionToWorld(struct FVector* WorldLocation, struct FVector* WorldDirection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b60b803);

		APlayerController_DeprojectMousePositionToWorld_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (WorldLocation != nullptr)
			*WorldLocation = params.WorldLocation;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;

		return params.ReturnValue;
	}


	// Function Engine.PlayerController.ConsoleKey
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)

	void APlayerController::ConsoleKey(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b8e3542);

		APlayerController_ConsoleKey_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientWasKicked
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FText                   KickReason                     (CPF_ConstParm, CPF_Parm, CPF_ReferenceParm)

	void APlayerController::ClientWasKicked(const struct FText& KickReason) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5a63e07);

		APlayerController_ClientWasKicked_Params params;
		params.KickReason = KickReason;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientVoiceHandshakeComplete
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientVoiceHandshakeComplete() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x56684453);

		APlayerController_ClientVoiceHandshakeComplete_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientUpdateLevelStreamingStatus
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FName                   PackageName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bNewShouldBeLoaded             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bNewShouldBeVisible            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bNewShouldBlockOnLoad          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            LODIndex                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientUpdateLevelStreamingStatus(const struct FName& PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int LODIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb7aced0);

		APlayerController_ClientUpdateLevelStreamingStatus_Params params;
		params.PackageName = PackageName;
		params.bNewShouldBeLoaded = bNewShouldBeLoaded;
		params.bNewShouldBeVisible = bNewShouldBeVisible;
		params.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;
		params.LODIndex = LODIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientUnmutePlayer
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FUniqueNetIdRepl        PlayerId                       (CPF_Parm)

	void APlayerController::ClientUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfea47fbe);

		APlayerController_ClientUnmutePlayer_Params params;
		params.PlayerId = PlayerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientTravelInternal
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// struct FString                 URL                            (CPF_Parm, CPF_ZeroConstructor)
	// TEnumAsByte<ETravelType>       TravelType                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSeamless                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FGuid                   MapPackageGuid                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientTravelInternal(const struct FString& URL, TEnumAsByte<ETravelType> TravelType, bool bSeamless, const struct FGuid& MapPackageGuid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeaa7ca94);

		APlayerController_ClientTravelInternal_Params params;
		params.URL = URL;
		params.TravelType = TravelType;
		params.bSeamless = bSeamless;
		params.MapPackageGuid = MapPackageGuid;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientTravel
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults)
	// Parameters:
	// struct FString                 URL                            (CPF_Parm, CPF_ZeroConstructor)
	// TEnumAsByte<ETravelType>       TravelType                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSeamless                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FGuid                   MapPackageGuid                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientTravel(const struct FString& URL, TEnumAsByte<ETravelType> TravelType, bool bSeamless, const struct FGuid& MapPackageGuid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9aa5a4bb);

		APlayerController_ClientTravel_Params params;
		params.URL = URL;
		params.TravelType = TravelType;
		params.bSeamless = bSeamless;
		params.MapPackageGuid = MapPackageGuid;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientTeamMessage
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class APlayerState*            SenderPlayerState              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 S                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FName                   Type                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MsgLifeTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientTeamMessage(class APlayerState* SenderPlayerState, const struct FString& S, const struct FName& Type, float MsgLifeTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x78ee0a71);

		APlayerController_ClientTeamMessage_Params params;
		params.SenderPlayerState = SenderPlayerState;
		params.S = S;
		params.Type = Type;
		params.MsgLifeTime = MsgLifeTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientStopForceFeedback
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient, FUNC_BlueprintCallable)
	// Parameters:
	// class UForceFeedbackEffect*    ForceFeedbackEffect            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   Tag                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, const struct FName& Tag) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x45b844f1);

		APlayerController_ClientStopForceFeedback_Params params;
		params.ForceFeedbackEffect = ForceFeedbackEffect;
		params.Tag = Tag;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientStopCameraShake
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  Shake                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bImmediately                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientStopCameraShake(class UClass* Shake, bool bImmediately) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe9a83828);

		APlayerController_ClientStopCameraShake_Params params;
		params.Shake = Shake;
		params.bImmediately = bImmediately;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientStopCameraAnim
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class UCameraAnim*             AnimToStop                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientStopCameraAnim(class UCameraAnim* AnimToStop) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb829f9d5);

		APlayerController_ClientStopCameraAnim_Params params;
		params.AnimToStop = AnimToStop;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientStartOnlineSession
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientStartOnlineSession() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x98eb394c);

		APlayerController_ClientStartOnlineSession_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSpawnCameraLensEffect
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  LensEffectEmitterClass         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientSpawnCameraLensEffect(class UClass* LensEffectEmitterClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb61337e);

		APlayerController_ClientSpawnCameraLensEffect_Params params;
		params.LensEffectEmitterClass = LensEffectEmitterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSetViewTarget
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class AActor*                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FViewTargetTransitionParams TransitionParams               (CPF_Parm)

	void APlayerController::ClientSetViewTarget(class AActor* A, const struct FViewTargetTransitionParams& TransitionParams) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4f9fd755);

		APlayerController_ClientSetViewTarget_Params params;
		params.A = A;
		params.TransitionParams = TransitionParams;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSetSpectatorWaiting
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// bool                           bWaiting                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientSetSpectatorWaiting(bool bWaiting) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x324bf8f1);

		APlayerController_ClientSetSpectatorWaiting_Params params;
		params.bWaiting = bWaiting;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSetHUD
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  NewHUDClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientSetHUD(class UClass* NewHUDClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaec9a348);

		APlayerController_ClientSetHUD_Params params;
		params.NewHUDClass = NewHUDClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ForceDuration                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            CinematicTextureGroups         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, int CinematicTextureGroups) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc05c3d15);

		APlayerController_ClientSetForceMipLevelsToBeResident_Params params;
		params.Material = Material;
		params.ForceDuration = ForceDuration;
		params.CinematicTextureGroups = CinematicTextureGroups;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSetCinematicMode
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// bool                           bInCinematicMode               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsMovement               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsTurning                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsHUD                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7282865d);

		APlayerController_ClientSetCinematicMode_Params params;
		params.bInCinematicMode = bInCinematicMode;
		params.bAffectsMovement = bAffectsMovement;
		params.bAffectsTurning = bAffectsTurning;
		params.bAffectsHUD = bAffectsHUD;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSetCameraMode
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FName                   NewCamMode                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientSetCameraMode(const struct FName& NewCamMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x91f04f85);

		APlayerController_ClientSetCameraMode_Params params;
		params.NewCamMode = NewCamMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSetCameraFade
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// bool                           bEnableFading                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FColor                  FadeColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               FadeAlpha                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FadeTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFadeAudio                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientSetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x669debe6);

		APlayerController_ClientSetCameraFade_Params params;
		params.bEnableFading = bEnableFading;
		params.FadeColor = FadeColor;
		params.FadeAlpha = FadeAlpha;
		params.FadeTime = FadeTime;
		params.bFadeAudio = bFadeAudio;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientSetBlockOnAsyncLoading
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientSetBlockOnAsyncLoading() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xabd28ce3);

		APlayerController_ClientSetBlockOnAsyncLoading_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientReturnToMainMenu
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FString                 ReturnReason                   (CPF_Parm, CPF_ZeroConstructor)

	void APlayerController::ClientReturnToMainMenu(const struct FString& ReturnReason) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37c94a8c);

		APlayerController_ClientReturnToMainMenu_Params params;
		params.ReturnReason = ReturnReason;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientRetryClientRestart
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class APawn*                   NewPawn                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientRetryClientRestart(class APawn* NewPawn) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1cd820af);

		APlayerController_ClientRetryClientRestart_Params params;
		params.NewPawn = NewPawn;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientRestart
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class APawn*                   NewPawn                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientRestart(class APawn* NewPawn) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa8fa5f44);

		APlayerController_ClientRestart_Params params;
		params.NewPawn = NewPawn;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientReset
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientReset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6df3f900);

		APlayerController_ClientReset_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientRepObjRef
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientRepObjRef(class UObject* Object) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c593b66);

		APlayerController_ClientRepObjRef_Params params;
		params.Object = Object;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientReceiveLocalizedMessage
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class UClass*                  Message                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Switch                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APlayerState*            RelatedPlayerState_2           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APlayerState*            RelatedPlayerState_3           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UObject*                 OptionalObject                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientReceiveLocalizedMessage(class UClass* Message, int Switch, class APlayerState* RelatedPlayerState_2, class APlayerState* RelatedPlayerState_3, class UObject* OptionalObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdd75d35a);

		APlayerController_ClientReceiveLocalizedMessage_Params params;
		params.Message = Message;
		params.Switch = Switch;
		params.RelatedPlayerState_2 = RelatedPlayerState_2;
		params.RelatedPlayerState_3 = RelatedPlayerState_3;
		params.OptionalObject = OptionalObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientPrestreamTextures
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class AActor*                  ForcedActor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ForceDuration                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableStreaming               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            CinematicTextureGroups         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int CinematicTextureGroups) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb4e2d3fa);

		APlayerController_ClientPrestreamTextures_Params params;
		params.ForcedActor = ForcedActor;
		params.ForceDuration = ForceDuration;
		params.bEnableStreaming = bEnableStreaming;
		params.CinematicTextureGroups = CinematicTextureGroups;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientPrepareMapChange
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FName                   LevelName                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFirst                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLast                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientPrepareMapChange(const struct FName& LevelName, bool bFirst, bool bLast) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbe1617a2);

		APlayerController_ClientPrepareMapChange_Params params;
		params.LevelName = LevelName;
		params.bFirst = bFirst;
		params.bLast = bLast;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientPlaySoundAtLocation
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// class USoundBase*              Sound                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientPlaySoundAtLocation(class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbbdc0da0);

		APlayerController_ClientPlaySoundAtLocation_Params params;
		params.Sound = Sound;
		params.Location = Location;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientPlaySound
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class USoundBase*              Sound                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x61f7b9e6);

		APlayerController_ClientPlaySound_Params params;
		params.Sound = Sound;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientPlayForceFeedback
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient, FUNC_BlueprintCallable)
	// Parameters:
	// class UForceFeedbackEffect*    ForceFeedbackEffect            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLooping                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   Tag                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, bool bLooping, const struct FName& Tag) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd1209caf);

		APlayerController_ClientPlayForceFeedback_Params params;
		params.ForceFeedbackEffect = ForceFeedbackEffect;
		params.bLooping = bLooping;
		params.Tag = Tag;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientPlayCameraShake
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  Shake                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECameraAnimPlaySpace> PlaySpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                UserPlaySpaceRot               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientPlayCameraShake(class UClass* Shake, float Scale, TEnumAsByte<ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8195f56e);

		APlayerController_ClientPlayCameraShake_Params params;
		params.Shake = Shake;
		params.Scale = Scale;
		params.PlaySpace = PlaySpace;
		params.UserPlaySpaceRot = UserPlaySpaceRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientPlayCameraAnim
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient, FUNC_BlueprintCallable)
	// Parameters:
	// class UCameraAnim*             AnimToPlay                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Rate                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendInTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendOutTime                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLoop                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bRandomStartTime               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECameraAnimPlaySpace> Space                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                CustomPlaySpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, TEnumAsByte<ECameraAnimPlaySpace> Space, const struct FRotator& CustomPlaySpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x94c7684b);

		APlayerController_ClientPlayCameraAnim_Params params;
		params.AnimToPlay = AnimToPlay;
		params.Scale = Scale;
		params.Rate = Rate;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		params.bLoop = bLoop;
		params.bRandomStartTime = bRandomStartTime;
		params.Space = Space;
		params.CustomPlaySpace = CustomPlaySpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientMutePlayer
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FUniqueNetIdRepl        PlayerId                       (CPF_Parm)

	void APlayerController::ClientMutePlayer(const struct FUniqueNetIdRepl& PlayerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xae6d810b);

		APlayerController_ClientMutePlayer_Params params;
		params.PlayerId = PlayerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientMessage
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FString                 S                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FName                   Type                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MsgLifeTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientMessage(const struct FString& S, const struct FName& Type, float MsgLifeTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x286ca3ac);

		APlayerController_ClientMessage_Params params;
		params.S = S;
		params.Type = Type;
		params.MsgLifeTime = MsgLifeTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientIgnoreMoveInput
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// bool                           bIgnore                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientIgnoreMoveInput(bool bIgnore) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x303948ba);

		APlayerController_ClientIgnoreMoveInput_Params params;
		params.bIgnore = bIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientIgnoreLookInput
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// bool                           bIgnore                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientIgnoreLookInput(bool bIgnore) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x36689f3c);

		APlayerController_ClientIgnoreLookInput_Params params;
		params.bIgnore = bIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientGotoState
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// struct FName                   NewState                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientGotoState(const struct FName& NewState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa73e6441);

		APlayerController_ClientGotoState_Params params;
		params.NewState = NewState;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientGameEnded
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// class AActor*                  EndGameFocus                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIsWinner                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e20ad7f);

		APlayerController_ClientGameEnded_Params params;
		params.EndGameFocus = EndGameFocus;
		params.bIsWinner = bIsWinner;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientForceGarbageCollection
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientForceGarbageCollection() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x65729e55);

		APlayerController_ClientForceGarbageCollection_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientFlushLevelStreaming
	// (FUNC_Final, FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientFlushLevelStreaming() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfaf15ca1);

		APlayerController_ClientFlushLevelStreaming_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientEndOnlineSession
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientEndOnlineSession() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x44cf3b71);

		APlayerController_ClientEndOnlineSession_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientEnableNetworkVoice
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientEnableNetworkVoice(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa87910c2);

		APlayerController_ClientEnableNetworkVoice_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientCommitMapChange
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientCommitMapChange() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1cca8302);

		APlayerController_ClientCommitMapChange_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientClearCameraLensEffects
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient, FUNC_BlueprintCallable)

	void APlayerController::ClientClearCameraLensEffects() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb0d19b83);

		APlayerController_ClientClearCameraLensEffects_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientCapBandwidth
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// int                            Cap                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientCapBandwidth(int Cap) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc0f7c988);

		APlayerController_ClientCapBandwidth_Params params;
		params.Cap = Cap;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientCancelPendingMapChange
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void APlayerController::ClientCancelPendingMapChange() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9896a9c);

		APlayerController_ClientCancelPendingMapChange_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClientAddTextureStreamingLoc
	// (FUNC_Final, FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// struct FVector                 InLoc                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bOverrideLocation              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8a01af6b);

		APlayerController_ClientAddTextureStreamingLoc_Params params;
		params.InLoc = InLoc;
		params.Duration = Duration;
		params.bOverrideLocation = bOverrideLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ClearAudioListenerOverride
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void APlayerController::ClearAudioListenerOverride() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdfba7b69);

		APlayerController_ClearAudioListenerOverride_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.Camera
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   NewMode                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::Camera(const struct FName& NewMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa4988e4f);

		APlayerController_Camera_Params params;
		params.NewMode = NewMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.AddYawInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::AddYawInput(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5296c894);

		APlayerController_AddYawInput_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.AddRollInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::AddRollInput(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5bc583c6);

		APlayerController_AddRollInput_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.AddPitchInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::AddPitchInput(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x497ce225);

		APlayerController_AddPitchInput_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerController.ActivateTouchInterface
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTouchInterface*         NewTouchInterface              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerController::ActivateTouchInterface(class UTouchInterface* NewTouchInterface) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4169c9cf);

		APlayerController_ActivateTouchInterface_Params params;
		params.NewTouchInterface = NewTouchInterface;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.SpawnDefaultController
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void APawn::SpawnDefaultController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbaa202dd);

		APawn_SpawnDefaultController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.SetCanAffectNavigationGeneration
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bForceUpdate                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24dc0090);

		APawn_SetCanAffectNavigationGeneration_Params params;
		params.bNewValue = bNewValue;
		params.bForceUpdate = bForceUpdate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.ReceiveUnpossessed
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             OldController                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::ReceiveUnpossessed(class AController* OldController) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaa68572c);

		APawn_ReceiveUnpossessed_Params params;
		params.OldController = OldController;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.ReceivePossessed
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             NewController                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::ReceivePossessed(class AController* NewController) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76802593);

		APawn_ReceivePossessed_Params params;
		params.NewController = NewController;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.PawnMakeNoise
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Loudness                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NoiseLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseNoiseMakerLocation         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  NoiseMaker                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::PawnMakeNoise(float Loudness, const struct FVector& NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x56debce5);

		APawn_PawnMakeNoise_Params params;
		params.Loudness = Loudness;
		params.NoiseLocation = NoiseLocation;
		params.bUseNoiseMakerLocation = bUseNoiseMakerLocation;
		params.NoiseMaker = NoiseMaker;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.OnRep_PlayerState
	// (FUNC_Native, FUNC_Public)

	void APawn::OnRep_PlayerState() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5e22992c);

		APawn_OnRep_PlayerState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.OnRep_Controller
	// (FUNC_Native, FUNC_Public)

	void APawn::OnRep_Controller() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x49cdba46);

		APawn_OnRep_Controller_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.LaunchPawn
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 LaunchVelocity                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bXYOverride                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bZOverride                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::LaunchPawn(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7905ea1e);

		APawn_LaunchPawn_Params params;
		params.LaunchVelocity = LaunchVelocity;
		params.bXYOverride = bXYOverride;
		params.bZOverride = bZOverride;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.K2_GetMovementInputVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector APawn::K2_GetMovementInputVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5867b1d1);

		APawn_K2_GetMovementInputVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.IsPlayerControlled
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APawn::IsPlayerControlled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ad99efc);

		APawn_IsPlayerControlled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.IsMoveInputIgnored
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APawn::IsMoveInputIgnored() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x509fc768);

		APawn_IsMoveInputIgnored_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.IsLocallyControlled
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APawn::IsLocallyControlled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe7fd550d);

		APawn_IsLocallyControlled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.IsControlled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APawn::IsControlled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b39609f);

		APawn_IsControlled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.GetPendingMovementInputVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector APawn::GetPendingMovementInputVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e7764cc);

		APawn_GetPendingMovementInputVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.GetNavAgentLocation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector APawn::GetNavAgentLocation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x734d4660);

		APawn_GetNavAgentLocation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.GetMovementComponent
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UPawnMovementComponent*  ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UPawnMovementComponent* APawn::GetMovementComponent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1ba1acb5);

		APawn_GetMovementComponent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.GetMovementBaseActor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class APawn*                   Pawn                           (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* APawn::STATIC_GetMovementBaseActor(class APawn* Pawn) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc78ef026);

		APawn_GetMovementBaseActor_Params params;
		params.Pawn = Pawn;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.GetLastMovementInputVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector APawn::GetLastMovementInputVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2cd26cad);

		APawn_GetLastMovementInputVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.GetControlRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator APawn::GetControlRotation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x198b511c);

		APawn_GetControlRotation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.GetController
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AController*             ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AController* APawn::GetController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3ad9a1c3);

		APawn_GetController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.GetBaseAimRotation
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator APawn::GetBaseAimRotation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x68d2b729);

		APawn_GetBaseAimRotation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.DetachFromControllerPendingDestroy
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void APawn::DetachFromControllerPendingDestroy() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75088455);

		APawn_DetachFromControllerPendingDestroy_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.ConsumeMovementInputVector
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector APawn::ConsumeMovementInputVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x412882b7);

		APawn_ConsumeMovementInputVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Pawn.AddMovementInput
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 WorldDirection                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScaleValue                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bForce                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::AddMovementInput(const struct FVector& WorldDirection, float ScaleValue, bool bForce) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1a704557);

		APawn_AddMovementInput_Params params;
		params.WorldDirection = WorldDirection;
		params.ScaleValue = ScaleValue;
		params.bForce = bForce;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.AddControllerYawInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::AddControllerYawInput(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x78edd8e5);

		APawn_AddControllerYawInput_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.AddControllerRollInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::AddControllerRollInput(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x92f154b5);

		APawn_AddControllerRollInput_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Pawn.AddControllerPitchInput
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APawn::AddControllerPitchInput(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8a7c8360);

		APawn_AddControllerPitchInput_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.UnCrouch
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bClientSimulation              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::UnCrouch(bool bClientSimulation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe9451899);

		ACharacter_UnCrouch_Params params;
		params.bClientSimulation = bClientSimulation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.StopJumping
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void ACharacter::StopJumping() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xca08c66);

		ACharacter_StopJumping_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.StopAnimMontage
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimMontage*            AnimMontage                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::StopAnimMontage(class UAnimMontage* AnimMontage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x113afa40);

		ACharacter_StopAnimMontage_Params params;
		params.AnimMontage = AnimMontage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.SetReplicateMovement
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInReplicateMovement           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::SetReplicateMovement(bool bInReplicateMovement) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x93a3ea2c);

		ACharacter_SetReplicateMovement_Params params;
		params.bInReplicateMovement = bInReplicateMovement;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.PlayAnimMontage
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimMontage*            AnimMontage                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPlayRate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   StartSectionName               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float ACharacter::PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, const struct FName& StartSectionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xffb7d222);

		ACharacter_PlayAnimMontage_Params params;
		params.AnimMontage = AnimMontage;
		params.InPlayRate = InPlayRate;
		params.StartSectionName = StartSectionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.OnWalkingOffLedge
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// struct FVector                 PreviousFloorImpactNormal      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 PreviousFloorContactNormal     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 PreviousLocation               (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          TimeDelta                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::OnWalkingOffLedge(const struct FVector& PreviousFloorImpactNormal, const struct FVector& PreviousFloorContactNormal, const struct FVector& PreviousLocation, float TimeDelta) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb612d7e4);

		ACharacter_OnWalkingOffLedge_Params params;
		params.PreviousFloorImpactNormal = PreviousFloorImpactNormal;
		params.PreviousFloorContactNormal = PreviousFloorContactNormal;
		params.PreviousLocation = PreviousLocation;
		params.TimeDelta = TimeDelta;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.OnRep_RootMotion
	// (FUNC_Final, FUNC_Native, FUNC_Public)

	void ACharacter::OnRep_RootMotion() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37b3ae33);

		ACharacter_OnRep_RootMotion_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.OnRep_ReplicatedBasedMovement
	// (FUNC_Native, FUNC_Public)

	void ACharacter::OnRep_ReplicatedBasedMovement() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5461544);

		ACharacter_OnRep_ReplicatedBasedMovement_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.OnRep_IsCrouched
	// (FUNC_Native, FUNC_Public)

	void ACharacter::OnRep_IsCrouched() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ca45280);

		ACharacter_OnRep_IsCrouched_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.OnLaunched
	// (FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// struct FVector                 LaunchVelocity                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bXYOverride                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bZOverride                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::OnLaunched(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4afc881b);

		ACharacter_OnLaunched_Params params;
		params.LaunchVelocity = LaunchVelocity;
		params.bXYOverride = bXYOverride;
		params.bZOverride = bZOverride;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.OnLanded
	// (FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintEvent)
	// Parameters:
	// struct FHitResult              Hit                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void ACharacter::OnLanded(const struct FHitResult& Hit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2e590d71);

		ACharacter_OnLanded_Params params;
		params.Hit = Hit;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.OnJumped
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void ACharacter::OnJumped() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x44201736);

		ACharacter_OnJumped_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.LaunchCharacter
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 LaunchVelocity                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bXYOverride                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bZOverride                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3ae750f4);

		ACharacter_LaunchCharacter_Params params;
		params.LaunchVelocity = LaunchVelocity;
		params.bXYOverride = bXYOverride;
		params.bZOverride = bZOverride;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.K2_UpdateCustomMovement
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::K2_UpdateCustomMovement(float DeltaTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85fb4e49);

		ACharacter_K2_UpdateCustomMovement_Params params;
		params.DeltaTime = DeltaTime;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.K2_OnStartCrouch
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// float                          HalfHeightAdjust               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScaledHalfHeightAdjust         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf9c1436b);

		ACharacter_K2_OnStartCrouch_Params params;
		params.HalfHeightAdjust = HalfHeightAdjust;
		params.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.K2_OnMovementModeChanged
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<EMovementMode>     PrevMovementMode               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EMovementMode>     NewMovementMode                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  PrevCustomMode                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  NewCustomMode                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::K2_OnMovementModeChanged(TEnumAsByte<EMovementMode> PrevMovementMode, TEnumAsByte<EMovementMode> NewMovementMode, unsigned char PrevCustomMode, unsigned char NewCustomMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe57461cf);

		ACharacter_K2_OnMovementModeChanged_Params params;
		params.PrevMovementMode = PrevMovementMode;
		params.NewMovementMode = NewMovementMode;
		params.PrevCustomMode = PrevCustomMode;
		params.NewCustomMode = NewCustomMode;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.K2_OnEndCrouch
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// float                          HalfHeightAdjust               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ScaledHalfHeightAdjust         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb581ff04);

		ACharacter_K2_OnEndCrouch_Params params;
		params.HalfHeightAdjust = HalfHeightAdjust;
		params.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.Jump
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void ACharacter::Jump() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe43b6422);

		ACharacter_Jump_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.IsPlayingRootMotion
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ACharacter::IsPlayingRootMotion() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x685f33a2);

		ACharacter_IsPlayingRootMotion_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.IsPlayingNetworkedRootMotionMontage
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ACharacter::IsPlayingNetworkedRootMotionMontage() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc18311f2);

		ACharacter_IsPlayingNetworkedRootMotionMontage_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.IsJumpProvidingForce
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ACharacter::IsJumpProvidingForce() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c109401);

		ACharacter_IsJumpProvidingForce_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.GetMesh
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class USkeletalMeshComponent*  ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class USkeletalMeshComponent* ACharacter::GetMesh() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x82e758b9);

		ACharacter_GetMesh_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.GetCurrentMontage
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimMontage*            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UAnimMontage* ACharacter::GetCurrentMontage() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd0aed2ac);

		ACharacter_GetCurrentMontage_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.GetCharacterMovement
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UCharacterMovementComponent* ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UCharacterMovementComponent* ACharacter::GetCharacterMovement() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x72c767c0);

		ACharacter_GetCharacterMovement_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.GetCapsuleComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UCapsuleComponent*       ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UCapsuleComponent* ACharacter::GetCapsuleComponent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf41c120);

		ACharacter_GetCapsuleComponent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.GetBaseTranslationOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector ACharacter::GetBaseTranslationOffset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfead7f5b);

		ACharacter_GetBaseTranslationOffset_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.GetBaseRotationOffsetRotator
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator ACharacter::GetBaseRotationOffsetRotator() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb65d531d);

		ACharacter_GetBaseRotationOffsetRotator_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.GetAnimRootMotionTranslationScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float ACharacter::GetAnimRootMotionTranslationScale() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x56e65b92);

		ACharacter_GetAnimRootMotionTranslationScale_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.Crouch
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bClientSimulation              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ACharacter::Crouch(bool bClientSimulation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3c8af49c);

		ACharacter_Crouch_Params params;
		params.bClientSimulation = bClientSimulation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.ClientCheatWalk
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void ACharacter::ClientCheatWalk() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x821d069f);

		ACharacter_ClientCheatWalk_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.ClientCheatGhost
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void ACharacter::ClientCheatGhost() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4ddd6f59);

		ACharacter_ClientCheatGhost_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.ClientCheatFly
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)

	void ACharacter::ClientCheatFly() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5fb62a4f);

		ACharacter_ClientCheatFly_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Character.CanJumpInternal
	// (FUNC_Native, FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ACharacter::CanJumpInternal() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x663444e3);

		ACharacter_CanJumpInternal_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Character.CanJump
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ACharacter::CanJump() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2378d090);

		ACharacter_CanJump_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.StopMovementImmediately
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UMovementComponent::StopMovementImmediately() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef58a2a0);

		UMovementComponent_StopMovementImmediately_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.SnapUpdatedComponentToPlane
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UMovementComponent::SnapUpdatedComponentToPlane() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf1edc91a);

		UMovementComponent_SnapUpdatedComponentToPlane_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.SetUpdatedComponent
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         NewUpdatedComponent            (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void UMovementComponent::SetUpdatedComponent(class USceneComponent* NewUpdatedComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2a744e85);

		UMovementComponent_SetUpdatedComponent_Params params;
		params.NewUpdatedComponent = NewUpdatedComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.SetPlaneConstraintOrigin
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 PlaneOrigin                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMovementComponent::SetPlaneConstraintOrigin(const struct FVector& PlaneOrigin) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5bd4043c);

		UMovementComponent_SetPlaneConstraintOrigin_Params params;
		params.PlaneOrigin = PlaneOrigin;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.SetPlaneConstraintNormal
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 PlaneNormal                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMovementComponent::SetPlaneConstraintNormal(const struct FVector& PlaneNormal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x80e90d33);

		UMovementComponent_SetPlaneConstraintNormal_Params params;
		params.PlaneNormal = PlaneNormal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.SetPlaneConstraintFromVectors
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Forward                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Up                             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMovementComponent::SetPlaneConstraintFromVectors(const struct FVector& Forward, const struct FVector& Up) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xac8bda7e);

		UMovementComponent_SetPlaneConstraintFromVectors_Params params;
		params.Forward = Forward;
		params.Up = Up;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.SetPlaneConstraintEnabled
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnabled                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMovementComponent::SetPlaneConstraintEnabled(bool bEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c293c2d);

		UMovementComponent_SetPlaneConstraintEnabled_Params params;
		params.bEnabled = bEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.SetPlaneConstraintAxisSetting
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EPlaneConstraintAxisSetting> NewAxisSetting                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMovementComponent::SetPlaneConstraintAxisSetting(TEnumAsByte<EPlaneConstraintAxisSetting> NewAxisSetting) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x70b26f87);

		UMovementComponent_SetPlaneConstraintAxisSetting_Params params;
		params.NewAxisSetting = NewAxisSetting;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.PhysicsVolumeChanged
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// class APhysicsVolume*          NewVolume                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMovementComponent::PhysicsVolumeChanged(class APhysicsVolume* NewVolume) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaba76bf6);

		UMovementComponent_PhysicsVolumeChanged_Params params;
		params.NewVolume = NewVolume;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MovementComponent.K2_MoveUpdatedComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Delta                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bSweep                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UMovementComponent::K2_MoveUpdatedComponent(const struct FVector& Delta, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfbfeabbc);

		UMovementComponent_K2_MoveUpdatedComponent_Params params;
		params.Delta = Delta;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.K2_GetModifiedMaxSpeed
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UMovementComponent::K2_GetModifiedMaxSpeed() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe44ceaf1);

		UMovementComponent_K2_GetModifiedMaxSpeed_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.K2_GetMaxSpeedModifier
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UMovementComponent::K2_GetMaxSpeedModifier() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc36d3bb);

		UMovementComponent_K2_GetMaxSpeedModifier_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.IsExceedingMaxSpeed
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          MaxSpeed                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UMovementComponent::IsExceedingMaxSpeed(float MaxSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5be50318);

		UMovementComponent_IsExceedingMaxSpeed_Params params;
		params.MaxSpeed = MaxSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.GetPlaneConstraintOrigin
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	struct FVector UMovementComponent::GetPlaneConstraintOrigin() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa4ac3358);

		UMovementComponent_GetPlaneConstraintOrigin_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.GetPlaneConstraintNormal
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	struct FVector UMovementComponent::GetPlaneConstraintNormal() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdb9504b7);

		UMovementComponent_GetPlaneConstraintNormal_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.GetPlaneConstraintAxisSetting
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<EPlaneConstraintAxisSetting> ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<EPlaneConstraintAxisSetting> UMovementComponent::GetPlaneConstraintAxisSetting() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1f844fbb);

		UMovementComponent_GetPlaneConstraintAxisSetting_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.GetPhysicsVolume
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APhysicsVolume*          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APhysicsVolume* UMovementComponent::GetPhysicsVolume() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb271fb8);

		UMovementComponent_GetPhysicsVolume_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.GetMaxSpeed
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UMovementComponent::GetMaxSpeed() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4adc56f0);

		UMovementComponent_GetMaxSpeed_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.GetGravityZ
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UMovementComponent::GetGravityZ() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc8b65e3);

		UMovementComponent_GetGravityZ_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.ConstrainNormalToPlane
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 Normal                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UMovementComponent::ConstrainNormalToPlane(const struct FVector& Normal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x23198d50);

		UMovementComponent_ConstrainNormalToPlane_Params params;
		params.Normal = Normal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.ConstrainLocationToPlane
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UMovementComponent::ConstrainLocationToPlane(const struct FVector& Location) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7517c85c);

		UMovementComponent_ConstrainLocationToPlane_Params params;
		params.Location = Location;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MovementComponent.ConstrainDirectionToPlane
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 Direction                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UMovementComponent::ConstrainDirectionToPlane(const struct FVector& Direction) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3b8ac146);

		UMovementComponent_ConstrainDirectionToPlane_Params params;
		params.Direction = Direction;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavMovementComponent.StopMovementKeepPathing
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UNavMovementComponent::StopMovementKeepPathing() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16efd09f);

		UNavMovementComponent_StopMovementKeepPathing_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavMovementComponent.StopActiveMovement
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UNavMovementComponent::StopActiveMovement() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9feecb0d);

		UNavMovementComponent_StopActiveMovement_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavMovementComponent.IsSwimming
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavMovementComponent::IsSwimming() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf64deedb);

		UNavMovementComponent_IsSwimming_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavMovementComponent.IsMovingOnGround
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavMovementComponent::IsMovingOnGround() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1c711594);

		UNavMovementComponent_IsMovingOnGround_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavMovementComponent.IsFlying
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavMovementComponent::IsFlying() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc1009b69);

		UNavMovementComponent_IsFlying_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavMovementComponent.IsFalling
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavMovementComponent::IsFalling() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbe711039);

		UNavMovementComponent_IsFalling_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavMovementComponent.IsCrouching
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavMovementComponent::IsCrouching() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9b84fe1a);

		UNavMovementComponent_IsCrouching_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PawnMovementComponent.K2_GetInputVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPawnMovementComponent::K2_GetInputVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x513a7462);

		UPawnMovementComponent_K2_GetInputVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PawnMovementComponent.IsMoveInputIgnored
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPawnMovementComponent::IsMoveInputIgnored() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe0790da);

		UPawnMovementComponent_IsMoveInputIgnored_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PawnMovementComponent.GetPendingInputVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPawnMovementComponent::GetPendingInputVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x36eca52f);

		UPawnMovementComponent_GetPendingInputVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PawnMovementComponent.GetPawnOwner
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APawn*                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APawn* UPawnMovementComponent::GetPawnOwner() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x66249e78);

		UPawnMovementComponent_GetPawnOwner_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PawnMovementComponent.GetLastInputVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPawnMovementComponent::GetLastInputVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3b65202);

		UPawnMovementComponent_GetLastInputVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PawnMovementComponent.ConsumeInputVector
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPawnMovementComponent::ConsumeInputVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf99d67b8);

		UPawnMovementComponent_ConsumeInputVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PawnMovementComponent.AddInputVector
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 WorldVector                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bForce                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPawnMovementComponent::AddInputVector(const struct FVector& WorldVector, bool bForce) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb45915e9);

		UPawnMovementComponent_AddInputVector_Params params;
		params.WorldVector = WorldVector;
		params.bForce = bForce;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetUseAutoGears
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bUseAuto                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetUseAutoGears(bool bUseAuto) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2369e9ad);

		UWheeledVehicleMovementComponent_SetUseAutoGears_Params params;
		params.bUseAuto = bUseAuto;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetThrottleInput
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Throttle                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetThrottleInput(float Throttle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe27f38fb);

		UWheeledVehicleMovementComponent_SetThrottleInput_Params params;
		params.Throttle = Throttle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetTargetGear
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            GearNum                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bImmediate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetTargetGear(int GearNum, bool bImmediate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4bd21b73);

		UWheeledVehicleMovementComponent_SetTargetGear_Params params;
		params.GearNum = GearNum;
		params.bImmediate = bImmediate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetSteeringInput
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Steering                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetSteeringInput(float Steering) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x83c0745c);

		UWheeledVehicleMovementComponent_SetSteeringInput_Params params;
		params.Steering = Steering;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetHandbrakeInput
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewHandbrake                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetHandbrakeInput(bool bNewHandbrake) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa9067dd1);

		UWheeledVehicleMovementComponent_SetHandbrakeInput_Params params;
		params.bNewHandbrake = bNewHandbrake;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetGroupsToIgnoreMask
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FNavAvoidanceMask       GroupMask                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetGroupsToIgnoreMask(const struct FNavAvoidanceMask& GroupMask) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf561710);

		UWheeledVehicleMovementComponent_SetGroupsToIgnoreMask_Params params;
		params.GroupMask = GroupMask;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetGroupsToIgnore
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            GroupFlags                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetGroupsToIgnore(int GroupFlags) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f947268);

		UWheeledVehicleMovementComponent_SetGroupsToIgnore_Params params;
		params.GroupFlags = GroupFlags;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetGroupsToAvoidMask
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FNavAvoidanceMask       GroupMask                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetGroupsToAvoidMask(const struct FNavAvoidanceMask& GroupMask) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc1218b1);

		UWheeledVehicleMovementComponent_SetGroupsToAvoidMask_Params params;
		params.GroupMask = GroupMask;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetGroupsToAvoid
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            GroupFlags                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetGroupsToAvoid(int GroupFlags) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x50b60f3d);

		UWheeledVehicleMovementComponent_SetGroupsToAvoid_Params params;
		params.GroupFlags = GroupFlags;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetGearUp
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewGearUp                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetGearUp(bool bNewGearUp) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1be103bb);

		UWheeledVehicleMovementComponent_SetGearUp_Params params;
		params.bNewGearUp = bNewGearUp;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetGearDown
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewGearDown                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetGearDown(bool bNewGearDown) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5030f80);

		UWheeledVehicleMovementComponent_SetGearDown_Params params;
		params.bNewGearDown = bNewGearDown;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetBrakeInput
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Brake                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetBrakeInput(float Brake) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x47ae3f1e);

		UWheeledVehicleMovementComponent_SetBrakeInput_Params params;
		params.Brake = Brake;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetAvoidanceGroupMask
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FNavAvoidanceMask       GroupMask                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetAvoidanceGroupMask(const struct FNavAvoidanceMask& GroupMask) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf2e30006);

		UWheeledVehicleMovementComponent_SetAvoidanceGroupMask_Params params;
		params.GroupMask = GroupMask;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetAvoidanceGroup
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            GroupFlags                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetAvoidanceGroup(int GroupFlags) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3efd454e);

		UWheeledVehicleMovementComponent_SetAvoidanceGroup_Params params;
		params.GroupFlags = GroupFlags;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.SetAvoidanceEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::SetAvoidanceEnabled(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5f6ebc8);

		UWheeledVehicleMovementComponent_SetAvoidanceEnabled_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.ServerUpdateState
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Protected, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// float                          InSteeringInput                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InThrottleInput                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InBrakeInput                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InHandbrakeInput               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            CurrentGear                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UWheeledVehicleMovementComponent::ServerUpdateState(float InSteeringInput, float InThrottleInput, float InBrakeInput, float InHandbrakeInput, int CurrentGear) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb20686f4);

		UWheeledVehicleMovementComponent_ServerUpdateState_Params params;
		params.InSteeringInput = InSteeringInput;
		params.InThrottleInput = InThrottleInput;
		params.InBrakeInput = InBrakeInput;
		params.InHandbrakeInput = InHandbrakeInput;
		params.CurrentGear = CurrentGear;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.OnRep_TirePunctured
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// TArray<bool>                   LastTirePunctured              (CPF_Parm, CPF_ZeroConstructor)

	void UWheeledVehicleMovementComponent::OnRep_TirePunctured(TArray<bool> LastTirePunctured) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6f455e4);

		UWheeledVehicleMovementComponent_OnRep_TirePunctured_Params params;
		params.LastTirePunctured = LastTirePunctured;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WheeledVehicleMovementComponent.GetUseAutoGears
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UWheeledVehicleMovementComponent::GetUseAutoGears() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2547dd1);

		UWheeledVehicleMovementComponent_GetUseAutoGears_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.WheeledVehicleMovementComponent.GetTargetGear
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UWheeledVehicleMovementComponent::GetTargetGear() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1c0ef5bf);

		UWheeledVehicleMovementComponent_GetTargetGear_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.WheeledVehicleMovementComponent.GetForwardSpeed
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UWheeledVehicleMovementComponent::GetForwardSpeed() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc89619ed);

		UWheeledVehicleMovementComponent_GetForwardSpeed_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.WheeledVehicleMovementComponent.GetEngineRotationSpeed
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UWheeledVehicleMovementComponent::GetEngineRotationSpeed() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe7f2dd52);

		UWheeledVehicleMovementComponent_GetEngineRotationSpeed_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.WheeledVehicleMovementComponent.GetEngineMaxRotationSpeed
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UWheeledVehicleMovementComponent::GetEngineMaxRotationSpeed() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdfe4436);

		UWheeledVehicleMovementComponent_GetEngineMaxRotationSpeed_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.WheeledVehicleMovementComponent.GetCurrentGear
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UWheeledVehicleMovementComponent::GetCurrentGear() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1d2d9071);

		UWheeledVehicleMovementComponent_GetCurrentGear_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.SeverAddRotationVelocity
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Protected, FUNC_NetServer, FUNC_HasDefaults, FUNC_NetValidate)
	// Parameters:
	// struct FVector                 RotationVelocity               (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SeverAddRotationVelocity(const struct FVector& RotationVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab221179);

		UCharacterMovementComponent_SeverAddRotationVelocity_Params params;
		params.RotationVelocity = RotationVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetWalkableFloorZ
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InWalkableFloorZ               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x46051e65);

		UCharacterMovementComponent_SetWalkableFloorZ_Params params;
		params.InWalkableFloorZ = InWalkableFloorZ;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetWalkableFloorAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InWalkableFloorAngle           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa69c07aa);

		UCharacterMovementComponent_SetWalkableFloorAngle_Params params;
		params.InWalkableFloorAngle = InWalkableFloorAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetProneWalkableFloorAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InWalkableFloorAngle           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetProneWalkableFloorAngle(float InWalkableFloorAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc5eb9830);

		UCharacterMovementComponent_SetProneWalkableFloorAngle_Params params;
		params.InWalkableFloorAngle = InWalkableFloorAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetMovementMode
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EMovementMode>     NewMovementMode                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  NewCustomMode                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetMovementMode(TEnumAsByte<EMovementMode> NewMovementMode, unsigned char NewCustomMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76b9d190);

		UCharacterMovementComponent_SetMovementMode_Params params;
		params.NewMovementMode = NewMovementMode;
		params.NewCustomMode = NewCustomMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetGroupsToIgnoreMask
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FNavAvoidanceMask       GroupMask                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetGroupsToIgnoreMask(const struct FNavAvoidanceMask& GroupMask) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7bf858ff);

		UCharacterMovementComponent_SetGroupsToIgnoreMask_Params params;
		params.GroupMask = GroupMask;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetGroupsToIgnore
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            GroupFlags                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetGroupsToIgnore(int GroupFlags) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8892f48b);

		UCharacterMovementComponent_SetGroupsToIgnore_Params params;
		params.GroupFlags = GroupFlags;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetGroupsToAvoidMask
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FNavAvoidanceMask       GroupMask                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetGroupsToAvoidMask(const struct FNavAvoidanceMask& GroupMask) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe9895070);

		UCharacterMovementComponent_SetGroupsToAvoidMask_Params params;
		params.GroupMask = GroupMask;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetGroupsToAvoid
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            GroupFlags                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetGroupsToAvoid(int GroupFlags) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18559908);

		UCharacterMovementComponent_SetGroupsToAvoid_Params params;
		params.GroupFlags = GroupFlags;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetAvoidanceGroupMask
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FNavAvoidanceMask       GroupMask                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetAvoidanceGroupMask(const struct FNavAvoidanceMask& GroupMask) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x207fe8bd);

		UCharacterMovementComponent_SetAvoidanceGroupMask_Params params;
		params.GroupMask = GroupMask;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetAvoidanceGroup
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            GroupFlags                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetAvoidanceGroup(int GroupFlags) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdce234e1);

		UCharacterMovementComponent_SetAvoidanceGroup_Params params;
		params.GroupFlags = GroupFlags;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.SetAvoidanceEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::SetAvoidanceEnabled(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xee17852b);

		UCharacterMovementComponent_SetAvoidanceEnabled_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ServerMoveOld
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// float                          OldTimeStamp                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector_NetQuantize10   OldAccel                       (CPF_Parm)
	// unsigned char                  OldMoveFlags                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, unsigned char OldMoveFlags) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5df14317);

		UCharacterMovementComponent_ServerMoveOld_Params params;
		params.OldTimeStamp = OldTimeStamp;
		params.OldAccel = OldAccel;
		params.OldMoveFlags = OldMoveFlags;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ServerMoveDualHybridRootMotion
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// float                          TimeStamp0                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector_NetQuantize10   InAccel0                       (CPF_Parm)
	// unsigned char                  PendingFlags                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// uint32_t                       View0                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TimeStamp                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector_NetQuantize10   InAccel                        (CPF_Parm)
	// struct FVector_NetQuantize100  ClientLoc                      (CPF_Parm)
	// unsigned char                  NewFlags                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ClientRoll                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// uint32_t                       View                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     ClientMovementBase             (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   ClientBaseBoneName             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ClientMovementMode             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ServerMoveDualHybridRootMotion(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, unsigned char PendingFlags, uint32_t View0, float TimeStamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x58506e4a);

		UCharacterMovementComponent_ServerMoveDualHybridRootMotion_Params params;
		params.TimeStamp0 = TimeStamp0;
		params.InAccel0 = InAccel0;
		params.PendingFlags = PendingFlags;
		params.View0 = View0;
		params.TimeStamp = TimeStamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.NewFlags = NewFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ServerMoveDual
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// float                          TimeStamp0                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector_NetQuantize10   InAccel0                       (CPF_Parm)
	// unsigned char                  PendingFlags                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// uint32_t                       View0                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TimeStamp                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector_NetQuantize10   InAccel                        (CPF_Parm)
	// struct FVector_NetQuantize100  ClientLoc                      (CPF_Parm)
	// unsigned char                  NewFlags                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ClientRoll                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// uint32_t                       View                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     ClientMovementBase             (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   ClientBaseBoneName             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ClientMovementMode             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, unsigned char PendingFlags, uint32_t View0, float TimeStamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16f09b8a);

		UCharacterMovementComponent_ServerMoveDual_Params params;
		params.TimeStamp0 = TimeStamp0;
		params.InAccel0 = InAccel0;
		params.PendingFlags = PendingFlags;
		params.View0 = View0;
		params.TimeStamp = TimeStamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.NewFlags = NewFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ServerMove
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)
	// Parameters:
	// float                          TimeStamp                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector_NetQuantize10   InAccel                        (CPF_Parm)
	// struct FVector_NetQuantize100  ClientLoc                      (CPF_Parm)
	// unsigned char                  CompressedMoveFlags            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ClientRoll                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// uint32_t                       View                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     ClientMovementBase             (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   ClientBaseBoneName             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ClientMovementMode             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ServerMove(float TimeStamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char CompressedMoveFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5bc09d88);

		UCharacterMovementComponent_ServerMove_Params params;
		params.TimeStamp = TimeStamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.CompressedMoveFlags = CompressedMoveFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCharacterMovementComponent::K2_GetWalkableFloorZ() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd9f1c10f);

		UCharacterMovementComponent_K2_GetWalkableFloorZ_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCharacterMovementComponent::K2_GetWalkableFloorAngle() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc154dc50);

		UCharacterMovementComponent_K2_GetWalkableFloorAngle_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCharacterMovementComponent::K2_GetModifiedMaxAcceleration() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc11efe65);

		UCharacterMovementComponent_K2_GetModifiedMaxAcceleration_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.K2_FindFloor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 CapsuleLocation                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FFindFloorResult        FloorResult                    (CPF_Parm, CPF_OutParm)

	void UCharacterMovementComponent::K2_FindFloor(const struct FVector& CapsuleLocation, struct FFindFloorResult* FloorResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x409d91fd);

		UCharacterMovementComponent_K2_FindFloor_Params params;
		params.CapsuleLocation = CapsuleLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (FloorResult != nullptr)
			*FloorResult = params.FloorResult;
	}


	// Function Engine.CharacterMovementComponent.K2_ComputeFloorDist
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 CapsuleLocation                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LineDistance                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          SweepDistance                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          SweepRadius                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FFindFloorResult        FloorResult                    (CPF_Parm, CPF_OutParm)

	void UCharacterMovementComponent::K2_ComputeFloorDist(const struct FVector& CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, struct FFindFloorResult* FloorResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3773063f);

		UCharacterMovementComponent_K2_ComputeFloorDist_Params params;
		params.CapsuleLocation = CapsuleLocation;
		params.LineDistance = LineDistance;
		params.SweepDistance = SweepDistance;
		params.SweepRadius = SweepRadius;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (FloorResult != nullptr)
			*FloorResult = params.FloorResult;
	}


	// Function Engine.CharacterMovementComponent.IsWalking
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UCharacterMovementComponent::IsWalking() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xda286537);

		UCharacterMovementComponent_IsWalking_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.IsWalkable
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FHitResult              Hit                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UCharacterMovementComponent::IsWalkable(const struct FHitResult& Hit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xda299475);

		UCharacterMovementComponent_IsWalkable_Params params;
		params.Hit = Hit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetValidPerchRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCharacterMovementComponent::GetValidPerchRadius() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x64db899a);

		UCharacterMovementComponent_GetValidPerchRadius_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCharacterMovementComponent::GetPerchRadiusThreshold() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96f74529);

		UCharacterMovementComponent_GetPerchRadiusThreshold_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetMovementBase
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UPrimitiveComponent*     ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UPrimitiveComponent* UCharacterMovementComponent::GetMovementBase() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54542702);

		UCharacterMovementComponent_GetMovementBase_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetMaxJumpHeight
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCharacterMovementComponent::GetMaxJumpHeight() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x78cb5fc9);

		UCharacterMovementComponent_GetMaxJumpHeight_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetMaxAcceleration
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCharacterMovementComponent::GetMaxAcceleration() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x58c4ecb0);

		UCharacterMovementComponent_GetMaxAcceleration_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UCharacterMovementComponent::GetImpartedMovementBaseVelocity() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc7c277d1);

		UCharacterMovementComponent_GetImpartedMovementBaseVelocity_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetCurrentAcceleration
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UCharacterMovementComponent::GetCurrentAcceleration() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x134e325);

		UCharacterMovementComponent_GetCurrentAcceleration_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetCharacterOwner
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class ACharacter*              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class ACharacter* UCharacterMovementComponent::GetCharacterOwner() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xced96c74);

		UCharacterMovementComponent_GetCharacterOwner_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.GetAnalogInputModifier
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCharacterMovementComponent::GetAnalogInputModifier() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc135d085);

		UCharacterMovementComponent_GetAnalogInputModifier_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CharacterMovementComponent.DisableMovement
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCharacterMovementComponent::DisableMovement() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcbcbda45);

		UCharacterMovementComponent_DisableMovement_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ClientVeryShortAdjustPosition
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// float                          TimeStamp                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewLoc                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     NewBase                        (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   NewBaseBoneName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bHasBase                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bBaseRelativePosition          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ServerMovementMode             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ClientVeryShortAdjustPosition(float TimeStamp, const struct FVector& NewLoc, class UPrimitiveComponent* NewBase, const struct FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x166ec567);

		UCharacterMovementComponent_ClientVeryShortAdjustPosition_Params params;
		params.TimeStamp = TimeStamp;
		params.NewLoc = NewLoc;
		params.NewBase = NewBase;
		params.NewBaseBoneName = NewBaseBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ClientAdjustRootMotionSourcePosition
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// float                          TimeStamp                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRootMotionSourceGroup  ServerRootMotion               (CPF_Parm)
	// bool                           bHasAnimRootMotion             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ServerMontageTrackPosition     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ServerLoc                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector_NetQuantizeNormal ServerRotation                 (CPF_Parm)
	// float                          ServerVelZ                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     ServerBase                     (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   ServerBoneName                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bHasBase                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bBaseRelativePosition          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ServerMovementMode             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ClientAdjustRootMotionSourcePosition(float TimeStamp, const struct FRootMotionSourceGroup& ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, const struct FName& ServerBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc70ecac6);

		UCharacterMovementComponent_ClientAdjustRootMotionSourcePosition_Params params;
		params.TimeStamp = TimeStamp;
		params.ServerRootMotion = ServerRootMotion;
		params.bHasAnimRootMotion = bHasAnimRootMotion;
		params.ServerMontageTrackPosition = ServerMontageTrackPosition;
		params.ServerLoc = ServerLoc;
		params.ServerRotation = ServerRotation;
		params.ServerVelZ = ServerVelZ;
		params.ServerBase = ServerBase;
		params.ServerBoneName = ServerBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ClientAdjustRootMotionPosition
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// float                          TimeStamp                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ServerMontageTrackPosition     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ServerLoc                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector_NetQuantizeNormal ServerRotation                 (CPF_Parm)
	// float                          ServerVelZ                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     ServerBase                     (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   ServerBoneName                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bHasBase                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bBaseRelativePosition          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ServerMovementMode             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ClientAdjustRootMotionPosition(float TimeStamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, const struct FName& ServerBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf9fea11);

		UCharacterMovementComponent_ClientAdjustRootMotionPosition_Params params;
		params.TimeStamp = TimeStamp;
		params.ServerMontageTrackPosition = ServerMontageTrackPosition;
		params.ServerLoc = ServerLoc;
		params.ServerRotation = ServerRotation;
		params.ServerVelZ = ServerVelZ;
		params.ServerBase = ServerBase;
		params.ServerBoneName = ServerBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ClientAdjustPosition
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasDefaults, FUNC_NetClient)
	// Parameters:
	// float                          TimeStamp                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewLoc                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewVel                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     NewBase                        (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   NewBaseBoneName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bHasBase                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bBaseRelativePosition          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ServerMovementMode             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ClientAdjustPosition(float TimeStamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, const struct FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37e9e8a3);

		UCharacterMovementComponent_ClientAdjustPosition_Params params;
		params.TimeStamp = TimeStamp;
		params.NewLoc = NewLoc;
		params.NewVel = NewVel;
		params.NewBase = NewBase;
		params.NewBaseBoneName = NewBaseBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.ClientAckGoodMove
	// (FUNC_Net, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetClient)
	// Parameters:
	// float                          TimeStamp                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::ClientAckGoodMove(float TimeStamp) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x70c7879e);

		UCharacterMovementComponent_ClientAckGoodMove_Params params;
		params.TimeStamp = TimeStamp;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.CapsuleTouched
	// (FUNC_Native, FUNC_Protected, FUNC_HasOutParms)
	// Parameters:
	// class UPrimitiveComponent*     OverlappedComp                 (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// class AActor*                  Other                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     OtherComp                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// int                            OtherBodyIndex                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFromSweep                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              SweepResult                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UCharacterMovementComponent::CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c7e4c67);

		UCharacterMovementComponent_CapsuleTouched_Params params;
		params.OverlappedComp = OverlappedComp;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.CalcVelocity
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Friction                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFluid                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BrakingDeceleration            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16d1ab84);

		UCharacterMovementComponent_CalcVelocity_Params params;
		params.DeltaTime = DeltaTime;
		params.Friction = Friction;
		params.bFluid = bFluid;
		params.BrakingDeceleration = BrakingDeceleration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.AddImpulse
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Impulse                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bVelocityChange                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::AddImpulse(const struct FVector& Impulse, bool bVelocityChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaa1ca324);

		UCharacterMovementComponent_AddImpulse_Params params;
		params.Impulse = Impulse;
		params.bVelocityChange = bVelocityChange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CharacterMovementComponent.AddForce
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Force                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCharacterMovementComponent::AddForce(const struct FVector& Force) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8286334);

		UCharacterMovementComponent_AddForce_Params params;
		params.Force = Force;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.VehicleWheel.GetSuspensionOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UVehicleWheel::GetSuspensionOffset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x480126d2);

		UVehicleWheel_GetSuspensionOffset_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.VehicleWheel.GetSteerAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UVehicleWheel::GetSteerAngle() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x360b3f74);

		UVehicleWheel_GetSteerAngle_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.VehicleWheel.GetRotationAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UVehicleWheel::GetRotationAngle() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x43929987);

		UVehicleWheel_GetRotationAngle_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.VehicleWheel.GetLongitudinalSlip
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UVehicleWheel::GetLongitudinalSlip() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfc88d9aa);

		UVehicleWheel_GetLongitudinalSlip_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.VehicleWheel.GetLateralSlip
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UVehicleWheel::GetLateralSlip() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75412a3);

		UVehicleWheel_GetLateralSlip_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.UnlockAIResources
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bUnlockMovement                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           UnlockAILogic                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4c49906e);

		UAnimInstance_UnlockAIResources_Params params;
		params.bUnlockMovement = bUnlockMovement;
		params.UnlockAILogic = UnlockAILogic;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.TryGetPawnOwner
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APawn*                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APawn* UAnimInstance::TryGetPawnOwner() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x71017723);

		UAnimInstance_TryGetPawnOwner_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.StopSlotAnimation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InBlendOutTime                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   SlotNodeName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::StopSlotAnimation(float InBlendOutTime, const struct FName& SlotNodeName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb37ac265);

		UAnimInstance_StopSlotAnimation_Params params;
		params.InBlendOutTime = InBlendOutTime;
		params.SlotNodeName = SlotNodeName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.SetRootMotionMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ERootMotionMode>   Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::SetRootMotionMode(TEnumAsByte<ERootMotionMode> Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab319d4c);

		UAnimInstance_SetRootMotionMode_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.SetMorphTarget
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   MorphTargetName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::SetMorphTarget(const struct FName& MorphTargetName, float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf698548c);

		UAnimInstance_SetMorphTarget_Params params;
		params.MorphTargetName = MorphTargetName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimSequenceBase*       Asset                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   SlotNodeName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendInTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendOutTime                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPlayRate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            LoopCount                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendOutTriggerTime            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InTimeToStartMontageAt         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAnimMontage*            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage(class UAnimSequenceBase* Asset, const struct FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x515e11b1);

		UAnimInstance_PlaySlotAnimationAsDynamicMontage_Params params;
		params.Asset = Asset;
		params.SlotNodeName = SlotNodeName;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		params.InPlayRate = InPlayRate;
		params.LoopCount = LoopCount;
		params.BlendOutTriggerTime = BlendOutTriggerTime;
		params.InTimeToStartMontageAt = InTimeToStartMontageAt;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.PlaySlotAnimation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimSequenceBase*       Asset                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   SlotNodeName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendInTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendOutTime                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPlayRate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            LoopCount                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::PlaySlotAnimation(class UAnimSequenceBase* Asset, const struct FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int LoopCount) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x31c6dd87);

		UAnimInstance_PlaySlotAnimation_Params params;
		params.Asset = Asset;
		params.SlotNodeName = SlotNodeName;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		params.InPlayRate = InPlayRate;
		params.LoopCount = LoopCount;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.Montage_Stop
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InBlendOutTime                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::Montage_Stop(float InBlendOutTime, class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x157944c3);

		UAnimInstance_Montage_Stop_Params params;
		params.InBlendOutTime = InBlendOutTime;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.Montage_SetPlayRate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NewPlayRate                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::Montage_SetPlayRate(class UAnimMontage* Montage, float NewPlayRate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xca4a0685);

		UAnimInstance_Montage_SetPlayRate_Params params;
		params.Montage = Montage;
		params.NewPlayRate = NewPlayRate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.Montage_SetNextSection
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   SectionNameToChange            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   NextSection                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::Montage_SetNextSection(const struct FName& SectionNameToChange, const struct FName& NextSection, class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5a30d0fb);

		UAnimInstance_Montage_SetNextSection_Params params;
		params.SectionNameToChange = SectionNameToChange;
		params.NextSection = NextSection;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.Montage_Resume
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::Montage_Resume(class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x65a89b12);

		UAnimInstance_Montage_Resume_Params params;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.Montage_Play
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimMontage*            MontageToPlay                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPlayRate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EMontagePlayReturnType> ReturnValueType                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InTimeToStartMontageAt         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::Montage_Play(class UAnimMontage* MontageToPlay, float InPlayRate, TEnumAsByte<EMontagePlayReturnType> ReturnValueType, float InTimeToStartMontageAt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xae5961a5);

		UAnimInstance_Montage_Play_Params params;
		params.MontageToPlay = MontageToPlay;
		params.InPlayRate = InPlayRate;
		params.ReturnValueType = ReturnValueType;
		params.InTimeToStartMontageAt = InTimeToStartMontageAt;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.Montage_Pause
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::Montage_Pause(class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe8fbd753);

		UAnimInstance_Montage_Pause_Params params;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.Montage_JumpToSectionsEnd
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   SectionName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::Montage_JumpToSectionsEnd(const struct FName& SectionName, class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5a32ae0b);

		UAnimInstance_Montage_JumpToSectionsEnd_Params params;
		params.SectionName = SectionName;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.Montage_JumpToSection
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   SectionName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::Montage_JumpToSection(const struct FName& SectionName, class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc5b0c5d);

		UAnimInstance_Montage_JumpToSection_Params params;
		params.SectionName = SectionName;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.Montage_IsPlaying
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimInstance::Montage_IsPlaying(class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x411ad293);

		UAnimInstance_Montage_IsPlaying_Params params;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.Montage_IsActive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimInstance::Montage_IsActive(class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf0a2d29);

		UAnimInstance_Montage_IsActive_Params params;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.Montage_GetCurrentSection
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UAnimMontage*            Montage                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName UAnimInstance::Montage_GetCurrentSection(class UAnimMontage* Montage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4146331);

		UAnimInstance_Montage_GetCurrentSection_Params params;
		params.Montage = Montage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.LockAIResources
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bLockMovement                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           LockAILogic                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::LockAIResources(bool bLockMovement, bool LockAILogic) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1bec2421);

		UAnimInstance_LockAIResources_Params params;
		params.bLockMovement = bLockMovement;
		params.LockAILogic = LockAILogic;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.IsSyncGroupBetweenMarkers
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSyncGroupName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PreviousMarker                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   NextMarker                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bRespectMarkerOrder            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimInstance::IsSyncGroupBetweenMarkers(const struct FName& InSyncGroupName, const struct FName& PreviousMarker, const struct FName& NextMarker, bool bRespectMarkerOrder) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe6438404);

		UAnimInstance_IsSyncGroupBetweenMarkers_Params params;
		params.InSyncGroupName = InSyncGroupName;
		params.PreviousMarker = PreviousMarker;
		params.NextMarker = NextMarker;
		params.bRespectMarkerOrder = bRespectMarkerOrder;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.IsPlayingSlotAnimation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UAnimSequenceBase*       Asset                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   SlotNodeName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimInstance::IsPlayingSlotAnimation(class UAnimSequenceBase* Asset, const struct FName& SlotNodeName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4d3038e5);

		UAnimInstance_IsPlayingSlotAnimation_Params params;
		params.Asset = Asset;
		params.SlotNodeName = SlotNodeName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.HasMarkerBeenHitThisFrame
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   SyncGroup                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   MarkerName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimInstance::HasMarkerBeenHitThisFrame(const struct FName& SyncGroup, const struct FName& MarkerName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2e8f84ad);

		UAnimInstance_HasMarkerBeenHitThisFrame_Params params;
		params.SyncGroup = SyncGroup;
		params.MarkerName = MarkerName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetTimeToClosestMarker
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   SyncGroup                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   MarkerName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutMarkerTime                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimInstance::GetTimeToClosestMarker(const struct FName& SyncGroup, const struct FName& MarkerName, float* OutMarkerTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab18e16a);

		UAnimInstance_GetTimeToClosestMarker_Params params;
		params.SyncGroup = SyncGroup;
		params.MarkerName = MarkerName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutMarkerTime != nullptr)
			*OutMarkerTime = params.OutMarkerTime;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetSyncGroupPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSyncGroupName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FMarkerSyncAnimPosition ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FMarkerSyncAnimPosition UAnimInstance::GetSyncGroupPosition(const struct FName& InSyncGroupName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf2d3d66);

		UAnimInstance_GetSyncGroupPosition_Params params;
		params.InSyncGroupName = InSyncGroupName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetStateWeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StateIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetStateWeight(int MachineIndex, int StateIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9979d65a);

		UAnimInstance_GetStateWeight_Params params;
		params.MachineIndex = MachineIndex;
		params.StateIndex = StateIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StateIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetRelevantAnimTimeRemainingFraction(int MachineIndex, int StateIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6421c346);

		UAnimInstance_GetRelevantAnimTimeRemainingFraction_Params params;
		params.MachineIndex = MachineIndex;
		params.StateIndex = StateIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetRelevantAnimTimeRemaining
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StateIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetRelevantAnimTimeRemaining(int MachineIndex, int StateIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf837fa8);

		UAnimInstance_GetRelevantAnimTimeRemaining_Params params;
		params.MachineIndex = MachineIndex;
		params.StateIndex = StateIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetRelevantAnimTimeFraction
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StateIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetRelevantAnimTimeFraction(int MachineIndex, int StateIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2000b642);

		UAnimInstance_GetRelevantAnimTimeFraction_Params params;
		params.MachineIndex = MachineIndex;
		params.StateIndex = StateIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetRelevantAnimTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StateIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetRelevantAnimTime(int MachineIndex, int StateIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x60c1ca94);

		UAnimInstance_GetRelevantAnimTime_Params params;
		params.MachineIndex = MachineIndex;
		params.StateIndex = StateIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetRelevantAnimLength
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StateIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetRelevantAnimLength(int MachineIndex, int StateIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc3b30f27);

		UAnimInstance_GetRelevantAnimLength_Params params;
		params.MachineIndex = MachineIndex;
		params.StateIndex = StateIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetOwningComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class USkeletalMeshComponent*  ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class USkeletalMeshComponent* UAnimInstance::GetOwningComponent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb1916fc);

		UAnimInstance_GetOwningComponent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetOwningActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* UAnimInstance::GetOwningActor() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5bd7ac32);

		UAnimInstance_GetOwningActor_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TransitionIndex                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceTransitionTimeElapsedFraction(int MachineIndex, int TransitionIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f90058e);

		UAnimInstance_GetInstanceTransitionTimeElapsedFraction_Params params;
		params.MachineIndex = MachineIndex;
		params.TransitionIndex = TransitionIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TransitionIndex                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceTransitionTimeElapsed(int MachineIndex, int TransitionIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x51153d80);

		UAnimInstance_GetInstanceTransitionTimeElapsed_Params params;
		params.MachineIndex = MachineIndex;
		params.TransitionIndex = TransitionIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TransitionIndex                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceTransitionCrossfadeDuration(int MachineIndex, int TransitionIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d1b4ecb);

		UAnimInstance_GetInstanceTransitionCrossfadeDuration_Params params;
		params.MachineIndex = MachineIndex;
		params.TransitionIndex = TransitionIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceStateWeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StateIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceStateWeight(int MachineIndex, int StateIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2843389);

		UAnimInstance_GetInstanceStateWeight_Params params;
		params.MachineIndex = MachineIndex;
		params.StateIndex = StateIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceMachineWeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceMachineWeight(int MachineIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4d0f28d5);

		UAnimInstance_GetInstanceMachineWeight_Params params;
		params.MachineIndex = MachineIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceCurrentStateElapsedTime(int MachineIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x42bc0f5f);

		UAnimInstance_GetInstanceCurrentStateElapsedTime_Params params;
		params.MachineIndex = MachineIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            AssetPlayerIndex               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceAssetPlayerTimeFromEndFraction(int AssetPlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb23c1663);

		UAnimInstance_GetInstanceAssetPlayerTimeFromEndFraction_Params params;
		params.AssetPlayerIndex = AssetPlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            AssetPlayerIndex               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceAssetPlayerTimeFromEnd(int AssetPlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6deeddd5);

		UAnimInstance_GetInstanceAssetPlayerTimeFromEnd_Params params;
		params.AssetPlayerIndex = AssetPlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            AssetPlayerIndex               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceAssetPlayerTimeFraction(int AssetPlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3251f1bc);

		UAnimInstance_GetInstanceAssetPlayerTimeFraction_Params params;
		params.AssetPlayerIndex = AssetPlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceAssetPlayerTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            AssetPlayerIndex               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceAssetPlayerTime(int AssetPlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x335effea);

		UAnimInstance_GetInstanceAssetPlayerTime_Params params;
		params.AssetPlayerIndex = AssetPlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetInstanceAssetPlayerLength
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            AssetPlayerIndex               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetInstanceAssetPlayerLength(int AssetPlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc3a6023d);

		UAnimInstance_GetInstanceAssetPlayerLength_Params params;
		params.AssetPlayerIndex = AssetPlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetCurveValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FName                   CurveName                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetCurveValue(const struct FName& CurveName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x81b25bf7);

		UAnimInstance_GetCurveValue_Params params;
		params.CurveName = CurveName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetCurrentStateName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName UAnimInstance::GetCurrentStateName(int MachineIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf33d0f44);

		UAnimInstance_GetCurrentStateName_Params params;
		params.MachineIndex = MachineIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetCurrentStateElapsedTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            MachineIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetCurrentStateElapsedTime(int MachineIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdb02c19c);

		UAnimInstance_GetCurrentStateElapsedTime_Params params;
		params.MachineIndex = MachineIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEndFraction
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UAnimationAsset*         AnimAsset                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CurrentTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::STATIC_GetAnimAssetPlayerTimeFromEndFraction(class UAnimationAsset* AnimAsset, float CurrentTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd606418d);

		UAnimInstance_GetAnimAssetPlayerTimeFromEndFraction_Params params;
		params.AnimAsset = AnimAsset;
		params.CurrentTime = CurrentTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEnd
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UAnimationAsset*         AnimAsset                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CurrentTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::GetAnimAssetPlayerTimeFromEnd(class UAnimationAsset* AnimAsset, float CurrentTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x48851263);

		UAnimInstance_GetAnimAssetPlayerTimeFromEnd_Params params;
		params.AnimAsset = AnimAsset;
		params.CurrentTime = CurrentTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetAnimAssetPlayerTimeFraction
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UAnimationAsset*         AnimAsset                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CurrentTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::STATIC_GetAnimAssetPlayerTimeFraction(class UAnimationAsset* AnimAsset, float CurrentTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4ad909a);

		UAnimInstance_GetAnimAssetPlayerTimeFraction_Params params;
		params.AnimAsset = AnimAsset;
		params.CurrentTime = CurrentTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.GetAnimAssetPlayerLength
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UAnimationAsset*         AnimAsset                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::STATIC_GetAnimAssetPlayerLength(class UAnimationAsset* AnimAsset) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x72fa49df);

		UAnimInstance_GetAnimAssetPlayerLength_Params params;
		params.AnimAsset = AnimAsset;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.ClearMorphTargets
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UAnimInstance::ClearMorphTargets() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeb804100);

		UAnimInstance_ClearMorphTargets_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.CalculateDirection
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Velocity                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                BaseRotation                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimInstance::CalculateDirection(const struct FVector& Velocity, const struct FRotator& BaseRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8a0d94d2);

		UAnimInstance_CalculateDirection_Params params;
		params.Velocity = Velocity;
		params.BaseRotation = BaseRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimInstance.BlueprintUpdateAnimation
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// float                          DeltaTimeX                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimInstance::BlueprintUpdateAnimation(float DeltaTimeX) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe9632af5);

		UAnimInstance_BlueprintUpdateAnimation_Params params;
		params.DeltaTimeX = DeltaTimeX;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.BlueprintPostEvaluateAnimation
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void UAnimInstance::BlueprintPostEvaluateAnimation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd6ab8ca9);

		UAnimInstance_BlueprintPostEvaluateAnimation_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimInstance.BlueprintInitializeAnimation
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void UAnimInstance::BlueprintInitializeAnimation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xda6fd16e);

		UAnimInstance_BlueprintInitializeAnimation_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetUseFieldOfViewForLOD
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInUseFieldOfViewForLOD        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x14452d1c);

		UCameraComponent_SetUseFieldOfViewForLOD_Params params;
		params.bInUseFieldOfViewForLOD = bInUseFieldOfViewForLOD;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetProjectionMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ECameraProjectionMode> InProjectionMode               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetProjectionMode(TEnumAsByte<ECameraProjectionMode> InProjectionMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4d630d7);

		UCameraComponent_SetProjectionMode_Params params;
		params.InProjectionMode = InProjectionMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetPostProcessBlendWeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InPostProcessBlendWeight       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetPostProcessBlendWeight(float InPostProcessBlendWeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b95eb2f);

		UCameraComponent_SetPostProcessBlendWeight_Params params;
		params.InPostProcessBlendWeight = InPostProcessBlendWeight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetOrthoWidth
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InOrthoWidth                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetOrthoWidth(float InOrthoWidth) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf615bbcf);

		UCameraComponent_SetOrthoWidth_Params params;
		params.InOrthoWidth = InOrthoWidth;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetOrthoNearClipPlane
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InOrthoNearClipPlane           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetOrthoNearClipPlane(float InOrthoNearClipPlane) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x383f2359);

		UCameraComponent_SetOrthoNearClipPlane_Params params;
		params.InOrthoNearClipPlane = InOrthoNearClipPlane;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetOrthoFarClipPlane
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InOrthoFarClipPlane            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetOrthoFarClipPlane(float InOrthoFarClipPlane) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x27a38ce0);

		UCameraComponent_SetOrthoFarClipPlane_Params params;
		params.InOrthoFarClipPlane = InOrthoFarClipPlane;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetFieldOfView
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InFieldOfView                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetFieldOfView(float InFieldOfView) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c3ef293);

		UCameraComponent_SetFieldOfView_Params params;
		params.InFieldOfView = InFieldOfView;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetConstraintAspectRatio
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInConstrainAspectRatio        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetConstraintAspectRatio(bool bInConstrainAspectRatio) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e901419);

		UCameraComponent_SetConstraintAspectRatio_Params params;
		params.bInConstrainAspectRatio = bInConstrainAspectRatio;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.SetAspectRatio
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InAspectRatio                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::SetAspectRatio(float InAspectRatio) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xea4ebd1e);

		UCameraComponent_SetAspectRatio_Params params;
		params.InAspectRatio = InAspectRatio;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraComponent.GetCameraView
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FMinimalViewInfo        DesiredView                    (CPF_Parm, CPF_OutParm)

	void UCameraComponent::GetCameraView(float DeltaTime, struct FMinimalViewInfo* DesiredView) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd38dbc5b);

		UCameraComponent_GetCameraView_Params params;
		params.DeltaTime = DeltaTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (DesiredView != nullptr)
			*DesiredView = params.DesiredView;
	}


	// Function Engine.CameraComponent.AddOrUpdateBlendable
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TScriptInterface<class UBlendableInterface> InBlendableObject              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InWeight                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraComponent::AddOrUpdateBlendable(const TScriptInterface<class UBlendableInterface>& InBlendableObject, float InWeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7465b1dd);

		UCameraComponent_AddOrUpdateBlendable_Params params;
		params.InBlendableObject = InBlendableObject;
		params.InWeight = InWeight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.Walk
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCheatManager::Walk() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf190baa);

		UCheatManager_Walk_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ViewSelf
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::ViewSelf() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe433c870);

		UCheatManager_ViewSelf_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ViewPlayer
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 S                              (CPF_Parm, CPF_ZeroConstructor)

	void UCheatManager::ViewPlayer(const struct FString& S) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3eae011d);

		UCheatManager_ViewPlayer_Params params;
		params.S = S;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ViewClass
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// class UClass*                  DesiredClass                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::ViewClass(class UClass* DesiredClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x199e3e12);

		UCheatManager_ViewClass_Params params;
		params.DesiredClass = DesiredClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ViewActor
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   ActorName                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::ViewActor(const struct FName& ActorName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x475a8d5d);

		UCheatManager_ViewActor_Params params;
		params.ActorName = ActorName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ToggleDebugCamera
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::ToggleDebugCamera() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5a48118f);

		UCheatManager_ToggleDebugCamera_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ToggleAILogging
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::ToggleAILogging() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24b81c06);

		UCheatManager_ToggleAILogging_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.TestCollisionDistance
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::TestCollisionDistance() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x97be1f92);

		UCheatManager_TestCollisionDistance_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.Teleport
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCheatManager::Teleport() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb1aa8834);

		UCheatManager_Teleport_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.Summon
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 ClassName                      (CPF_Parm, CPF_ZeroConstructor)

	void UCheatManager::Summon(const struct FString& ClassName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5da7cf04);

		UCheatManager_Summon_Params params;
		params.ClassName = ClassName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.StreamLevelOut
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   PackageName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::StreamLevelOut(const struct FName& PackageName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x83dded67);

		UCheatManager_StreamLevelOut_Params params;
		params.PackageName = PackageName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.StreamLevelIn
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   PackageName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::StreamLevelIn(const struct FName& PackageName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x14e7eb08);

		UCheatManager_StreamLevelIn_Params params;
		params.PackageName = PackageName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.Slomo
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewTimeDilation                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::Slomo(float NewTimeDilation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb09ab1a3);

		UCheatManager_Slomo_Params params;
		params.NewTimeDilation = NewTimeDilation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.SetWorldOrigin
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::SetWorldOrigin() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd0fa1f2b);

		UCheatManager_SetWorldOrigin_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.SetNavDrawDistance
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// float                          DrawDistance                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::SetNavDrawDistance(float DrawDistance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x693e5fd1);

		UCheatManager_SetNavDrawDistance_Params params;
		params.DrawDistance = DrawDistance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.SetMouseSensitivityToDefault
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::SetMouseSensitivityToDefault() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbe68edb1);

		UCheatManager_SetMouseSensitivityToDefault_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ServerToggleAILogging
	// (FUNC_Net, FUNC_NetReliable, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_NetServer, FUNC_NetValidate)

	void UCheatManager::ServerToggleAILogging() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x32b6e231);

		UCheatManager_ServerToggleAILogging_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ReceiveInitCheatManager
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void UCheatManager::ReceiveInitCheatManager() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc528c98);

		UCheatManager_ReceiveInitCheatManager_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ReceiveEndPlay
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void UCheatManager::ReceiveEndPlay() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c05aca9);

		UCheatManager_ReceiveEndPlay_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.RebuildNavigation
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::RebuildNavigation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa4f85500);

		UCheatManager_RebuildNavigation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.PlayersOnly
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCheatManager::PlayersOnly() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ac1c277);

		UCheatManager_PlayersOnly_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.OnlyLoadLevel
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   PackageName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::OnlyLoadLevel(const struct FName& PackageName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x185ea52b);

		UCheatManager_OnlyLoadLevel_Params params;
		params.PackageName = PackageName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.LogLoc
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::LogLoc() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5577407d);

		UCheatManager_LogLoc_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.InvertMouse
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::InvertMouse() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5875be2);

		UCheatManager_InvertMouse_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.God
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCheatManager::God() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1fe5d2e5);

		UCheatManager_God_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.Ghost
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCheatManager::Ghost() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x51876efa);

		UCheatManager_Ghost_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.FreezeFrame
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Delay                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::FreezeFrame(float Delay) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfe3ef593);

		UCheatManager_FreezeFrame_Params params;
		params.Delay = Delay;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.Fly
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCheatManager::Fly() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26a29bd0);

		UCheatManager_Fly_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.FlushLog
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::FlushLog() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ef0e6b5);

		UCheatManager_FlushLog_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.EnableDebugCamera
	// (FUNC_Native, FUNC_Protected, FUNC_BlueprintCallable)

	void UCheatManager::EnableDebugCamera() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f673d64);

		UCheatManager_EnableDebugCamera_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DumpVoiceMutingState
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DumpVoiceMutingState() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xad61cfdc);

		UCheatManager_DumpVoiceMutingState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DumpPartyState
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DumpPartyState() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef769578);

		UCheatManager_DumpPartyState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DumpOnlineSessionState
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DumpOnlineSessionState() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xce55e0d9);

		UCheatManager_DumpOnlineSessionState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DumpChatState
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DumpChatState() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8149e9d4);

		UCheatManager_DumpChatState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DisableDebugCamera
	// (FUNC_Native, FUNC_Protected, FUNC_BlueprintCallable)

	void UCheatManager::DisableDebugCamera() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x962048b5);

		UCheatManager_DisableDebugCamera_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DestroyTarget
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCheatManager::DestroyTarget() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x664c321a);

		UCheatManager_DestroyTarget_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DestroyPawns
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// class UClass*                  aClass                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::DestroyPawns(class UClass* aClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9ca201d2);

		UCheatManager_DestroyPawns_Params params;
		params.aClass = aClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DestroyAllPawnsExceptTarget
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DestroyAllPawnsExceptTarget() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeed51cfb);

		UCheatManager_DestroyAllPawnsExceptTarget_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DestroyAll
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// class UClass*                  aClass                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::DestroyAll(class UClass* aClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x704d95fa);

		UCheatManager_DestroyAll_Params params;
		params.aClass = aClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DebugCapsuleSweepSize
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::DebugCapsuleSweepSize(float HalfHeight, float Radius) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8ebd1d6);

		UCheatManager_DebugCapsuleSweepSize_Params params;
		params.HalfHeight = HalfHeight;
		params.Radius = Radius;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DebugCapsuleSweepPawn
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DebugCapsuleSweepPawn() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa6f155db);

		UCheatManager_DebugCapsuleSweepPawn_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DebugCapsuleSweepComplex
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::DebugCapsuleSweepComplex(bool bTraceComplex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x15902233);

		UCheatManager_DebugCapsuleSweepComplex_Params params;
		params.bTraceComplex = bTraceComplex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DebugCapsuleSweepClear
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DebugCapsuleSweepClear() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfeb0dcd4);

		UCheatManager_DebugCapsuleSweepClear_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DebugCapsuleSweepChannel
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// TEnumAsByte<ECollisionChannel> Channel                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::DebugCapsuleSweepChannel(TEnumAsByte<ECollisionChannel> Channel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xda0908ce);

		UCheatManager_DebugCapsuleSweepChannel_Params params;
		params.Channel = Channel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DebugCapsuleSweepCapture
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DebugCapsuleSweepCapture() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa14d6931);

		UCheatManager_DebugCapsuleSweepCapture_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DebugCapsuleSweep
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UCheatManager::DebugCapsuleSweep() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6f84c189);

		UCheatManager_DebugCapsuleSweep_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.DamageTarget
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          DamageAmount                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::DamageTarget(float DamageAmount) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb064bae9);

		UCheatManager_DamageTarget_Params params;
		params.DamageAmount = DamageAmount;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.CheatScript
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 ScriptName                     (CPF_Parm, CPF_ZeroConstructor)

	void UCheatManager::CheatScript(const struct FString& ScriptName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x94cfa17b);

		UCheatManager_CheatScript_Params params;
		params.ScriptName = ScriptName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.ChangeSize
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          F                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::ChangeSize(float F) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8e43f87a);

		UCheatManager_ChangeSize_Params params;
		params.F = F;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.BugItStringCreator
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults)
	// Parameters:
	// struct FVector                 ViewLocation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ViewRotation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 GoString                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// struct FString                 LocString                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UCheatManager::BugItStringCreator(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, struct FString* GoString, struct FString* LocString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcd0fb13);

		UCheatManager_BugItStringCreator_Params params;
		params.ViewLocation = ViewLocation;
		params.ViewRotation = ViewRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (GoString != nullptr)
			*GoString = params.GoString;
		if (LocString != nullptr)
			*LocString = params.LocString;
	}


	// Function Engine.CheatManager.BugItGo
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// float                          X                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Y                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Z                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Pitch                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Yaw                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Roll                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCheatManager::BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd9f7bb40);

		UCheatManager_BugItGo_Params params;
		params.X = X;
		params.Y = Y;
		params.Z = Z;
		params.Pitch = Pitch;
		params.Yaw = Yaw;
		params.Roll = Roll;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CheatManager.BugIt
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 ScreenShotDescription          (CPF_Parm, CPF_ZeroConstructor)

	void UCheatManager::BugIt(const struct FString& ScreenShotDescription) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e18fb6);

		UCheatManager_BugIt_Params params;
		params.ScreenShotDescription = ScreenShotDescription;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameViewportClient.SSSwapControllers
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UGameViewportClient::SSSwapControllers() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x50382692);

		UGameViewportClient_SSSwapControllers_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameViewportClient.ShowTitleSafeArea
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void UGameViewportClient::ShowTitleSafeArea() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb1a5aef);

		UGameViewportClient_ShowTitleSafeArea_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameViewportClient.SetConsoleTarget
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// int                            PlayerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameViewportClient::SetConsoleTarget(int PlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe9f733b8);

		UGameViewportClient_SetConsoleTarget_Params params;
		params.PlayerIndex = PlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkinnedMeshComponent.UnHideBoneByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkinnedMeshComponent::UnHideBoneByName(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd0b06156);

		USkinnedMeshComponent_UnHideBoneByName_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkinnedMeshComponent.TransformToBoneSpace
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InPosition                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                InRotation                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutPosition                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                OutRotation                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkinnedMeshComponent::TransformToBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe3e69d12);

		USkinnedMeshComponent_TransformToBoneSpace_Params params;
		params.BoneName = BoneName;
		params.InPosition = InPosition;
		params.InRotation = InRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutPosition != nullptr)
			*OutPosition = params.OutPosition;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}


	// Function Engine.SkinnedMeshComponent.TransformFromBoneSpace
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InPosition                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                InRotation                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutPosition                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                OutRotation                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkinnedMeshComponent::TransformFromBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa1ddd047);

		USkinnedMeshComponent_TransformFromBoneSpace_Params params;
		params.BoneName = BoneName;
		params.InPosition = InPosition;
		params.InRotation = InRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutPosition != nullptr)
			*OutPosition = params.OutPosition;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}


	// Function Engine.SkinnedMeshComponent.SetSkeletalMesh
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USkeletalMesh*           NewMesh                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bReinitPose                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkinnedMeshComponent::SetSkeletalMesh(class USkeletalMesh* NewMesh, bool bReinitPose) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcbc7e66b);

		USkinnedMeshComponent_SetSkeletalMesh_Params params;
		params.NewMesh = NewMesh;
		params.bReinitPose = bReinitPose;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkinnedMeshComponent.SetPhysicsAsset
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UPhysicsAsset*           NewPhysicsAsset                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bForceReInit                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkinnedMeshComponent::SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf5a398);

		USkinnedMeshComponent_SetPhysicsAsset_Params params;
		params.NewPhysicsAsset = NewPhysicsAsset;
		params.bForceReInit = bForceReInit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkinnedMeshComponent.SetMinLOD
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            InNewMinLOD                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkinnedMeshComponent::SetMinLOD(int InNewMinLOD) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x48918908);

		USkinnedMeshComponent_SetMinLOD_Params params;
		params.InNewMinLOD = InNewMinLOD;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkinnedMeshComponent.SetMasterPoseComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USkinnedMeshComponent*   NewMasterBoneComponent         (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void USkinnedMeshComponent::SetMasterPoseComponent(class USkinnedMeshComponent* NewMasterBoneComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfd7392fd);

		USkinnedMeshComponent_SetMasterPoseComponent_Params params;
		params.NewMasterBoneComponent = NewMasterBoneComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkinnedMeshComponent.SetForcedLOD
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            InNewForcedLOD                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkinnedMeshComponent::SetForcedLOD(int InNewForcedLOD) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5c040e7);

		USkinnedMeshComponent_SetForcedLOD_Params params;
		params.InNewForcedLOD = InNewForcedLOD;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkinnedMeshComponent.IsBoneHiddenByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USkinnedMeshComponent::IsBoneHiddenByName(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x601fc273);

		USkinnedMeshComponent_IsBoneHiddenByName_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkinnedMeshComponent.HideBoneByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EPhysBodyOp>       PhysBodyOption                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkinnedMeshComponent::HideBoneByName(const struct FName& BoneName, TEnumAsByte<EPhysBodyOp> PhysBodyOption) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf26ed2bb);

		USkinnedMeshComponent_HideBoneByName_Params params;
		params.BoneName = BoneName;
		params.PhysBodyOption = PhysBodyOption;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkinnedMeshComponent.GetSocketBoneName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName USkinnedMeshComponent::GetSocketBoneName(const struct FName& InSocketName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1dbb33d1);

		USkinnedMeshComponent_GetSocketBoneName_Params params;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkinnedMeshComponent.GetParentBone
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName USkinnedMeshComponent::GetParentBone(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdb7dc097);

		USkinnedMeshComponent_GetParentBone_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkinnedMeshComponent.GetNumBones
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int USkinnedMeshComponent::GetNumBones() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x780e4fec);

		USkinnedMeshComponent_GetNumBones_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkinnedMeshComponent.GetBoneName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            BoneIndex                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName USkinnedMeshComponent::GetBoneName(int BoneIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc40b37ea);

		USkinnedMeshComponent_GetBoneName_Params params;
		params.BoneIndex = BoneIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkinnedMeshComponent.GetBoneIndex
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int USkinnedMeshComponent::GetBoneIndex(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c567d09);

		USkinnedMeshComponent_GetBoneIndex_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkinnedMeshComponent.FindClosestBone_K2
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 TestLocation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoneLocation                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          IgnoreScale                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bRequirePhysicsAsset           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName USkinnedMeshComponent::FindClosestBone_K2(const struct FVector& TestLocation, float IgnoreScale, bool bRequirePhysicsAsset, struct FVector* BoneLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x42742e37);

		USkinnedMeshComponent_FindClosestBone_K2_Params params;
		params.TestLocation = TestLocation;
		params.IgnoreScale = IgnoreScale;
		params.bRequirePhysicsAsset = bRequirePhysicsAsset;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (BoneLocation != nullptr)
			*BoneLocation = params.BoneLocation;

		return params.ReturnValue;
	}


	// Function Engine.SkinnedMeshComponent.BoneIsChildOf
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ParentBoneName                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USkinnedMeshComponent::BoneIsChildOf(const struct FName& BoneName, const struct FName& ParentBoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4d912f6a);

		USkinnedMeshComponent_BoneIsChildOf_Params params;
		params.BoneName = BoneName;
		params.ParentBoneName = ParentBoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.DestructibleComponent.SetDestructibleMesh
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UDestructibleMesh*       NewMesh                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDestructibleComponent::SetDestructibleMesh(class UDestructibleMesh* NewMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2dfdd719);

		UDestructibleComponent_SetDestructibleMesh_Params params;
		params.NewMesh = NewMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DestructibleComponent.GetDestructibleMesh
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UDestructibleMesh*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UDestructibleMesh* UDestructibleComponent::GetDestructibleMesh() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2d489c0d);

		UDestructibleComponent_GetDestructibleMesh_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.DestructibleComponent.ApplyRadiusDamage
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// float                          BaseDamage                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HurtOrigin                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          DamageRadius                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ImpulseStrength                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFullDamage                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDestructibleComponent::ApplyRadiusDamage(float BaseDamage, const struct FVector& HurtOrigin, float DamageRadius, float ImpulseStrength, bool bFullDamage) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3a654d79);

		UDestructibleComponent_ApplyRadiusDamage_Params params;
		params.BaseDamage = BaseDamage;
		params.HurtOrigin = HurtOrigin;
		params.DamageRadius = DamageRadius;
		params.ImpulseStrength = ImpulseStrength;
		params.bFullDamage = bFullDamage;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DestructibleComponent.ApplyDamage
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// float                          DamageAmount                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitLocation                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 ImpulseDir                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          ImpulseStrength                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDestructibleComponent::ApplyDamage(float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfca45203);

		UDestructibleComponent_ApplyDamage_Params params;
		params.DamageAmount = DamageAmount;
		params.HitLocation = HitLocation;
		params.ImpulseDir = ImpulseDir;
		params.ImpulseStrength = ImpulseStrength;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.StartPlay
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AGameModeBase::StartPlay() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe5b6e1af);

		AGameModeBase_StartPlay_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.SpawnDefaultPawnFor
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  StartSpot                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APawn*                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APawn* AGameModeBase::SpawnDefaultPawnFor(class AController* NewPlayer, class AActor* StartSpot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x13721932);

		AGameModeBase_SpawnDefaultPawnFor_Params params;
		params.NewPlayer = NewPlayer;
		params.StartSpot = StartSpot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.SpawnDefaultPawnAtTransform
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              SpawnTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class APawn*                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APawn* AGameModeBase::SpawnDefaultPawnAtTransform(class AController* NewPlayer, const struct FTransform& SpawnTransform) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5e58e6ca);

		AGameModeBase_SpawnDefaultPawnAtTransform_Params params;
		params.NewPlayer = NewPlayer;
		params.SpawnTransform = SpawnTransform;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.ShouldReset
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AActor*                  ActorToReset                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameModeBase::ShouldReset(class AActor* ActorToReset) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1a30687f);

		AGameModeBase_ShouldReset_Params params;
		params.ActorToReset = ActorToReset;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.ReturnToMainMenuHost
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AGameModeBase::ReturnToMainMenuHost() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x57ec53fa);

		AGameModeBase_ReturnToMainMenuHost_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.RestartPlayerAtTransform
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class AController*             NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              SpawnTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void AGameModeBase::RestartPlayerAtTransform(class AController* NewPlayer, const struct FTransform& SpawnTransform) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x680cd510);

		AGameModeBase_RestartPlayerAtTransform_Params params;
		params.NewPlayer = NewPlayer;
		params.SpawnTransform = SpawnTransform;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.RestartPlayerAtPlayerStart
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AController*             NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  StartSpot                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::RestartPlayerAtPlayerStart(class AController* NewPlayer, class AActor* StartSpot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf60027c1);

		AGameModeBase_RestartPlayerAtPlayerStart_Params params;
		params.NewPlayer = NewPlayer;
		params.StartSpot = StartSpot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.RestartPlayer
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AController*             NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::RestartPlayer(class AController* NewPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd379e64b);

		AGameModeBase_RestartPlayer_Params params;
		params.NewPlayer = NewPlayer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.ResetLevel
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AGameModeBase::ResetLevel() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ea91f7a);

		AGameModeBase_ResetLevel_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.PlayerCanRestart
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameModeBase::PlayerCanRestart(class APlayerController* Player) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd002f347);

		AGameModeBase_PlayerCanRestart_Params params;
		params.Player = Player;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.MustSpectate
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// class APlayerController*       NewPlayerController            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameModeBase::MustSpectate(class APlayerController* NewPlayerController) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x979d659d);

		AGameModeBase_MustSpectate_Params params;
		params.NewPlayerController = NewPlayerController;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.K2_PostLogin
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::K2_PostLogin(class APlayerController* NewPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6a4681ac);

		AGameModeBase_K2_PostLogin_Params params;
		params.NewPlayer = NewPlayer;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.K2_OnSwapPlayerControllers
	// (FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       OldPC                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APlayerController*       NewPC                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::K2_OnSwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x573fec99);

		AGameModeBase_K2_OnSwapPlayerControllers_Params params;
		params.OldPC = OldPC;
		params.NewPC = NewPC;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.K2_OnRestartPlayer
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::K2_OnRestartPlayer(class AController* NewPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5dc651d6);

		AGameModeBase_K2_OnRestartPlayer_Params params;
		params.NewPlayer = NewPlayer;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.K2_OnLogout
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             ExitingController              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::K2_OnLogout(class AController* ExitingController) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x690e582a);

		AGameModeBase_K2_OnLogout_Params params;
		params.ExitingController = ExitingController;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.K2_OnChangeName
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             Other                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 NewName                        (CPF_Parm, CPF_ZeroConstructor)
	// bool                           bNameChange                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::K2_OnChangeName(class AController* Other, const struct FString& NewName, bool bNameChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa1111019);

		AGameModeBase_K2_OnChangeName_Params params;
		params.Other = Other;
		params.NewName = NewName;
		params.bNameChange = bNameChange;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.K2_FindPlayerStart
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class AController*             Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 IncomingName                   (CPF_Parm, CPF_ZeroConstructor)
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* AGameModeBase::K2_FindPlayerStart(class AController* Player, const struct FString& IncomingName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe5ce7dcb);

		AGameModeBase_K2_FindPlayerStart_Params params;
		params.Player = Player;
		params.IncomingName = IncomingName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.InitStartSpot
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AActor*                  StartSpot                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AController*             NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::InitStartSpot(class AActor* StartSpot, class AController* NewPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54f2b2e3);

		AGameModeBase_InitStartSpot_Params params;
		params.StartSpot = StartSpot;
		params.NewPlayer = NewPlayer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.InitializeHUDForPlayer
	// (FUNC_Native, FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::InitializeHUDForPlayer(class APlayerController* NewPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xabd00ac2);

		AGameModeBase_InitializeHUDForPlayer_Params params;
		params.NewPlayer = NewPlayer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.HasMatchStarted
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameModeBase::HasMatchStarted() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcdbd4463);

		AGameModeBase_HasMatchStarted_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.HandleStartingNewPlayer
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       NewPlayer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::HandleStartingNewPlayer(class APlayerController* NewPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x55fc7112);

		AGameModeBase_HandleStartingNewPlayer_Params params;
		params.NewPlayer = NewPlayer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.GetNumSpectators
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int AGameModeBase::GetNumSpectators() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6acbc599);

		AGameModeBase_GetNumSpectators_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.GetNumPlayers
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int AGameModeBase::GetNumPlayers() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb64e0b83);

		AGameModeBase_GetNumPlayers_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.GetDefaultPawnClassForController
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             InController                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UClass* AGameModeBase::GetDefaultPawnClassForController(class AController* InController) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54379b13);

		AGameModeBase_GetDefaultPawnClassForController_Params params;
		params.InController = InController;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.FindPlayerStart
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 IncomingName                   (CPF_Parm, CPF_ZeroConstructor)
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* AGameModeBase::FindPlayerStart(class AController* Player, const struct FString& IncomingName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6c12366b);

		AGameModeBase_FindPlayerStart_Params params;
		params.Player = Player;
		params.IncomingName = IncomingName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.ChoosePlayerStart
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class AController*             Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* AGameModeBase::ChoosePlayerStart(class AController* Player) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4872fc85);

		AGameModeBase_ChoosePlayerStart_Params params;
		params.Player = Player;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameModeBase.ChangeName
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AController*             Controller                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 NewName                        (CPF_Parm, CPF_ZeroConstructor)
	// bool                           bNameChange                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameModeBase::ChangeName(class AController* Controller, const struct FString& NewName, bool bNameChange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5826002);

		AGameModeBase_ChangeName_Params params;
		params.Controller = Controller;
		params.NewName = NewName;
		params.bNameChange = bNameChange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameModeBase.CanSpectate
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       Viewer                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APlayerState*            ViewTarget                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameModeBase::CanSpectate(class APlayerController* Viewer, class APlayerState* ViewTarget) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xca3c7a76);

		AGameModeBase_CanSpectate_Params params;
		params.Viewer = Viewer;
		params.ViewTarget = ViewTarget;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameMode.StartMatch
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AGameMode::StartMatch() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa4b57f75);

		AGameMode_StartMatch_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameMode.SetBandwidthLimit
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// float                          AsyncIOBandwidthLimit          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameMode::SetBandwidthLimit(float AsyncIOBandwidthLimit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc7b551e6);

		AGameMode_SetBandwidthLimit_Params params;
		params.AsyncIOBandwidthLimit = AsyncIOBandwidthLimit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameMode.Say
	// (FUNC_Exec, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 Msg                            (CPF_Parm, CPF_ZeroConstructor)

	void AGameMode::Say(const struct FString& Msg) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x247c87e3);

		AGameMode_Say_Params params;
		params.Msg = Msg;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameMode.RestartGame
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AGameMode::RestartGame() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x157bf021);

		AGameMode_RestartGame_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameMode.ReadyToStartMatch
	// (FUNC_Native, FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameMode::ReadyToStartMatch() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x13a2b5c3);

		AGameMode_ReadyToStartMatch_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameMode.ReadyToEndMatch
	// (FUNC_Native, FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameMode::ReadyToEndMatch() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8a68d4fe);

		AGameMode_ReadyToEndMatch_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameMode.K2_OnSetMatchState
	// (FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent)
	// Parameters:
	// struct FName                   NewState                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AGameMode::K2_OnSetMatchState(const struct FName& NewState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xed7aaaef);

		AGameMode_K2_OnSetMatchState_Params params;
		params.NewState = NewState;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameMode.IsMatchInProgress
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameMode::IsMatchInProgress() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x93a90b89);

		AGameMode_IsMatchInProgress_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameMode.HasMatchEnded
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameMode::HasMatchEnded() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6466c9df);

		AGameMode_HasMatchEnded_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameMode.GetMatchState
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName AGameMode::GetMatchState() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc29fdea4);

		AGameMode_GetMatchState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameMode.EndMatch
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AGameMode::EndMatch() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9a79fa84);

		AGameMode_EndMatch_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameMode.AbortMatch
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AGameMode::AbortMatch() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1a598acb);

		AGameMode_AbortMatch_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameInstance.ReceiveShutdown
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void UGameInstance::ReceiveShutdown() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8466e417);

		UGameInstance_ReceiveShutdown_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameInstance.ReceiveInit
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void UGameInstance::ReceiveInit() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb589a093);

		UGameInstance_ReceiveInit_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameInstance.HandleTravelError
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<ETravelFailure>    FailureType                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameInstance::HandleTravelError(TEnumAsByte<ETravelFailure> FailureType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdc8dfd2);

		UGameInstance_HandleTravelError_Params params;
		params.FailureType = FailureType;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameInstance.HandleNetworkError
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// TEnumAsByte<ENetworkFailure>   FailureType                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIsServer                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameInstance::HandleNetworkError(TEnumAsByte<ENetworkFailure> FailureType, bool bIsServer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1b92de9c);

		UGameInstance_HandleNetworkError_Params params;
		params.FailureType = FailureType;
		params.bIsServer = bIsServer;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameInstance.DebugRemovePlayer
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// int                            ControllerId                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameInstance::DebugRemovePlayer(int ControllerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x20083ce8);

		UGameInstance_DebugRemovePlayer_Params params;
		params.ControllerId = ControllerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameInstance.DebugCreatePlayer
	// (FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// int                            ControllerId                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameInstance::DebugCreatePlayer(int ControllerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcbfce948);

		UGameInstance_DebugCreatePlayer_Params params;
		params.ControllerId = ControllerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintFunctionLibrary.MakeStringAssetReference
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AssetLongPathname              (CPF_Parm, CPF_ZeroConstructor)
	// struct FStringAssetReference   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FStringAssetReference UBlueprintFunctionLibrary::STATIC_MakeStringAssetReference(const struct FString& AssetLongPathname) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4114fb8b);

		UBlueprintFunctionLibrary_MakeStringAssetReference_Params params;
		params.AssetLongPathname = AssetLongPathname;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameStateBase.OnRep_SpectatorClass
	// (FUNC_Native, FUNC_Protected)

	void AGameStateBase::OnRep_SpectatorClass() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe7872701);

		AGameStateBase_OnRep_SpectatorClass_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameStateBase.OnRep_ReplicatedWorldTimeSeconds
	// (FUNC_Native, FUNC_Protected)

	void AGameStateBase::OnRep_ReplicatedWorldTimeSeconds() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x704aa375);

		AGameStateBase_OnRep_ReplicatedWorldTimeSeconds_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameStateBase.OnRep_ReplicatedHasBegunPlay
	// (FUNC_Native, FUNC_Protected)

	void AGameStateBase::OnRep_ReplicatedHasBegunPlay() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5aeabafe);

		AGameStateBase_OnRep_ReplicatedHasBegunPlay_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameStateBase.OnRep_GameModeClass
	// (FUNC_Native, FUNC_Protected)

	void AGameStateBase::OnRep_GameModeClass() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5fe1785);

		AGameStateBase_OnRep_GameModeClass_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameStateBase.HasMatchStarted
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameStateBase::HasMatchStarted() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfa38f12b);

		AGameStateBase_HasMatchStarted_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameStateBase.HasBegunPlay
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AGameStateBase::HasBegunPlay() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9216c186);

		AGameStateBase_HasBegunPlay_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameStateBase.GetServerWorldTimeSeconds
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AGameStateBase::GetServerWorldTimeSeconds() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x32a3870a);

		AGameStateBase_GetServerWorldTimeSeconds_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameStateBase.GetPlayerStartTime
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AController*             Controller                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AGameStateBase::GetPlayerStartTime(class AController* Controller) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf7f415cd);

		AGameStateBase_GetPlayerStartTime_Params params;
		params.Controller = Controller;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameStateBase.GetPlayerRespawnDelay
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AController*             Controller                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float AGameStateBase::GetPlayerRespawnDelay(class AController* Controller) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc36ffc3);

		AGameStateBase_GetPlayerRespawnDelay_Params params;
		params.Controller = Controller;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameState.OnRep_MatchState
	// (FUNC_Native, FUNC_Public)

	void AGameState::OnRep_MatchState() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf6545ff);

		AGameState_OnRep_MatchState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameState.OnRep_ElapsedTime
	// (FUNC_Native, FUNC_Public)

	void AGameState::OnRep_ElapsedTime() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xedda8134);

		AGameState_OnRep_ElapsedTime_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.ValidateSettings
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::ValidateSettings() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x641fd4a6);

		UGameUserSettings_ValidateSettings_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetVSyncEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetVSyncEnabled(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7a32e7ef);

		UGameUserSettings_SetVSyncEnabled_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetVisualEffectQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetVisualEffectQuality(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfc3b8df1);

		UGameUserSettings_SetVisualEffectQuality_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetViewDistanceQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetViewDistanceQuality(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf833e90e);

		UGameUserSettings_SetViewDistanceQuality_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetToDefaults
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::SetToDefaults() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2553ffcc);

		UGameUserSettings_SetToDefaults_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetTextureQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetTextureQuality(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85fe9199);

		UGameUserSettings_SetTextureQuality_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetShadowQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetShadowQuality(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2b4b89c);

		UGameUserSettings_SetShadowQuality_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetScreenResolution
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FIntPoint               Resolution                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetScreenResolution(const struct FIntPoint& Resolution) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf4e39dd3);

		UGameUserSettings_SetScreenResolution_Params params;
		params.Resolution = Resolution;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetResolutionScaleValueEx
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewScaleValue                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetResolutionScaleValueEx(float NewScaleValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24302a1);

		UGameUserSettings_SetResolutionScaleValueEx_Params params;
		params.NewScaleValue = NewScaleValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetResolutionScaleValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            NewScaleValue                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetResolutionScaleValue(int NewScaleValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4e33787a);

		UGameUserSettings_SetResolutionScaleValue_Params params;
		params.NewScaleValue = NewScaleValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetResolutionScaleNormalized
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewScaleNormalized             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetResolutionScaleNormalized(float NewScaleNormalized) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbcff58cc);

		UGameUserSettings_SetResolutionScaleNormalized_Params params;
		params.NewScaleNormalized = NewScaleNormalized;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetPostProcessingQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetPostProcessingQuality(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4526e685);

		UGameUserSettings_SetPostProcessingQuality_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetOverallScalabilityLevel
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetOverallScalabilityLevel(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc15e0c01);

		UGameUserSettings_SetOverallScalabilityLevel_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetFullscreenMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EWindowMode>       InFullscreenMode               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetFullscreenMode(TEnumAsByte<EWindowMode> InFullscreenMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc05be93f);

		UGameUserSettings_SetFullscreenMode_Params params;
		params.InFullscreenMode = InFullscreenMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetFrameRateLimit
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewLimit                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetFrameRateLimit(float NewLimit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2239ddf7);

		UGameUserSettings_SetFrameRateLimit_Params params;
		params.NewLimit = NewLimit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetFoliageQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetFoliageQuality(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2503c02d);

		UGameUserSettings_SetFoliageQuality_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetBenchmarkFallbackValues
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::SetBenchmarkFallbackValues() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb34507c6);

		UGameUserSettings_SetBenchmarkFallbackValues_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetAudioQualityLevel
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            QualityLevel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetAudioQualityLevel(int QualityLevel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1c88635a);

		UGameUserSettings_SetAudioQualityLevel_Params params;
		params.QualityLevel = QualityLevel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SetAntiAliasingQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::SetAntiAliasingQuality(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79928060);

		UGameUserSettings_SetAntiAliasingQuality_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.SaveSettings
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::SaveSettings() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x21896a5b);

		UGameUserSettings_SaveSettings_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.RunHardwareBenchmark
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            WorkScale                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CPUMultiplier                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          GPUMultiplier                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::RunHardwareBenchmark(int WorkScale, float CPUMultiplier, float GPUMultiplier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe4da4263);

		UGameUserSettings_RunHardwareBenchmark_Params params;
		params.WorkScale = WorkScale;
		params.CPUMultiplier = CPUMultiplier;
		params.GPUMultiplier = GPUMultiplier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.RevertVideoMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::RevertVideoMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4ace9d5b);

		UGameUserSettings_RevertVideoMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.ResetToCurrentSettings
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::ResetToCurrentSettings() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbcfaba6d);

		UGameUserSettings_ResetToCurrentSettings_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.LoadSettings
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bForceReload                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::LoadSettings(bool bForceReload) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3ba29ec0);

		UGameUserSettings_LoadSettings_Params params;
		params.bForceReload = bForceReload;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.IsVSyncEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameUserSettings::IsVSyncEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x654400f5);

		UGameUserSettings_IsVSyncEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.IsVSyncDirty
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameUserSettings::IsVSyncDirty() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x91d8ef46);

		UGameUserSettings_IsVSyncDirty_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.IsScreenResolutionDirty
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameUserSettings::IsScreenResolutionDirty() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x19e5736f);

		UGameUserSettings_IsScreenResolutionDirty_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.IsFullscreenModeDirty
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameUserSettings::IsFullscreenModeDirty() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2fed198f);

		UGameUserSettings_IsFullscreenModeDirty_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.IsDirty
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameUserSettings::IsDirty() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85d6246d);

		UGameUserSettings_IsDirty_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetVisualEffectQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetVisualEffectQuality() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfc2d38b5);

		UGameUserSettings_GetVisualEffectQuality_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetViewDistanceQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetViewDistanceQuality() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb4efada);

		UGameUserSettings_GetViewDistanceQuality_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetTextureQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetTextureQuality() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6553ad5d);

		UGameUserSettings_GetTextureQuality_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetShadowQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetShadowQuality() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3d9925e8);

		UGameUserSettings_GetShadowQuality_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetScreenResolution
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FIntPoint               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FIntPoint UGameUserSettings::GetScreenResolution() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe974f8e7);

		UGameUserSettings_GetScreenResolution_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetResolutionScaleInformationEx
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          CurrentScaleNormalized         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CurrentScaleValue              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MinScaleValue                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxScaleValue                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::GetResolutionScaleInformationEx(float* CurrentScaleNormalized, float* CurrentScaleValue, float* MinScaleValue, float* MaxScaleValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8ead9a70);

		UGameUserSettings_GetResolutionScaleInformationEx_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (CurrentScaleNormalized != nullptr)
			*CurrentScaleNormalized = params.CurrentScaleNormalized;
		if (CurrentScaleValue != nullptr)
			*CurrentScaleValue = params.CurrentScaleValue;
		if (MinScaleValue != nullptr)
			*MinScaleValue = params.MinScaleValue;
		if (MaxScaleValue != nullptr)
			*MaxScaleValue = params.MaxScaleValue;
	}


	// Function Engine.GameUserSettings.GetResolutionScaleInformation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          CurrentScaleNormalized         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            CurrentScaleValue              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinScaleValue                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaxScaleValue                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::GetResolutionScaleInformation(float* CurrentScaleNormalized, int* CurrentScaleValue, int* MinScaleValue, int* MaxScaleValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc8b8bba7);

		UGameUserSettings_GetResolutionScaleInformation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (CurrentScaleNormalized != nullptr)
			*CurrentScaleNormalized = params.CurrentScaleNormalized;
		if (CurrentScaleValue != nullptr)
			*CurrentScaleValue = params.CurrentScaleValue;
		if (MinScaleValue != nullptr)
			*MinScaleValue = params.MinScaleValue;
		if (MaxScaleValue != nullptr)
			*MaxScaleValue = params.MaxScaleValue;
	}


	// Function Engine.GameUserSettings.GetPreferredFullscreenMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<EWindowMode>       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<EWindowMode> UGameUserSettings::GetPreferredFullscreenMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x582b8f12);

		UGameUserSettings_GetPreferredFullscreenMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetPostProcessingQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetPostProcessingQuality() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbd2d7989);

		UGameUserSettings_GetPostProcessingQuality_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetOverallScalabilityLevel
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetOverallScalabilityLevel() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x14115a85);

		UGameUserSettings_GetOverallScalabilityLevel_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetLastConfirmedScreenResolution
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FIntPoint               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FIntPoint UGameUserSettings::GetLastConfirmedScreenResolution() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7c43e81e);

		UGameUserSettings_GetLastConfirmedScreenResolution_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetLastConfirmedFullscreenMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<EWindowMode>       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<EWindowMode> UGameUserSettings::GetLastConfirmedFullscreenMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbe421f26);

		UGameUserSettings_GetLastConfirmedFullscreenMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetGameUserSettings
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UGameUserSettings*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UGameUserSettings* UGameUserSettings::STATIC_GetGameUserSettings() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x589bd0c1);

		UGameUserSettings_GetGameUserSettings_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetFullScreenMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<EWindowMode>       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<EWindowMode> UGameUserSettings::GetFullScreenMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf980745b);

		UGameUserSettings_GetFullScreenMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetFrameRateLimit
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UGameUserSettings::GetFrameRateLimit() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xde9077ab);

		UGameUserSettings_GetFrameRateLimit_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetFoliageQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetFoliageQuality() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x483345d1);

		UGameUserSettings_GetFoliageQuality_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetDesktopResolution
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FIntPoint               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FIntPoint UGameUserSettings::GetDesktopResolution() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdb382499);

		UGameUserSettings_GetDesktopResolution_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetDefaultWindowPosition
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FIntPoint               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FIntPoint UGameUserSettings::STATIC_GetDefaultWindowPosition() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2e3fd491);

		UGameUserSettings_GetDefaultWindowPosition_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetDefaultWindowMode
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EWindowMode>       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<EWindowMode> UGameUserSettings::STATIC_GetDefaultWindowMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfc260651);

		UGameUserSettings_GetDefaultWindowMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetDefaultResolutionScale
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UGameUserSettings::GetDefaultResolutionScale() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x36f071f4);

		UGameUserSettings_GetDefaultResolutionScale_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetDefaultResolution
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FIntPoint               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FIntPoint UGameUserSettings::STATIC_GetDefaultResolution() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1240ae1a);

		UGameUserSettings_GetDefaultResolution_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetAudioQualityLevel
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetAudioQualityLevel() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcfb0c96e);

		UGameUserSettings_GetAudioQualityLevel_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.GetAntiAliasingQuality
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameUserSettings::GetAntiAliasingQuality() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd7335fc);

		UGameUserSettings_GetAntiAliasingQuality_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameUserSettings.ConfirmVideoMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::ConfirmVideoMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc3c4112f);

		UGameUserSettings_ConfirmVideoMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.ApplySettings
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bCheckForCommandLineOverrides  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::ApplySettings(bool bCheckForCommandLineOverrides) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x29abf82e);

		UGameUserSettings_ApplySettings_Params params;
		params.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.ApplyResolutionSettings
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bCheckForCommandLineOverrides  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameUserSettings::ApplyResolutionSettings(bool bCheckForCommandLineOverrides) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x17d57ff8);

		UGameUserSettings_ApplyResolutionSettings_Params params;
		params.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.ApplyNonResolutionSettings
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::ApplyNonResolutionSettings() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd429505b);

		UGameUserSettings_ApplyNonResolutionSettings_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameUserSettings.ApplyHardwareBenchmarkResults
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UGameUserSettings::ApplyHardwareBenchmarkResults() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x81e71d5c);

		UGameUserSettings_ApplyHardwareBenchmarkResults_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            InstanceIndex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              NewInstanceTransform           (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bWorldSpace                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bMarkRenderStateDirty          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTeleport                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UInstancedStaticMeshComponent::UpdateInstanceTransform(int InstanceIndex, const struct FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x68003f58);

		UInstancedStaticMeshComponent_UpdateInstanceTransform_Params params;
		params.InstanceIndex = InstanceIndex;
		params.NewInstanceTransform = NewInstanceTransform;
		params.bWorldSpace = bWorldSpace;
		params.bMarkRenderStateDirty = bMarkRenderStateDirty;
		params.bTeleport = bTeleport;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InstancedStaticMeshComponent.UpdateInstanceCustomData
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            InstanceIndex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector4                NewInstanceData                (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bMarkRenderStateDirty          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UInstancedStaticMeshComponent::UpdateInstanceCustomData(int InstanceIndex, const struct FVector4& NewInstanceData, bool bMarkRenderStateDirty) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x119e56ad);

		UInstancedStaticMeshComponent_UpdateInstanceCustomData_Params params;
		params.InstanceIndex = InstanceIndex;
		params.NewInstanceData = NewInstanceData;
		params.bMarkRenderStateDirty = bMarkRenderStateDirty;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InstancedStaticMeshComponent.SetCullDistances
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            StartCullDistance              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            EndCullDistance                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInstancedStaticMeshComponent::SetCullDistances(int StartCullDistance, int EndCullDistance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xefcb279e);

		UInstancedStaticMeshComponent_SetCullDistances_Params params;
		params.StartCullDistance = StartCullDistance;
		params.EndCullDistance = EndCullDistance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.InstancedStaticMeshComponent.RemoveInstance
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            InstanceIndex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UInstancedStaticMeshComponent::RemoveInstance(int InstanceIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9a07ef7);

		UInstancedStaticMeshComponent_RemoveInstance_Params params;
		params.InstanceIndex = InstanceIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InstancedStaticMeshComponent.GetInstanceTransform
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            InstanceIndex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              OutInstanceTransform           (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bWorldSpace                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UInstancedStaticMeshComponent::GetInstanceTransform(int InstanceIndex, bool bWorldSpace, struct FTransform* OutInstanceTransform) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdd9ce819);

		UInstancedStaticMeshComponent_GetInstanceTransform_Params params;
		params.InstanceIndex = InstanceIndex;
		params.bWorldSpace = bWorldSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutInstanceTransform != nullptr)
			*OutInstanceTransform = params.OutInstanceTransform;

		return params.ReturnValue;
	}


	// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 Center                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSphereInWorldSpace            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<int>                    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<int> UInstancedStaticMeshComponent::GetInstancesOverlappingSphere(const struct FVector& Center, float Radius, bool bSphereInWorldSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa78c84f4);

		UInstancedStaticMeshComponent_GetInstancesOverlappingSphere_Params params;
		params.Center = Center;
		params.Radius = Radius;
		params.bSphereInWorldSpace = bSphereInWorldSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingBox
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FBox                    Box                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bBoxInWorldSpace               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<int>                    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<int> UInstancedStaticMeshComponent::GetInstancesOverlappingBox(const struct FBox& Box, bool bBoxInWorldSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf5f02222);

		UInstancedStaticMeshComponent_GetInstancesOverlappingBox_Params params;
		params.Box = Box;
		params.bBoxInWorldSpace = bBoxInWorldSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InstancedStaticMeshComponent.GetInstanceCount
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UInstancedStaticMeshComponent::GetInstanceCount() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5967a4c4);

		UInstancedStaticMeshComponent_GetInstanceCount_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InstancedStaticMeshComponent.ClearInstances
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UInstancedStaticMeshComponent::ClearInstances() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9994f9f);

		UInstancedStaticMeshComponent_ClearInstances_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              WorldTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UInstancedStaticMeshComponent::AddInstanceWorldSpace(const struct FTransform& WorldTransform) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb1f69ca8);

		UInstancedStaticMeshComponent_AddInstanceWorldSpace_Params params;
		params.WorldTransform = WorldTransform;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InstancedStaticMeshComponent.AddInstance
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTransform              InstanceTransform              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UInstancedStaticMeshComponent::AddInstance(const struct FTransform& InstanceTransform) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5274996);

		UInstancedStaticMeshComponent_AddInstance_Params params;
		params.InstanceTransform = InstanceTransform;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HierarchicalInstancedStaticMeshComponent.RemoveInstances
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    InstancesToRemove              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UHierarchicalInstancedStaticMeshComponent::RemoveInstances(TArray<int> InstancesToRemove) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c198ea5);

		UHierarchicalInstancedStaticMeshComponent_RemoveInstances_Params params;
		params.InstancesToRemove = InstancesToRemove;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.LevelScriptActor.WorldOriginLocationChanged
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// struct FIntVector              OldOriginLocation              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FIntVector              NewOriginLocation              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALevelScriptActor::WorldOriginLocationChanged(const struct FIntVector& OldOriginLocation, const struct FIntVector& NewOriginLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeac2558);

		ALevelScriptActor_WorldOriginLocationChanged_Params params;
		params.OldOriginLocation = OldOriginLocation;
		params.NewOriginLocation = NewOriginLocation;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LevelScriptActor.SetCinematicMode
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bCinematicMode                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bHidePlayer                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsHUD                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsMovement               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAffectsTurning                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALevelScriptActor::SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3a26adb);

		ALevelScriptActor_SetCinematicMode_Params params;
		params.bCinematicMode = bCinematicMode;
		params.bHidePlayer = bHidePlayer;
		params.bAffectsHUD = bAffectsHUD;
		params.bAffectsMovement = bAffectsMovement;
		params.bAffectsTurning = bAffectsTurning;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LevelScriptActor.RemoteEvent
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   EventName                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ALevelScriptActor::RemoteEvent(const struct FName& EventName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd0c1c849);

		ALevelScriptActor_RemoteEvent_Params params;
		params.EventName = EventName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.LevelScriptActor.LevelReset
	// (FUNC_BlueprintAuthorityOnly, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void ALevelScriptActor::LevelReset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeea93ec6);

		ALevelScriptActor_LevelReset_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.StopCameraShake
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UCameraShake*            ShakeInstance                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bImmediately                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::StopCameraShake(class UCameraShake* ShakeInstance, bool bImmediately) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3d82d3bd);

		APlayerCameraManager_StopCameraShake_Params params;
		params.ShakeInstance = ShakeInstance;
		params.bImmediately = bImmediately;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.StopCameraFade
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void APlayerCameraManager::StopCameraFade() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5769c947);

		APlayerCameraManager_StopCameraFade_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.StopCameraAnimInst
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UCameraAnimInst*         AnimInst                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bImmediate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::StopCameraAnimInst(class UCameraAnimInst* AnimInst, bool bImmediate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf6bf4666);

		APlayerCameraManager_StopCameraAnimInst_Params params;
		params.AnimInst = AnimInst;
		params.bImmediate = bImmediate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  Shake                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bImmediately                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::StopAllInstancesOfCameraShake(class UClass* Shake, bool bImmediately) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9dbc01b1);

		APlayerCameraManager_StopAllInstancesOfCameraShake_Params params;
		params.Shake = Shake;
		params.bImmediately = bImmediately;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UCameraAnim*             Anim                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bImmediate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::StopAllInstancesOfCameraAnim(class UCameraAnim* Anim, bool bImmediate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x71b25cc2);

		APlayerCameraManager_StopAllInstancesOfCameraAnim_Params params;
		params.Anim = Anim;
		params.bImmediate = bImmediate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.StopAllCameraShakes
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bImmediately                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::StopAllCameraShakes(bool bImmediately) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x13027f9d);

		APlayerCameraManager_StopAllCameraShakes_Params params;
		params.bImmediately = bImmediately;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.StopAllCameraAnims
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bImmediate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::StopAllCameraAnims(bool bImmediate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb4577466);

		APlayerCameraManager_StopAllCameraAnims_Params params;
		params.bImmediate = bImmediate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.StartCameraFade
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// float                          FromAlpha                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ToAlpha                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            Color                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShouldFadeAudio               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bHoldWhenFinished              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::StartCameraFade(float FromAlpha, float ToAlpha, float Duration, const struct FLinearColor& Color, bool bShouldFadeAudio, bool bHoldWhenFinished) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd80bf2f3);

		APlayerCameraManager_StartCameraFade_Params params;
		params.FromAlpha = FromAlpha;
		params.ToAlpha = ToAlpha;
		params.Duration = Duration;
		params.Color = Color;
		params.bShouldFadeAudio = bShouldFadeAudio;
		params.bHoldWhenFinished = bHoldWhenFinished;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.SetManualCameraFade
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InFadeAmount                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            Color                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bInFadeAudio                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::SetManualCameraFade(float InFadeAmount, const struct FLinearColor& Color, bool bInFadeAudio) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaa82cbb5);

		APlayerCameraManager_SetManualCameraFade_Params params;
		params.InFadeAmount = InFadeAmount;
		params.Color = Color;
		params.bInFadeAudio = bInFadeAudio;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.RemoveCameraModifier
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UCameraModifier*         ModifierToRemove               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerCameraManager::RemoveCameraModifier(class UCameraModifier* ModifierToRemove) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xff1d5ee);

		APlayerCameraManager_RemoveCameraModifier_Params params;
		params.ModifierToRemove = ModifierToRemove;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.RemoveCameraLensEffect
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AEmitterCameraLensEffectBase* Emitter                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x122153aa);

		APlayerCameraManager_RemoveCameraLensEffect_Params params;
		params.Emitter = Emitter;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.PlayCameraShake
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  ShakeClass                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECameraAnimPlaySpace> PlaySpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                UserPlaySpaceRot               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UCameraShake*            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UCameraShake* APlayerCameraManager::PlayCameraShake(class UClass* ShakeClass, float Scale, TEnumAsByte<ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe5e9a4cf);

		APlayerCameraManager_PlayCameraShake_Params params;
		params.ShakeClass = ShakeClass;
		params.Scale = Scale;
		params.PlaySpace = PlaySpace;
		params.UserPlaySpaceRot = UserPlaySpaceRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.PlayCameraAnim
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UCameraAnim*             Anim                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Rate                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendInTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendOutTime                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLoop                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bRandomStartTime               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECameraAnimPlaySpace> PlaySpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                UserPlaySpaceRot               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UCameraAnimInst*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UCameraAnimInst* APlayerCameraManager::PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, TEnumAsByte<ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x864f1290);

		APlayerCameraManager_PlayCameraAnim_Params params;
		params.Anim = Anim;
		params.Rate = Rate;
		params.Scale = Scale;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		params.bLoop = bLoop;
		params.bRandomStartTime = bRandomStartTime;
		params.Duration = Duration;
		params.PlaySpace = PlaySpace;
		params.UserPlaySpaceRot = UserPlaySpaceRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.PhotographyCameraModify
	// (FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// struct FVector                 NewCameraLocation              (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PreviousCameraLocation         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OriginalCameraLocation         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ResultCameraLocation           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerCameraManager::PhotographyCameraModify(const struct FVector& NewCameraLocation, const struct FVector& PreviousCameraLocation, const struct FVector& OriginalCameraLocation, struct FVector* ResultCameraLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x574ff332);

		APlayerCameraManager_PhotographyCameraModify_Params params;
		params.NewCameraLocation = NewCameraLocation;
		params.PreviousCameraLocation = PreviousCameraLocation;
		params.OriginalCameraLocation = OriginalCameraLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (ResultCameraLocation != nullptr)
			*ResultCameraLocation = params.ResultCameraLocation;
	}


	// Function Engine.PlayerCameraManager.OnPhotographySessionStart
	// (FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void APlayerCameraManager::OnPhotographySessionStart() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xae67fbd8);

		APlayerCameraManager_OnPhotographySessionStart_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.OnPhotographySessionEnd
	// (FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void APlayerCameraManager::OnPhotographySessionEnd() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2dd1677b);

		APlayerCameraManager_OnPhotographySessionEnd_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureStart
	// (FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void APlayerCameraManager::OnPhotographyMultiPartCaptureStart() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc776d89a);

		APlayerCameraManager_OnPhotographyMultiPartCaptureStart_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureEnd
	// (FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

	void APlayerCameraManager::OnPhotographyMultiPartCaptureEnd() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x46631611);

		APlayerCameraManager_OnPhotographyMultiPartCaptureEnd_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.GetOwningPlayerController
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class APlayerController*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APlayerController* APlayerCameraManager::GetOwningPlayerController() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x74fb1d03);

		APlayerCameraManager_GetOwningPlayerController_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.GetFOVAngle
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float APlayerCameraManager::GetFOVAngle() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2a8103ce);

		APlayerCameraManager_GetFOVAngle_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.GetCameraRotation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator APlayerCameraManager::GetCameraRotation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x233c2e8b);

		APlayerCameraManager_GetCameraRotation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.GetCameraLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector APlayerCameraManager::GetCameraLocation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x15b72730);

		APlayerCameraManager_GetCameraLocation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.FindCameraModifierByClass
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  ModifierClass                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UCameraModifier*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UCameraModifier* APlayerCameraManager::FindCameraModifierByClass(class UClass* ModifierClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xedcc1890);

		APlayerCameraManager_FindCameraModifierByClass_Params params;
		params.ModifierClass = ModifierClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.ClearCameraLensEffects
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void APlayerCameraManager::ClearCameraLensEffects() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x284eaf68);

		APlayerCameraManager_ClearCameraLensEffects_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerCameraManager.BlueprintUpdateCamera
	// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// class AActor*                  CameraTarget                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewCameraLocation              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewCameraRotation              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NewCameraFOV                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool APlayerCameraManager::BlueprintUpdateCamera(class AActor* CameraTarget, struct FVector* NewCameraLocation, struct FRotator* NewCameraRotation, float* NewCameraFOV) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96ab4f5f);

		APlayerCameraManager_BlueprintUpdateCamera_Params params;
		params.CameraTarget = CameraTarget;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (NewCameraLocation != nullptr)
			*NewCameraLocation = params.NewCameraLocation;
		if (NewCameraRotation != nullptr)
			*NewCameraRotation = params.NewCameraRotation;
		if (NewCameraFOV != nullptr)
			*NewCameraFOV = params.NewCameraFOV;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.AddNewCameraModifier
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  ModifierClass                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UCameraModifier*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UCameraModifier* APlayerCameraManager::AddNewCameraModifier(class UClass* ModifierClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x12d232a3);

		APlayerCameraManager_AddNewCameraModifier_Params params;
		params.ModifierClass = ModifierClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerCameraManager.AddCameraLensEffect
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  LensEffectEmitterClass         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AEmitterCameraLensEffectBase* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AEmitterCameraLensEffectBase* APlayerCameraManager::AddCameraLensEffect(class UClass* LensEffectEmitterClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa8a23157);

		APlayerCameraManager_AddCameraLensEffect_Params params;
		params.LensEffectEmitterClass = LensEffectEmitterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerState.ReceiveOverrideWith
	// (FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerState*            OldPlayerState                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerState::ReceiveOverrideWith(class APlayerState* OldPlayerState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb7be3faa);

		APlayerState_ReceiveOverrideWith_Params params;
		params.OldPlayerState = OldPlayerState;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerState.ReceiveCopyProperties
	// (FUNC_Event, FUNC_Protected, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerState*            NewPlayerState                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlayerState::ReceiveCopyProperties(class APlayerState* NewPlayerState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdafb664a);

		APlayerState_ReceiveCopyProperties_Params params;
		params.NewPlayerState = NewPlayerState;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerState.OnRep_UniqueId
	// (FUNC_Native, FUNC_Public)

	void APlayerState::OnRep_UniqueId() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe06a5682);

		APlayerState_OnRep_UniqueId_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerState.OnRep_Score
	// (FUNC_Native, FUNC_Public)

	void APlayerState::OnRep_Score() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c67c93a);

		APlayerState_OnRep_Score_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerState.OnRep_PlayerName
	// (FUNC_Native, FUNC_Public)

	void APlayerState::OnRep_PlayerName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf1a66ce6);

		APlayerState_OnRep_PlayerName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerState.OnRep_bIsInactive
	// (FUNC_Native, FUNC_Public)

	void APlayerState::OnRep_bIsInactive() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc7642431);

		APlayerState_OnRep_bIsInactive_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BoxComponent.SetBoxExtent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 InBoxExtent                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateOverlaps                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UBoxComponent::SetBoxExtent(const struct FVector& InBoxExtent, bool bUpdateOverlaps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbab95080);

		UBoxComponent_SetBoxExtent_Params params;
		params.InBoxExtent = InBoxExtent;
		params.bUpdateOverlaps = bUpdateOverlaps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BoxComponent.GetUnscaledBoxExtent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UBoxComponent::GetUnscaledBoxExtent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8145fab1);

		UBoxComponent_GetUnscaledBoxExtent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.BoxComponent.GetScaledBoxExtent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UBoxComponent::GetScaledBoxExtent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x291c402a);

		UBoxComponent_GetScaledBoxExtent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SceneCaptureComponent.ShowOnlyComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     InComponent                    (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void USceneCaptureComponent::ShowOnlyComponent(class UPrimitiveComponent* InComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa49ce09e);

		USceneCaptureComponent_ShowOnlyComponent_Params params;
		params.InComponent = InComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneCaptureComponent.ShowOnlyActorComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  InActor                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneCaptureComponent::ShowOnlyActorComponents(class AActor* InActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x181d38c8);

		USceneCaptureComponent_ShowOnlyActorComponents_Params params;
		params.InActor = InActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneCaptureComponent.HideComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     InComponent                    (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void USceneCaptureComponent::HideComponent(class UPrimitiveComponent* InComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc1bb6719);

		USceneCaptureComponent_HideComponent_Params params;
		params.InComponent = InComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneCaptureComponent.HideActorComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  InActor                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneCaptureComponent::HideActorComponents(class AActor* InActor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe717f383);

		USceneCaptureComponent_HideActorComponents_Params params;
		params.InActor = InActor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneCaptureComponent2D.CaptureScene
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USceneCaptureComponent2D::CaptureScene() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x147c5c74);

		USceneCaptureComponent2D_CaptureScene_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TScriptInterface<class UBlendableInterface> InBlendableObject              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InWeight                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USceneCaptureComponent2D::AddOrUpdateBlendable(const TScriptInterface<class UBlendableInterface>& InBlendableObject, float InWeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x391ca2f0);

		USceneCaptureComponent2D_AddOrUpdateBlendable_Params params;
		params.InBlendableObject = InBlendableObject;
		params.InWeight = InWeight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DefaultPawn.TurnAtRate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Rate                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADefaultPawn::TurnAtRate(float Rate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4d72972a);

		ADefaultPawn_TurnAtRate_Params params;
		params.Rate = Rate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DefaultPawn.Turn
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADefaultPawn::Turn(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x92893ff3);

		ADefaultPawn_Turn_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DefaultPawn.MoveUp_World
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADefaultPawn::MoveUp_World(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x117b98e7);

		ADefaultPawn_MoveUp_World_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DefaultPawn.MoveRight
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADefaultPawn::MoveRight(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf5280de1);

		ADefaultPawn_MoveRight_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DefaultPawn.MoveForward
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADefaultPawn::MoveForward(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xad1449b4);

		ADefaultPawn_MoveForward_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DefaultPawn.LookUpAtRate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Rate                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADefaultPawn::LookUpAtRate(float Rate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x66333fc9);

		ADefaultPawn_LookUpAtRate_Params params;
		params.Rate = Rate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DefaultPawn.LookUp
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Val                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADefaultPawn::LookUp(float Val) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa29ff1dc);

		ADefaultPawn_LookUp_Params params;
		params.Val = Val;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.UpdateSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USplineComponent::UpdateSpline() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa483c19);

		USplineComponent_UpdateSpline_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetWorldLocationAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InLocation                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void USplineComponent::SetWorldLocationAtSplinePoint(int PointIndex, const struct FVector& InLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa1f2ee66);

		USplineComponent_SetWorldLocationAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.InLocation = InLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetUpVectorAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InUpVector                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetUpVectorAtSplinePoint(int PointIndex, const struct FVector& InUpVector, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb2324615);

		USplineComponent_SetUpVectorAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.InUpVector = InUpVector;
		params.CoordinateSpace = CoordinateSpace;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetUnselectedSplineSegmentColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            SegmentColor                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void USplineComponent::SetUnselectedSplineSegmentColor(const struct FLinearColor& SegmentColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6240c622);

		USplineComponent_SetUnselectedSplineSegmentColor_Params params;
		params.SegmentColor = SegmentColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetTangentsAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InArriveTangent                (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 InLeaveTangent                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetTangentsAtSplinePoint(int PointIndex, const struct FVector& InArriveTangent, const struct FVector& InLeaveTangent, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x55995629);

		USplineComponent_SetTangentsAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.InArriveTangent = InArriveTangent;
		params.InLeaveTangent = InLeaveTangent;
		params.CoordinateSpace = CoordinateSpace;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetTangentAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InTangent                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetTangentAtSplinePoint(int PointIndex, const struct FVector& InTangent, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ddf07f4);

		USplineComponent_SetTangentAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.InTangent = InTangent;
		params.CoordinateSpace = CoordinateSpace;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetSplineWorldPoints
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<struct FVector>         Points                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void USplineComponent::SetSplineWorldPoints(TArray<struct FVector> Points) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xec810ae1);

		USplineComponent_SetSplineWorldPoints_Params params;
		params.Points = Points;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetSplinePointType
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplinePointType>  Type                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetSplinePointType(int PointIndex, TEnumAsByte<ESplinePointType> Type, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ab55702);

		USplineComponent_SetSplinePointType_Params params;
		params.PointIndex = PointIndex;
		params.Type = Type;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetSplinePoints
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<struct FVector>         Points                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetSplinePoints(TArray<struct FVector> Points, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x198c071d);

		USplineComponent_SetSplinePoints_Params params;
		params.Points = Points;
		params.CoordinateSpace = CoordinateSpace;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetSplineLocalPoints
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<struct FVector>         Points                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void USplineComponent::SetSplineLocalPoints(TArray<struct FVector> Points) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8857e940);

		USplineComponent_SetSplineLocalPoints_Params params;
		params.Points = Points;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetSelectedSplineSegmentColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            SegmentColor                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void USplineComponent::SetSelectedSplineSegmentColor(const struct FLinearColor& SegmentColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3845e207);

		USplineComponent_SetSelectedSplineSegmentColor_Params params;
		params.SegmentColor = SegmentColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetLocationAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InLocation                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetLocationAtSplinePoint(int PointIndex, const struct FVector& InLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9e113710);

		USplineComponent_SetLocationAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.InLocation = InLocation;
		params.CoordinateSpace = CoordinateSpace;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetDrawDebug
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bShow                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetDrawDebug(bool bShow) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xec53115a);

		USplineComponent_SetDrawDebug_Params params;
		params.bShow = bShow;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetDefaultUpVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 UpVector                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetDefaultUpVector(const struct FVector& UpVector, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x863748f4);

		USplineComponent_SetDefaultUpVector_Params params;
		params.UpVector = UpVector;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetClosedLoopAtPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInClosedLoop                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Key                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x20c33adf);

		USplineComponent_SetClosedLoopAtPosition_Params params;
		params.bInClosedLoop = bInClosedLoop;
		params.Key = Key;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.SetClosedLoop
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInClosedLoop                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc8557bd);

		USplineComponent_SetClosedLoop_Params params;
		params.bInClosedLoop = bInClosedLoop;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.RemoveSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::RemoveSplinePoint(int Index, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4e76bd0);

		USplineComponent_RemoveSplinePoint_Params params;
		params.Index = Index;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.IsClosedLoop
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USplineComponent::IsClosedLoop() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xee54f0bb);

		USplineComponent_IsClosedLoop_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetWorldTangentAtDistanceAlongSpline(float Distance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5d900fa);

		USplineComponent_GetWorldTangentAtDistanceAlongSpline_Params params;
		params.Distance = Distance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetWorldRotationAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator USplineComponent::GetWorldRotationAtTime(float Time, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x51faeb03);

		USplineComponent_GetWorldRotationAtTime_Params params;
		params.Time = Time;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator USplineComponent::GetWorldRotationAtDistanceAlongSpline(float Distance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89d2da03);

		USplineComponent_GetWorldRotationAtDistanceAlongSpline_Params params;
		params.Distance = Distance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetWorldLocationAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetWorldLocationAtTime(float Time, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3102b0c0);

		USplineComponent_GetWorldLocationAtTime_Params params;
		params.Time = Time;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetWorldLocationAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetWorldLocationAtSplinePoint(int PointIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x91c8aeea);

		USplineComponent_GetWorldLocationAtSplinePoint_Params params;
		params.PointIndex = PointIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetWorldLocationAtDistanceAlongSpline(float Distance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd94f277e);

		USplineComponent_GetWorldLocationAtDistanceAlongSpline_Params params;
		params.Distance = Distance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetWorldDirectionAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e3eaf88);

		USplineComponent_GetWorldDirectionAtTime_Params params;
		params.Time = Time;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetWorldDirectionAtDistanceAlongSpline(float Distance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x43b297b6);

		USplineComponent_GetWorldDirectionAtDistanceAlongSpline_Params params;
		params.Distance = Distance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetUpVectorAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetUpVectorAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe55fc159);

		USplineComponent_GetUpVectorAtTime_Params params;
		params.Time = Time;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetUpVectorAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetUpVectorAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26620521);

		USplineComponent_GetUpVectorAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetUpVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79af094d);

		USplineComponent_GetUpVectorAtDistanceAlongSpline_Params params;
		params.Distance = Distance;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetTransformAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseScale                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform USplineComponent::GetTransformAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity, bool bUseScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb7364dcd);

		USplineComponent_GetTransformAtTime_Params params;
		params.Time = Time;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseConstantVelocity = bUseConstantVelocity;
		params.bUseScale = bUseScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetTransformAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseScale                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform USplineComponent::GetTransformAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x10fdf955);

		USplineComponent_GetTransformAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseScale = bUseScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseScale                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform USplineComponent::GetTransformAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe8d2ba59);

		USplineComponent_GetTransformAtDistanceAlongSpline_Params params;
		params.Distance = Distance;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseScale = bUseScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetTangentAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetTangentAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x49a9a66a);

		USplineComponent_GetTangentAtTime_Params params;
		params.Time = Time;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetTangentAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetTangentAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x34dbf110);

		USplineComponent_GetTangentAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetTangentAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa8c15514);

		USplineComponent_GetTangentAtDistanceAlongSpline_Params params;
		params.Distance = Distance;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetSplinePointType
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplinePointType>  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<ESplinePointType> USplineComponent::GetSplinePointType(int PointIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9af3b90e);

		USplineComponent_GetSplinePointType_Params params;
		params.PointIndex = PointIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetSplineLength
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineComponent::GetSplineLength() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1dce4358);

		USplineComponent_GetSplineLength_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetScaleAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetScaleAtTime(float Time, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x41eebd5f);

		USplineComponent_GetScaleAtTime_Params params;
		params.Time = Time;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetScaleAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetScaleAtSplinePoint(int PointIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3ed52c4b);

		USplineComponent_GetScaleAtSplinePoint_Params params;
		params.PointIndex = PointIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetScaleAtDistanceAlongSpline(float Distance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2bddc47);

		USplineComponent_GetScaleAtDistanceAlongSpline_Params params;
		params.Distance = Distance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRotationAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator USplineComponent::GetRotationAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbb292399);

		USplineComponent_GetRotationAtTime_Params params;
		params.Time = Time;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRotationAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator USplineComponent::GetRotationAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8de4a861);

		USplineComponent_GetRotationAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator USplineComponent::GetRotationAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7906668d);

		USplineComponent_GetRotationAtDistanceAlongSpline_Params params;
		params.Distance = Distance;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRollAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineComponent::GetRollAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1fec6e0e);

		USplineComponent_GetRollAtTime_Params params;
		params.Time = Time;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRollAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineComponent::GetRollAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcced07a4);

		USplineComponent_GetRollAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRollAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineComponent::GetRollAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2853920);

		USplineComponent_GetRollAtDistanceAlongSpline_Params params;
		params.Distance = Distance;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRightVectorAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetRightVectorAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3ca8dcba);

		USplineComponent_GetRightVectorAtTime_Params params;
		params.Time = Time;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRightVectorAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetRightVectorAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfc5517e0);

		USplineComponent_GetRightVectorAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetRightVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1be4ed64);

		USplineComponent_GetRightVectorAtDistanceAlongSpline_Params params;
		params.Distance = Distance;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetNumberOfSplinePoints
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int USplineComponent::GetNumberOfSplinePoints() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf171a025);

		USplineComponent_GetNumberOfSplinePoints_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetLocationAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetLocationAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdc6bdb46);

		USplineComponent_GetLocationAtTime_Params params;
		params.Time = Time;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetLocationAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetLocationAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa606a46c);

		USplineComponent_GetLocationAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetLocationAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x643aafa8);

		USplineComponent_GetLocationAtDistanceAlongSpline_Params params;
		params.Distance = Distance;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Tangent                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::GetLocationAndTangentAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, struct FVector* Location, struct FVector* Tangent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2a0166fa);

		USplineComponent_GetLocationAndTangentAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Location != nullptr)
			*Location = params.Location;
		if (Tangent != nullptr)
			*Tangent = params.Tangent;
	}


	// Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LocalLocation                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LocalTangent                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::GetLocalLocationAndTangentAtSplinePoint(int PointIndex, struct FVector* LocalLocation, struct FVector* LocalTangent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1149ebb);

		USplineComponent_GetLocalLocationAndTangentAtSplinePoint_Params params;
		params.PointIndex = PointIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (LocalLocation != nullptr)
			*LocalLocation = params.LocalLocation;
		if (LocalTangent != nullptr)
			*LocalTangent = params.LocalTangent;
	}


	// Function Engine.SplineComponent.GetLeaveTangentAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetLeaveTangentAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd7904bf3);

		USplineComponent_GetLeaveTangentAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineComponent::GetInputKeyAtDistanceAlongSpline(float Distance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdb598d44);

		USplineComponent_GetInputKeyAtDistanceAlongSpline_Params params;
		params.Distance = Distance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineComponent::GetDistanceAlongSplineAtSplinePoint(int PointIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfdf2e72c);

		USplineComponent_GetDistanceAlongSplineAtSplinePoint_Params params;
		params.PointIndex = PointIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetDirectionAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseConstantVelocity           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetDirectionAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x119141e2);

		USplineComponent_GetDirectionAtTime_Params params;
		params.Time = Time;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseConstantVelocity = bUseConstantVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetDirectionAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetDirectionAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe156c9f8);

		USplineComponent_GetDirectionAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          Distance                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetDirectionAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2d216a1c);

		USplineComponent_GetDirectionAtDistanceAlongSpline_Params params;
		params.Distance = Distance;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetDefaultUpVector
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetDefaultUpVector(TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x70c95908);

		USplineComponent_GetDefaultUpVector_Params params;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.GetArriveTangentAtSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            PointIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::GetArriveTangentAtSplinePoint(int PointIndex, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xce1be8d9);

		USplineComponent_GetArriveTangentAtSplinePoint_Params params;
		params.PointIndex = PointIndex;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindUpVectorClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::FindUpVectorClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5fd6d099);

		USplineComponent_FindUpVectorClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindTransformClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseScale                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform USplineComponent::FindTransformClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUseScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfcc8951f);

		USplineComponent_FindTransformClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;
		params.bUseScale = bUseScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindTangentClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::FindTangentClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6dae600);

		USplineComponent_FindTangentClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindScaleClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::FindScaleClosestToWorldLocation(const struct FVector& WorldLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa73641b1);

		USplineComponent_FindScaleClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindRotationClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator USplineComponent::FindRotationClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa131e6a5);

		USplineComponent_FindRotationClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindRollClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineComponent::FindRollClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x128e240e);

		USplineComponent_FindRollClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindRightVectorClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::FindRightVectorClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2f704f20);

		USplineComponent_FindRightVectorClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindLocationClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x353537fa);

		USplineComponent_FindLocationClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineComponent::FindInputKeyClosestToWorldLocation(const struct FVector& WorldLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x153f6306);

		USplineComponent_FindInputKeyClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.FindDirectionClosestToWorldLocation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineComponent::FindDirectionClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfa92e948);

		USplineComponent_FindDirectionClosestToWorldLocation_Params params;
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineComponent.ClearSplinePoints
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::ClearSplinePoints(bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x63ec1532);

		USplineComponent_ClearSplinePoints_Params params;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.AddSplineWorldPoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Position                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void USplineComponent::AddSplineWorldPoint(const struct FVector& Position) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd63209db);

		USplineComponent_AddSplineWorldPoint_Params params;
		params.Position = Position;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.AddSplinePointAtIndex
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Position                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::AddSplinePointAtIndex(const struct FVector& Position, int Index, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x165a28b2);

		USplineComponent_AddSplinePointAtIndex_Params params;
		params.Position = Position;
		params.Index = Index;
		params.CoordinateSpace = CoordinateSpace;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.AddSplinePoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Position                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::AddSplinePoint(const struct FVector& Position, TEnumAsByte<ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x11fcd1e5);

		USplineComponent_AddSplinePoint_Params params;
		params.Position = Position;
		params.CoordinateSpace = CoordinateSpace;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.AddSplineLocalPoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Position                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void USplineComponent::AddSplineLocalPoint(const struct FVector& Position) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf47de160);

		USplineComponent_AddSplineLocalPoint_Params params;
		params.Position = Position;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.AddPoints
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<struct FSplinePoint>    Points                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::AddPoints(TArray<struct FSplinePoint> Points, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf8391053);

		USplineComponent_AddPoints_Params params;
		params.Points = Points;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineComponent.AddPoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FSplinePoint            Point                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           bUpdateSpline                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineComponent::AddPoint(const struct FSplinePoint& Point, bool bUpdateSpline) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x61769df8);

		USplineComponent_AddPoint_Params params;
		params.Point = Point;
		params.bUpdateSpline = bUpdateSpline;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialInterface.GetPhysicalMaterial
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UPhysicalMaterial*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UPhysicalMaterial* UMaterialInterface::GetPhysicalMaterial() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x95d43ef3);

		UMaterialInterface_GetPhysicalMaterial_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MaterialInterface.GetBaseMaterial
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterial*               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterial* UMaterialInterface::GetBaseMaterial() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa55a6ab);

		UMaterialInterface_GetBaseMaterial_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.BlueprintAsyncActionBase.Activate
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UBlueprintAsyncActionBase::Activate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xecad8cf2);

		UBlueprintAsyncActionBase_Activate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraActor.GetAutoActivatePlayerIndex
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int ACameraActor::GetAutoActivatePlayerIndex() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf5b6502);

		ACameraActor_GetAutoActivatePlayerIndex_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.OnlineBlueprintCallProxyBase.Activate
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UOnlineBlueprintCallProxyBase::Activate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcbd23dfb);

		UOnlineBlueprintCallProxyBase_Activate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AmbientSound.Stop
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AAmbientSound::Stop() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd483c4f0);

		AAmbientSound_Stop_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AmbientSound.Play
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AAmbientSound::Play(float StartTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x48d8fe3e);

		AAmbientSound_Play_Params params;
		params.StartTime = StartTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AmbientSound.FadeOut
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          FadeOutDuration                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FadeVolumeLevel                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AAmbientSound::FadeOut(float FadeOutDuration, float FadeVolumeLevel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcfcc4a6);

		AAmbientSound_FadeOut_Params params;
		params.FadeOutDuration = FadeOutDuration;
		params.FadeVolumeLevel = FadeVolumeLevel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AmbientSound.FadeIn
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          FadeInDuration                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FadeVolumeLevel                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AAmbientSound::FadeIn(float FadeInDuration, float FadeVolumeLevel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x49db6913);

		AAmbientSound_FadeIn_Params params;
		params.FadeInDuration = FadeInDuration;
		params.FadeVolumeLevel = FadeVolumeLevel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AmbientSound.AdjustVolume
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          AdjustVolumeDuration           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          AdjustVolumeLevel              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AAmbientSound::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x307790e3);

		AAmbientSound_AdjustVolume_Params params;
		params.AdjustVolumeDuration = AdjustVolumeDuration;
		params.AdjustVolumeLevel = AdjustVolumeLevel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioVolume.SetReverbSettings
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FReverbSettings         NewReverbSettings              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void AAudioVolume::SetReverbSettings(const struct FReverbSettings& NewReverbSettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbd3d5e9c);

		AAudioVolume_SetReverbSettings_Params params;
		params.NewReverbSettings = NewReverbSettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioVolume.SetPriority
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewPriority                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AAudioVolume::SetPriority(float NewPriority) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x759b6f8f);

		AAudioVolume_SetPriority_Params params;
		params.NewPriority = NewPriority;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioVolume.SetInteriorSettings
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FInteriorSettings       NewInteriorSettings            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void AAudioVolume::SetInteriorSettings(const struct FInteriorSettings& NewInteriorSettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x520c486c);

		AAudioVolume_SetInteriorSettings_Params params;
		params.NewInteriorSettings = NewInteriorSettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioVolume.SetEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewEnabled                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AAudioVolume::SetEnabled(bool bNewEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x246ce66e);

		AAudioVolume_SetEnabled_Params params;
		params.bNewEnabled = bNewEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioVolume.OnRep_bEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Private)

	void AAudioVolume::OnRep_bEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xadb86df3);

		AAudioVolume_OnRep_bEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavModifierVolume.SetAreaClass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  NewAreaClass                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ANavModifierVolume::SetAreaClass(class UClass* NewAreaClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4fe3a5fe);

		ANavModifierVolume_SetAreaClass_Params params;
		params.NewAreaClass = NewAreaClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PostProcessVolume.AddOrUpdateBlendable
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TScriptInterface<class UBlendableInterface> InBlendableObject              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InWeight                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APostProcessVolume::AddOrUpdateBlendable(const TScriptInterface<class UBlendableInterface>& InBlendableObject, float InWeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x51fb7676);

		APostProcessVolume_AddOrUpdateBlendable_Params params;
		params.InBlendableObject = InBlendableObject;
		params.InWeight = InWeight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraShake.ReceiveStopShake
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// bool                           bImmediately                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraShake::ReceiveStopShake(bool bImmediately) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x11a1c04d);

		UCameraShake_ReceiveStopShake_Params params;
		params.bImmediately = bImmediately;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraShake.ReceivePlayShake
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraShake::ReceivePlayShake(float Scale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x99fbdc53);

		UCameraShake_ReceivePlayShake_Params params;
		params.Scale = Scale;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraShake.ReceiveIsFinished
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UCameraShake::ReceiveIsFinished() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xac78284b);

		UCameraShake_ReceiveIsFinished_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CameraShake.BlueprintUpdateCameraShake
	// (FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintEvent)
	// Parameters:
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FMinimalViewInfo        POV                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FMinimalViewInfo        ModifiedPOV                    (CPF_Parm, CPF_OutParm)

	void UCameraShake::BlueprintUpdateCameraShake(float DeltaTime, float Alpha, const struct FMinimalViewInfo& POV, struct FMinimalViewInfo* ModifiedPOV) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd949bc91);

		UCameraShake_BlueprintUpdateCameraShake_Params params;
		params.DeltaTime = DeltaTime;
		params.Alpha = Alpha;
		params.POV = POV;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (ModifiedPOV != nullptr)
			*ModifiedPOV = params.ModifiedPOV;
	}


	// Function Engine.InputComponent.WasControllerKeyJustReleased
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UInputComponent::WasControllerKeyJustReleased(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe8a9d3df);

		UInputComponent_WasControllerKeyJustReleased_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InputComponent.WasControllerKeyJustPressed
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UInputComponent::WasControllerKeyJustPressed(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x98cf8748);

		UInputComponent_WasControllerKeyJustPressed_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InputComponent.IsControllerKeyDown
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UInputComponent::IsControllerKeyDown(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2bd07515);

		UInputComponent_IsControllerKeyDown_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InputComponent.GetTouchState
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            FingerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LocationX                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LocationY                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIsCurrentlyPressed            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInputComponent::GetTouchState(int FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbd3f1c8);

		UInputComponent_GetTouchState_Params params;
		params.FingerIndex = FingerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (LocationX != nullptr)
			*LocationX = params.LocationX;
		if (LocationY != nullptr)
			*LocationY = params.LocationY;
		if (bIsCurrentlyPressed != nullptr)
			*bIsCurrentlyPressed = params.bIsCurrentlyPressed;
	}


	// Function Engine.InputComponent.GetControllerVectorKeyState
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UInputComponent::GetControllerVectorKeyState(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd396c729);

		UInputComponent_GetControllerVectorKeyState_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InputComponent.GetControllerMouseDelta
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          DeltaX                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaY                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInputComponent::GetControllerMouseDelta(float* DeltaX, float* DeltaY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xddf16dd9);

		UInputComponent_GetControllerMouseDelta_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (DeltaX != nullptr)
			*DeltaX = params.DeltaX;
		if (DeltaY != nullptr)
			*DeltaY = params.DeltaY;
	}


	// Function Engine.InputComponent.GetControllerKeyTimeDown
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UInputComponent::GetControllerKeyTimeDown(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2e5a63a);

		UInputComponent_GetControllerKeyTimeDown_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.InputComponent.GetControllerAnalogStickState
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<EControllerAnalogStick> WhichStick                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StickX                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StickY                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInputComponent::GetControllerAnalogStickState(TEnumAsByte<EControllerAnalogStick> WhichStick, float* StickX, float* StickY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8492e0f);

		UInputComponent_GetControllerAnalogStickState_Params params;
		params.WhichStick = WhichStick;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (StickX != nullptr)
			*StickX = params.StickX;
		if (StickY != nullptr)
			*StickY = params.StickY;
	}


	// Function Engine.InputComponent.GetControllerAnalogKeyState
	// (FUNC_Final, FUNC_Native, FUNC_Private, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FKey                    Key                            (CPF_Parm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UInputComponent::GetControllerAnalogKeyState(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcb60ca90);

		UInputComponent_GetControllerAnalogKeyState_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CurveBase.GetValueRange
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          MinValue                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxValue                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCurveBase::GetValueRange(float* MinValue, float* MaxValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbcc1571f);

		UCurveBase_GetValueRange_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (MinValue != nullptr)
			*MinValue = params.MinValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}


	// Function Engine.CurveBase.GetTimeRange
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          MinTime                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxTime                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCurveBase::GetTimeRange(float* MinTime, float* MaxTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbb8a0ed5);

		UCurveBase_GetTimeRange_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (MinTime != nullptr)
			*MinTime = params.MinTime;
		if (MaxTime != nullptr)
			*MaxTime = params.MaxTime;
	}


	// Function Engine.CurveFloat.GetFloatValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          InTime                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCurveFloat::GetFloatValue(float InTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6d0f4171);

		UCurveFloat_GetFloatValue_Params params;
		params.InTime = InTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.DebugCameraController.ToggleDisplay
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void ADebugCameraController::ToggleDisplay() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2b0e8c85);

		ADebugCameraController_ToggleDisplay_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DebugCameraController.ShowDebugSelectedInfo
	// (FUNC_Exec, FUNC_Native, FUNC_Public)

	void ADebugCameraController::ShowDebugSelectedInfo() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79f5a20c);

		ADebugCameraController_ShowDebugSelectedInfo_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DebugCameraController.SetPawnMovementSpeedScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewSpeedScale                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADebugCameraController::SetPawnMovementSpeedScale(float NewSpeedScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x63561437);

		ADebugCameraController_SetPawnMovementSpeedScale_Params params;
		params.NewSpeedScale = NewSpeedScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DebugCameraController.ReceiveOnDeactivate
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       RestoredPC                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADebugCameraController::ReceiveOnDeactivate(class APlayerController* RestoredPC) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9551d37d);

		ADebugCameraController_ReceiveOnDeactivate_Params params;
		params.RestoredPC = RestoredPC;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DebugCameraController.ReceiveOnActorSelected
	// (FUNC_Event, FUNC_Protected, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// class AActor*                  NewSelectedActor               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SelectHitLocation              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 SelectHitNormal                (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FHitResult              Hit                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void ADebugCameraController::ReceiveOnActorSelected(class AActor* NewSelectedActor, const struct FVector& SelectHitLocation, const struct FVector& SelectHitNormal, const struct FHitResult& Hit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f4d8125);

		ADebugCameraController_ReceiveOnActorSelected_Params params;
		params.NewSelectedActor = NewSelectedActor;
		params.SelectHitLocation = SelectHitLocation;
		params.SelectHitNormal = SelectHitNormal;
		params.Hit = Hit;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DebugCameraController.ReceiveOnActivate
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class APlayerController*       OriginalPC                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADebugCameraController::ReceiveOnActivate(class APlayerController* OriginalPC) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe860ad44);

		ADebugCameraController_ReceiveOnActivate_Params params;
		params.OriginalPC = OriginalPC;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DebugCameraController.GetSelectedActor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* ADebugCameraController::GetSelectedActor() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4a721d07);

		ADebugCameraController_GetSelectedActor_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.DecalActor.SetDecalMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      NewDecalMaterial               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ADecalActor::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e20a299);

		ADecalActor_SetDecalMaterial_Params params;
		params.NewDecalMaterial = NewDecalMaterial;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DecalActor.GetDecalMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UMaterialInterface*      ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInterface* ADecalActor::GetDecalMaterial() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaeb0fe45);

		ADecalActor_GetDecalMaterial_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.DecalActor.CreateDynamicMaterialInstance
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInstanceDynamic* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInstanceDynamic* ADecalActor::CreateDynamicMaterialInstance() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c60b386);

		ADecalActor_CreateDynamicMaterialInstance_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Emitter.ToggleActive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AEmitter::ToggleActive() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa4aed6ad);

		AEmitter_ToggleActive_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.SetVectorParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AEmitter::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x14d21f0d);

		AEmitter_SetVectorParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.SetTemplate
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UParticleSystem*         NewTemplate                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AEmitter::SetTemplate(class UParticleSystem* NewTemplate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xced4bb13);

		AEmitter_SetTemplate_Params params;
		params.NewTemplate = NewTemplate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.SetMaterialParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AEmitter::SetMaterialParameter(const struct FName& ParameterName, class UMaterialInterface* Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d197b07);

		AEmitter_SetMaterialParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.SetFloatParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AEmitter::SetFloatParameter(const struct FName& ParameterName, float Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c199802);

		AEmitter_SetFloatParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.SetColorParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AEmitter::SetColorParameter(const struct FName& ParameterName, const struct FLinearColor& Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa768417f);

		AEmitter_SetColorParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.SetActorParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AEmitter::SetActorParameter(const struct FName& ParameterName, class AActor* Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x93d6f415);

		AEmitter_SetActorParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.OnRep_bCurrentlyActive
	// (FUNC_Native, FUNC_Public)

	void AEmitter::OnRep_bCurrentlyActive() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3564d242);

		AEmitter_OnRep_bCurrentlyActive_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.OnParticleSystemFinished
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// class UParticleSystemComponent* FinishedComponent              (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void AEmitter::OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf375ce7);

		AEmitter_OnParticleSystemFinished_Params params;
		params.FinishedComponent = FinishedComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.IsActive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool AEmitter::IsActive() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c6d50dd);

		AEmitter_IsActive_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Emitter.Deactivate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AEmitter::Deactivate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7425379);

		AEmitter_Deactivate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Emitter.Activate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AEmitter::Activate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x83e9eb60);

		AEmitter_Activate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFog.OnRep_bEnabled
	// (FUNC_Native, FUNC_Public)

	void AExponentialHeightFog::OnRep_bEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb2972555);

		AExponentialHeightFog_OnRep_bEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLight.OnRep_bEnabled
	// (FUNC_Native, FUNC_Public)

	void ASkyLight::OnRep_bEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd3561956);

		ASkyLight_OnRep_bEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.WorldSettings.OnRep_WorldGravityZ
	// (FUNC_Native, FUNC_Public)

	void AWorldSettings::OnRep_WorldGravityZ() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x382f6061);

		AWorldSettings_OnRep_WorldGravityZ_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponentBase.SetCastShadows
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponentBase::SetCastShadows(bool bNewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7d9f2105);

		ULightComponentBase_SetCastShadows_Params params;
		params.bNewValue = bNewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponentBase.GetLightColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor ULightComponentBase::GetLightColor() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x238f1d06);

		ULightComponentBase_GetLightColor_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.LightComponent.SetTemperature
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewTemperature                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetTemperature(float NewTemperature) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc42eae56);

		ULightComponent_SetTemperature_Params params;
		params.NewTemperature = NewTemperature;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetLightFunctionScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLightFunctionScale          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetLightFunctionScale(const struct FVector& NewLightFunctionScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x25cf7d4a);

		ULightComponent_SetLightFunctionScale_Params params;
		params.NewLightFunctionScale = NewLightFunctionScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetLightFunctionMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      NewLightFunctionMaterial       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe0dc4da7);

		ULightComponent_SetLightFunctionMaterial_Params params;
		params.NewLightFunctionMaterial = NewLightFunctionMaterial;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetLightFunctionFadeDistance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewLightFunctionFadeDistance   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd3c3a1db);

		ULightComponent_SetLightFunctionFadeDistance_Params params;
		params.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetLightFunctionDisabledBrightness
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetLightFunctionDisabledBrightness(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x922e8e49);

		ULightComponent_SetLightFunctionDisabledBrightness_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetLightColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            NewLightColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSRGB                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetLightColor(const struct FLinearColor& NewLightColor, bool bSRGB) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x978c9c49);

		ULightComponent_SetLightColor_Params params;
		params.NewLightColor = NewLightColor;
		params.bSRGB = bSRGB;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetIntensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewIntensity                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetIntensity(float NewIntensity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe56e86db);

		ULightComponent_SetIntensity_Params params;
		params.NewIntensity = NewIntensity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetIndirectLightingIntensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewIntensity                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetIndirectLightingIntensity(float NewIntensity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x988dfedd);

		ULightComponent_SetIndirectLightingIntensity_Params params;
		params.NewIntensity = NewIntensity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetIESTexture
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTextureLightProfile*    NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetIESTexture(class UTextureLightProfile* NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x80541926);

		ULightComponent_SetIESTexture_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetEnableLightShaftBloom
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetEnableLightShaftBloom(bool bNewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8da695e6);

		ULightComponent_SetEnableLightShaftBloom_Params params;
		params.bNewValue = bNewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetBloomTint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FColor                  NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetBloomTint(const struct FColor& NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcfee30da);

		ULightComponent_SetBloomTint_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetBloomThreshold
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetBloomThreshold(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8e598fa);

		ULightComponent_SetBloomThreshold_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetBloomScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetBloomScale(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x70c8031);

		ULightComponent_SetBloomScale_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetAffectTranslucentLighting
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetAffectTranslucentLighting(bool bNewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x269a2308);

		ULightComponent_SetAffectTranslucentLighting_Params params;
		params.bNewValue = bNewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LightComponent.SetAffectDynamicIndirectLighting
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ULightComponent::SetAffectDynamicIndirectLighting(bool bNewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb38ba60c);

		ULightComponent_SetAffectDynamicIndirectLighting_Params params;
		params.bNewValue = bNewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.ToggleEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void ALight::ToggleEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x34780f98);

		ALight_ToggleEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.SetLightFunctionScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLightFunctionScale          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALight::SetLightFunctionScale(const struct FVector& NewLightFunctionScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37c760dd);

		ALight_SetLightFunctionScale_Params params;
		params.NewLightFunctionScale = NewLightFunctionScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.SetLightFunctionMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      NewLightFunctionMaterial       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALight::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb21246e2);

		ALight_SetLightFunctionMaterial_Params params;
		params.NewLightFunctionMaterial = NewLightFunctionMaterial;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.SetLightFunctionFadeDistance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewLightFunctionFadeDistance   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALight::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1cb8d1ea);

		ALight_SetLightFunctionFadeDistance_Params params;
		params.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.SetLightColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            NewLightColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALight::SetLightColor(const struct FLinearColor& NewLightColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcecc423a);

		ALight_SetLightColor_Params params;
		params.NewLightColor = NewLightColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.SetEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bSetEnabled                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALight::SetEnabled(bool bSetEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x942a943a);

		ALight_SetEnabled_Params params;
		params.bSetEnabled = bSetEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.SetCastShadows
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALight::SetCastShadows(bool bNewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x689f17c5);

		ALight_SetCastShadows_Params params;
		params.bNewValue = bNewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.SetBrightness
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewBrightness                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALight::SetBrightness(float NewBrightness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x49b9b39e);

		ALight_SetBrightness_Params params;
		params.NewBrightness = NewBrightness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.SetAffectTranslucentLighting
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ALight::SetAffectTranslucentLighting(bool bNewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5d40a4dd);

		ALight_SetAffectTranslucentLighting_Params params;
		params.bNewValue = bNewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.OnRep_bEnabled
	// (FUNC_Native, FUNC_Public)

	void ALight::OnRep_bEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf7633c2f);

		ALight_OnRep_bEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Light.IsEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ALight::IsEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbad0db08);

		ALight_IsEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Light.GetLightColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor ALight::GetLightColor() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6caa4ac6);

		ALight_GetLightColor_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Light.GetBrightness
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float ALight::GetBrightness() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf5f99aba);

		ALight_GetBrightness_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PointLight.SetRadius
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewRadius                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APointLight::SetRadius(float NewRadius) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe34009a5);

		APointLight_SetRadius_Params params;
		params.NewRadius = NewRadius;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PointLight.SetLightFalloffExponent
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewLightFalloffExponent        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APointLight::SetLightFalloffExponent(float NewLightFalloffExponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa925b75c);

		APointLight_SetLightFalloffExponent_Params params;
		params.NewLightFalloffExponent = NewLightFalloffExponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SpotLight.SetOuterConeAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewOuterConeAngle              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ASpotLight::SetOuterConeAngle(float NewOuterConeAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd5a189fa);

		ASpotLight_SetOuterConeAngle_Params params;
		params.NewOuterConeAngle = NewOuterConeAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SpotLight.SetInnerConeAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewInnerConeAngle              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ASpotLight::SetInnerConeAngle(float NewInnerConeAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5d088bf1);

		ASpotLight_SetInnerConeAngle_Params params;
		params.NewInnerConeAngle = NewInnerConeAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MatineeActor.Stop
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AMatineeActor::Stop() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x39ba2577);

		AMatineeActor_Stop_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MatineeActor.SetPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewPosition                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bJump                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AMatineeActor::SetPosition(float NewPosition, bool bJump) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcd979278);

		AMatineeActor_SetPosition_Params params;
		params.NewPosition = NewPosition;
		params.bJump = bJump;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MatineeActor.SetLoopingState
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewLooping                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AMatineeActor::SetLoopingState(bool bNewLooping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf88bc328);

		AMatineeActor_SetLoopingState_Params params;
		params.bNewLooping = bNewLooping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MatineeActor.Reverse
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AMatineeActor::Reverse() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1d4b06b7);

		AMatineeActor_Reverse_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MatineeActor.Play
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AMatineeActor::Play() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd878f1c1);

		AMatineeActor_Play_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MatineeActor.Pause
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AMatineeActor::Pause() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1c87262f);

		AMatineeActor_Pause_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MatineeActor.EnableGroupByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 GroupName                      (CPF_Parm, CPF_ZeroConstructor)
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void AMatineeActor::EnableGroupByName(const struct FString& GroupName, bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x269ea8b1);

		AMatineeActor_EnableGroupByName_Params params;
		params.GroupName = GroupName;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MatineeActor.ChangePlaybackDirection
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void AMatineeActor::ChangePlaybackDirection() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf9bd757);

		AMatineeActor_ChangePlaybackDirection_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavLinkProxy.SetSmartLinkEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnabled                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ANavLinkProxy::SetSmartLinkEnabled(bool bEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe4254dae);

		ANavLinkProxy_SetSmartLinkEnabled_Params params;
		params.bEnabled = bEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavLinkProxy.ResumePathFollowing
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  Agent                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ANavLinkProxy::ResumePathFollowing(class AActor* Agent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x29d000f1);

		ANavLinkProxy_ResumePathFollowing_Params params;
		params.Agent = Agent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavLinkProxy.ReceiveSmartLinkReached
	// (FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// class AActor*                  Agent                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Destination                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void ANavLinkProxy::ReceiveSmartLinkReached(class AActor* Agent, const struct FVector& Destination) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbad17d14);

		ANavLinkProxy_ReceiveSmartLinkReached_Params params;
		params.Agent = Agent;
		params.Destination = Destination;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavLinkProxy.IsSmartLinkEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ANavLinkProxy::IsSmartLinkEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x293dfdce);

		ANavLinkProxy_IsSmartLinkEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavLinkProxy.HasMovingAgents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ANavLinkProxy::HasMovingAgents() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf4b77c);

		ANavLinkProxy_HasMovingAgents_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMesh.NumSockets
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int USkeletalMesh::NumSockets() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3fb8cff);

		USkeletalMesh_NumSockets_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMesh.IsSectionUsingCloth
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            InSectionIndex                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bCheckCorrespondingSections    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USkeletalMesh::IsSectionUsingCloth(int InSectionIndex, bool bCheckCorrespondingSections) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6c33640e);

		USkeletalMesh_IsSectionUsingCloth_Params params;
		params.InSectionIndex = InSectionIndex;
		params.bCheckCorrespondingSections = bCheckCorrespondingSections;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMesh.GetSocketByIndex
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USkeletalMeshSocket*     ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class USkeletalMeshSocket* USkeletalMesh::GetSocketByIndex(int Index) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3e159fb1);

		USkeletalMesh_GetSocketByIndex_Params params;
		params.Index = Index;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMesh.GetImportedBounds
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FBoxSphereBounds        ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FBoxSphereBounds USkeletalMesh::GetImportedBounds() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x46cd233c);

		USkeletalMesh_GetImportedBounds_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMesh.GetBounds
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FBoxSphereBounds        ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FBoxSphereBounds USkeletalMesh::GetBounds() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b573964);

		USkeletalMesh_GetBounds_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMesh.FindSocketAndIndex
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            OutIndex                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USkeletalMeshSocket*     ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class USkeletalMeshSocket* USkeletalMesh::FindSocketAndIndex(const struct FName& InSocketName, int* OutIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79027f1e);

		USkeletalMesh_FindSocketAndIndex_Params params;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutIndex != nullptr)
			*OutIndex = params.OutIndex;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMesh.FindSocket
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InSocketName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USkeletalMeshSocket*     ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class USkeletalMeshSocket* USkeletalMesh::FindSocket(const struct FName& InSocketName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x71dba4ff);

		USkeletalMesh_FindSocket_Params params;
		params.InSocketName = InSocketName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.RadialForceActor.ToggleForce
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void ARadialForceActor::ToggleForce() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc82c80ad);

		ARadialForceActor_ToggleForce_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.RadialForceActor.FireImpulse
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void ARadialForceActor::FireImpulse() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x284a315d);

		ARadialForceActor_FireImpulse_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.RadialForceActor.EnableForce
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void ARadialForceActor::EnableForce() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8844effe);

		ARadialForceActor_EnableForce_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.RadialForceActor.DisableForce
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void ARadialForceActor::DisableForce() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x43c9edfd);

		ARadialForceActor_DisableForce_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlanarReflection.OnInterpToggle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void APlanarReflection::OnInterpToggle(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf1db81f);

		APlanarReflection_OnInterpToggle_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneCapture2D.OnInterpToggle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ASceneCapture2D::OnInterpToggle(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4858072a);

		ASceneCapture2D_OnInterpToggle_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneCaptureCube.OnInterpToggle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void ASceneCaptureCube::OnInterpToggle(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x13f7bead);

		ASceneCaptureCube_OnInterpToggle_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bRestoreSimulationSpace        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::UnbindClothFromMasterPoseComponent(bool bRestoreSimulationSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x83808472);

		USkeletalMeshComponent_UnbindClothFromMasterPoseComponent_Params params;
		params.bRestoreSimulationSpace = bRestoreSimulationSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.Stop
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USkeletalMeshComponent::Stop() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfcfdb370);

		USkeletalMeshComponent_Stop_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InPos                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFireNotifies                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetPosition(float InPos, bool bFireNotifies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcebc0f41);

		USkeletalMeshComponent_SetPosition_Params params;
		params.InPos = InPos;
		params.bFireNotifies = bFireNotifies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetPlayRate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Rate                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetPlayRate(float Rate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x47ff9f08);

		USkeletalMeshComponent_SetPlayRate_Params params;
		params.Rate = Rate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          PhysicsBlendWeight             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetPhysicsBlendWeight(float PhysicsBlendWeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c6e27ec);

		USkeletalMeshComponent_SetPhysicsBlendWeight_Params params;
		params.PhysicsBlendWeight = PhysicsBlendWeight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetNotifyRigidBodyCollisionBelow
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewNotifyRigidBodyCollision   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIncludeSelf                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, const struct FName& BoneName, bool bIncludeSelf) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x657aa593);

		USkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow_Params params;
		params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
		params.BoneName = BoneName;
		params.bIncludeSelf = bIncludeSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetMorphTarget
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   MorphTargetName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bRemoveZeroWeight              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetMorphTarget(const struct FName& MorphTargetName, float Value, bool bRemoveZeroWeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xafbafd);

		USkeletalMeshComponent_SetMorphTarget_Params params;
		params.MorphTargetName = MorphTargetName;
		params.Value = Value;
		params.bRemoveZeroWeight = bRemoveZeroWeight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewBlendPhysics               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetEnablePhysicsBlending(bool bNewBlendPhysics) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6249e83);

		USkeletalMeshComponent_SetEnablePhysicsBlending_Params params;
		params.bNewBlendPhysics = bNewBlendPhysics;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetEnableGravityOnAllBodiesBelow
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnableGravity                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIncludeSelf                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, const struct FName& BoneName, bool bIncludeSelf) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5eec7cae);

		USkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow_Params params;
		params.bEnableGravity = bEnableGravity;
		params.BoneName = BoneName;
		params.bIncludeSelf = bIncludeSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetEnableBodyGravity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnableGravity                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetEnableBodyGravity(bool bEnableGravity, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x304f7ff5);

		USkeletalMeshComponent_SetEnableBodyGravity_Params params;
		params.bEnableGravity = bEnableGravity;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetConstraintProfileForAll
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ProfileName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bDefaultIfNotFound             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetConstraintProfileForAll(const struct FName& ProfileName, bool bDefaultIfNotFound) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xca3f42be);

		USkeletalMeshComponent_SetConstraintProfileForAll_Params params;
		params.ProfileName = ProfileName;
		params.bDefaultIfNotFound = bDefaultIfNotFound;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetConstraintProfile
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   JointName                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ProfileName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bDefaultIfNotFound             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetConstraintProfile(const struct FName& JointName, const struct FName& ProfileName, bool bDefaultIfNotFound) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc744afb0);

		USkeletalMeshComponent_SetConstraintProfile_Params params;
		params.JointName = JointName;
		params.ProfileName = ProfileName;
		params.bDefaultIfNotFound = bDefaultIfNotFound;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetClothMaxDistanceScale(float Scale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7d750b7);

		USkeletalMeshComponent_SetClothMaxDistanceScale_Params params;
		params.Scale = Scale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetBodyNotifyRigidBodyCollision
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewNotifyRigidBodyCollision   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc939f68);

		USkeletalMeshComponent_SetBodyNotifyRigidBodyCollision_Params params;
		params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAnimInstanceClass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  NewClass                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAnimInstanceClass(class UClass* NewClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab27447e);

		USkeletalMeshComponent_SetAnimInstanceClass_Params params;
		params.NewClass = NewClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAnimationMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EAnimationMode>    InAnimationMode                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAnimationMode(TEnumAsByte<EAnimationMode> InAnimationMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6aa1c6d7);

		USkeletalMeshComponent_SetAnimationMode_Params params;
		params.InAnimationMode = InAnimationMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAnimation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimationAsset*         NewAnimToPlay                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAnimation(class UAnimationAsset* NewAnimToPlay) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbf22b5b2);

		USkeletalMeshComponent_SetAnimation_Params params;
		params.NewAnimToPlay = NewAnimToPlay;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAngularLimits
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InBoneName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Swing1LimitAngle               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TwistLimitAngle                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Swing2LimitAngle               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAngularLimits(const struct FName& InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb6e43666);

		USkeletalMeshComponent_SetAngularLimits_Params params;
		params.InBoneName = InBoneName;
		params.Swing1LimitAngle = Swing1LimitAngle;
		params.TwistLimitAngle = TwistLimitAngle;
		params.Swing2LimitAngle = Swing2LimitAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnableSwingDrive              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableTwistDrive              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSkipCustomPhysicsType         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76886922);

		USkeletalMeshComponent_SetAllMotorsAngularVelocityDrive_Params params;
		params.bEnableSwingDrive = bEnableSwingDrive;
		params.bEnableTwistDrive = bEnableTwistDrive;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnableSwingDrive              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableTwistDrive              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSkipCustomPhysicsType         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf61612a);

		USkeletalMeshComponent_SetAllMotorsAngularPositionDrive_Params params;
		params.bEnableSwingDrive = bEnableSwingDrive;
		params.bEnableTwistDrive = bEnableTwistDrive;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InSpring                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InDamping                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InForceLimit                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSkipCustomPhysicsType         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x59e1d0ef);

		USkeletalMeshComponent_SetAllMotorsAngularDriveParams_Params params;
		params.InSpring = InSpring;
		params.InDamping = InDamping;
		params.InForceLimit = InForceLimit;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewSimulate                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAllBodiesSimulatePhysics(bool bNewSimulate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x22515b72);

		USkeletalMeshComponent_SetAllBodiesSimulatePhysics_Params params;
		params.bNewSimulate = bNewSimulate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          PhysicsBlendWeight             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSkipCustomPhysicsType         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9749979d);

		USkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight_Params params;
		params.PhysicsBlendWeight = PhysicsBlendWeight;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InBoneName                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bNewSimulate                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIncludeSelf                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAllBodiesBelowSimulatePhysics(const struct FName& InBoneName, bool bNewSimulate, bool bIncludeSelf) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x938c1bc9);

		USkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics_Params params;
		params.InBoneName = InBoneName;
		params.bNewSimulate = bNewSimulate;
		params.bIncludeSelf = bIncludeSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InBoneName                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          PhysicsBlendWeight             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSkipCustomPhysicsType         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIncludeSelf                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::SetAllBodiesBelowPhysicsBlendWeight(const struct FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc0b1bb8c);

		USkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight_Params params;
		params.InBoneName = InBoneName;
		params.PhysicsBlendWeight = PhysicsBlendWeight;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;
		params.bIncludeSelf = bIncludeSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.ResetClothTeleportMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USkeletalMeshComponent::ResetClothTeleportMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9e724aeb);

		USkeletalMeshComponent_ResetClothTeleportMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USkeletalMeshComponent::ResetAllBodiesSimulatePhysics() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc600060f);

		USkeletalMeshComponent_ResetAllBodiesSimulatePhysics_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.PlayAnimation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimationAsset*         NewAnimToPlay                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLooping                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::PlayAnimation(class UAnimationAsset* NewAnimToPlay, bool bLooping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x28a0c538);

		USkeletalMeshComponent_PlayAnimation_Params params;
		params.NewAnimToPlay = NewAnimToPlay;
		params.bLooping = bLooping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.Play
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bLooping                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::Play(bool bLooping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7152ecbe);

		USkeletalMeshComponent_Play_Params params;
		params.bLooping = bLooping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.OverrideAnimationData
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimationAsset*         InAnimToPlay                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIsLooping                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIsPlaying                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Position                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PlayRate                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::OverrideAnimationData(class UAnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x710210c2);

		USkeletalMeshComponent_OverrideAnimationData_Params params;
		params.InAnimToPlay = InAnimToPlay;
		params.bIsLooping = bIsLooping;
		params.bIsPlaying = bIsPlaying;
		params.Position = Position;
		params.PlayRate = PlayRate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.K2_GetClosestPointOnPhysicsAsset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 WorldPosition                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 ClosestWorldPosition           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Normal                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Distance                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USkeletalMeshComponent::K2_GetClosestPointOnPhysicsAsset(const struct FVector& WorldPosition, struct FVector* ClosestWorldPosition, struct FVector* Normal, struct FName* BoneName, float* Distance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeeb26041);

		USkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset_Params params;
		params.WorldPosition = WorldPosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (ClosestWorldPosition != nullptr)
			*ClosestWorldPosition = params.ClosestWorldPosition;
		if (Normal != nullptr)
			*Normal = params.Normal;
		if (BoneName != nullptr)
			*BoneName = params.BoneName;
		if (Distance != nullptr)
			*Distance = params.Distance;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.IsPlaying
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USkeletalMeshComponent::IsPlaying() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x47e9d3a);

		USkeletalMeshComponent_IsPlaying_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.IsBodyGravityEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USkeletalMeshComponent::IsBodyGravityEnabled(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xee0c115);

		USkeletalMeshComponent_IsBodyGravityEnabled_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetSkeletalCenterOfMass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USkeletalMeshComponent::GetSkeletalCenterOfMass() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe320e48d);

		USkeletalMeshComponent_GetSkeletalCenterOfMass_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetPostProcessInstance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UAnimInstance*           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UAnimInstance* USkeletalMeshComponent::GetPostProcessInstance() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x481ee4b0);

		USkeletalMeshComponent_GetPostProcessInstance_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USkeletalMeshComponent::GetPosition() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x440d0905);

		USkeletalMeshComponent_GetPosition_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetPlayRate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USkeletalMeshComponent::GetPlayRate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd5b345f4);

		USkeletalMeshComponent_GetPlayRate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetMorphTarget
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   MorphTargetName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USkeletalMeshComponent::GetMorphTarget(const struct FName& MorphTargetName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3888ba9);

		USkeletalMeshComponent_GetMorphTarget_Params params;
		params.MorphTargetName = MorphTargetName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetCurrentJointAngles
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InBoneName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Swing1Angle                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TwistAngle                     (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Swing2Angle                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::GetCurrentJointAngles(const struct FName& InBoneName, float* Swing1Angle, float* TwistAngle, float* Swing2Angle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x59445969);

		USkeletalMeshComponent_GetCurrentJointAngles_Params params;
		params.InBoneName = InBoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Swing1Angle != nullptr)
			*Swing1Angle = params.Swing1Angle;
		if (TwistAngle != nullptr)
			*TwistAngle = params.TwistAngle;
		if (Swing2Angle != nullptr)
			*Swing2Angle = params.Swing2Angle;
	}


	// Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USkeletalMeshComponent::GetClothMaxDistanceScale() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xce6ef263);

		USkeletalMeshComponent_GetClothMaxDistanceScale_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetBoneMass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bScaleMass                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USkeletalMeshComponent::GetBoneMass(const struct FName& BoneName, bool bScaleMass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfab8685e);

		USkeletalMeshComponent_GetBoneMass_Params params;
		params.BoneName = BoneName;
		params.bScaleMass = bScaleMass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetAnimInstance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UAnimInstance*           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UAnimInstance* USkeletalMeshComponent::GetAnimInstance() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5aec4952);

		USkeletalMeshComponent_GetAnimInstance_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.GetAnimationMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<EAnimationMode>    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<EAnimationMode> USkeletalMeshComponent::GetAnimationMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb14c3ab);

		USkeletalMeshComponent_GetAnimationMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USkeletalMeshComponent::ForceClothNextUpdateTeleportAndReset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x802218ce);

		USkeletalMeshComponent_ForceClothNextUpdateTeleportAndReset_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USkeletalMeshComponent::ForceClothNextUpdateTeleport() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe15ad4de);

		USkeletalMeshComponent_ForceClothNextUpdateTeleport_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.FindConstraintBoneName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ConstraintIndex                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName USkeletalMeshComponent::FindConstraintBoneName(int ConstraintIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37e7a9b7);

		USkeletalMeshComponent_FindConstraintBoneName_Params params;
		params.ConstraintIndex = ConstraintIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SkeletalMeshComponent.ClearMorphTargets
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USkeletalMeshComponent::ClearMorphTargets() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf3e0783);

		USkeletalMeshComponent_ClearMorphTargets_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.BreakConstraint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Impulse                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   InBoneName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, const struct FName& InBoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4a524d4);

		USkeletalMeshComponent_BreakConstraint_Params params;
		params.Impulse = Impulse;
		params.HitLocation = HitLocation;
		params.InBoneName = InBoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.BindClothToMasterPoseComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USkeletalMeshComponent::BindClothToMasterPoseComponent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76bb5762);

		USkeletalMeshComponent_BindClothToMasterPoseComponent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.AddImpulseToAllBodiesBelow
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Impulse                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bVelChange                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIncludeSelf                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::AddImpulseToAllBodiesBelow(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange, bool bIncludeSelf) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa4b82841);

		USkeletalMeshComponent_AddImpulseToAllBodiesBelow_Params params;
		params.Impulse = Impulse;
		params.BoneName = BoneName;
		params.bVelChange = bVelChange;
		params.bIncludeSelf = bIncludeSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.AddForceToAllBodiesBelow
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Force                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAccelChange                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIncludeSelf                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::AddForceToAllBodiesBelow(const struct FVector& Force, const struct FName& BoneName, bool bAccelChange, bool bIncludeSelf) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd8fbad8d);

		USkeletalMeshComponent_AddForceToAllBodiesBelow_Params params;
		params.Force = Force;
		params.BoneName = BoneName;
		params.bAccelChange = bAccelChange;
		params.bIncludeSelf = bIncludeSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InBoneName                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          AddPhysicsBlendWeight          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSkipCustomPhysicsType         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshComponent::AccumulateAllBodiesBelowPhysicsBlendWeight(const struct FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe969e80a);

		USkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight_Params params;
		params.InBoneName = InBoneName;
		params.AddPhysicsBlendWeight = AddPhysicsBlendWeight;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset
	// (FUNC_Native, FUNC_Public)

	void ASkeletalMeshActor::OnRep_ReplicatedPhysAsset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7614aa2a);

		ASkeletalMeshActor_OnRep_ReplicatedPhysAsset_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh
	// (FUNC_Native, FUNC_Public)

	void ASkeletalMeshActor::OnRep_ReplicatedMesh() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfa6a25e5);

		ASkeletalMeshActor_OnRep_ReplicatedMesh_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1
	// (FUNC_Native, FUNC_Public)

	void ASkeletalMeshActor::OnRep_ReplicatedMaterial1() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x836b2282);

		ASkeletalMeshActor_OnRep_ReplicatedMaterial1_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0
	// (FUNC_Native, FUNC_Public)

	void ASkeletalMeshActor::OnRep_ReplicatedMaterial0() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa96d9ceb);

		ASkeletalMeshActor_OnRep_ReplicatedMaterial0_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.ApplicationLifecycleComponent.ApplicationLifetimeDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)

	void UApplicationLifecycleComponent::ApplicationLifetimeDelegate__DelegateSignature() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc1ffaddc);

		UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.InterpToMovementComponent.StopSimulating
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FHitResult              HitResult                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UInterpToMovementComponent::StopSimulating(const struct FHitResult& HitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x86b999f7);

		UInterpToMovementComponent_StopSimulating_Params params;
		params.HitResult = HitResult;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.InterpToMovementComponent.RestartMovement
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InitialDirection               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInterpToMovementComponent::RestartMovement(float InitialDirection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3df88dce);

		UInterpToMovementComponent_RestartMovement_Params params;
		params.InitialDirection = InitialDirection;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate, FUNC_HasOutParms)
	// Parameters:
	// struct FHitResult              ImpactResult                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInterpToMovementComponent::OnInterpToWaitEndDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x428c003d);

		UInterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature_Params params;
		params.ImpactResult = ImpactResult;
		params.Time = Time;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate, FUNC_HasOutParms)
	// Parameters:
	// struct FHitResult              ImpactResult                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInterpToMovementComponent::OnInterpToWaitBeginDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2da5a75d);

		UInterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature_Params params;
		params.ImpactResult = ImpactResult;
		params.Time = Time;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate, FUNC_HasOutParms)
	// Parameters:
	// struct FHitResult              ImpactResult                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInterpToMovementComponent::OnInterpToStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b85bc5d);

		UInterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature_Params params;
		params.ImpactResult = ImpactResult;
		params.Time = Time;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate, FUNC_HasOutParms)
	// Parameters:
	// struct FHitResult              ImpactResult                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInterpToMovementComponent::OnInterpToReverseDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x527be285);

		UInterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature_Params params;
		params.ImpactResult = ImpactResult;
		params.Time = Time;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate, FUNC_HasOutParms)
	// Parameters:
	// struct FHitResult              ImpactResult                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UInterpToMovementComponent::OnInterpToResetDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5a56e9cc);

		UInterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature_Params params;
		params.ImpactResult = ImpactResult;
		params.Time = Time;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.InterpToMovementComponent.FinaliseControlPoints
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UInterpToMovementComponent::FinaliseControlPoints() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f9b0375);

		UInterpToMovementComponent_FinaliseControlPoints_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.UnregisterNavigationInvoker
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  Invoker                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavigationSystem::UnregisterNavigationInvoker(class AActor* Invoker) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x640c7dee);

		UNavigationSystem_UnregisterNavigationInvoker_Params params;
		params.Invoker = Invoker;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.SimpleMoveToLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class AController*             Controller                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Goal                           (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UNavigationSystem::STATIC_SimpleMoveToLocation(class AController* Controller, const struct FVector& Goal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xda687613);

		UNavigationSystem_SimpleMoveToLocation_Params params;
		params.Controller = Controller;
		params.Goal = Goal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.SimpleMoveToActor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AController*             Controller                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  Goal                           (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavigationSystem::STATIC_SimpleMoveToActor(class AController* Controller, class AActor* Goal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5bd54c9);

		UNavigationSystem_SimpleMoveToActor_Params params;
		params.Controller = Controller;
		params.Goal = Goal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.SetMaxSimultaneousTileGenerationJobsCount
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            MaxNumberOfJobs                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavigationSystem::SetMaxSimultaneousTileGenerationJobsCount(int MaxNumberOfJobs) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe3fe3494);

		UNavigationSystem_SetMaxSimultaneousTileGenerationJobsCount_Params params;
		params.MaxNumberOfJobs = MaxNumberOfJobs;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.SetGeometryGatheringMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ENavDataGatheringModeConfig> NewMode                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavigationSystem::SetGeometryGatheringMode(TEnumAsByte<ENavDataGatheringModeConfig> NewMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x21a4478a);

		UNavigationSystem_SetGeometryGatheringMode_Params params;
		params.NewMode = NewMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.ResetMaxSimultaneousTileGenerationJobsCount
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UNavigationSystem::ResetMaxSimultaneousTileGenerationJobsCount() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8b6ef7b9);

		UNavigationSystem_ResetMaxSimultaneousTileGenerationJobsCount_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.RegisterNavigationInvoker
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  Invoker                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TileGenerationRadius           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TileRemovalRadius              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavigationSystem::RegisterNavigationInvoker(class AActor* Invoker, float TileGenerationRadius, float TileRemovalRadius) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2a317a6d);

		UNavigationSystem_RegisterNavigationInvoker_Params params;
		params.Invoker = Invoker;
		params.TileGenerationRadius = TileGenerationRadius;
		params.TileRemovalRadius = TileRemovalRadius;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.ProjectPointToNavigation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Point                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class ANavigationData*         NavData                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 QueryExtent                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UNavigationSystem::STATIC_ProjectPointToNavigation(class UObject* WorldContext, const struct FVector& Point, class ANavigationData* NavData, class UClass* FilterClass, const struct FVector& QueryExtent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1dfaf166);

		UNavigationSystem_ProjectPointToNavigation_Params params;
		params.WorldContext = WorldContext;
		params.Point = Point;
		params.NavData = NavData;
		params.FilterClass = FilterClass;
		params.QueryExtent = QueryExtent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.OnNavigationBoundsUpdated
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class ANavMeshBoundsVolume*    NavVolume                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavigationSystem::OnNavigationBoundsUpdated(class ANavMeshBoundsVolume* NavVolume) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85908b7);

		UNavigationSystem_OnNavigationBoundsUpdated_Params params;
		params.NavVolume = NavVolume;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationSystem.NavigationRaycast
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 RayStart                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 RayEnd                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 HitLocation                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AController*             Querier                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavigationSystem::STATIC_NavigationRaycast(class UObject* WorldContext, const struct FVector& RayStart, const struct FVector& RayEnd, class UClass* FilterClass, class AController* Querier, struct FVector* HitLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1cadcdff);

		UNavigationSystem_NavigationRaycast_Params params;
		params.WorldContext = WorldContext;
		params.RayStart = RayStart;
		params.RayEnd = RayEnd;
		params.FilterClass = FilterClass;
		params.Querier = Querier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HitLocation != nullptr)
			*HitLocation = params.HitLocation;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.IsNavigationBeingBuiltOrLocked
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavigationSystem::STATIC_IsNavigationBeingBuiltOrLocked(class UObject* WorldContext) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x12f7e558);

		UNavigationSystem_IsNavigationBeingBuiltOrLocked_Params params;
		params.WorldContext = WorldContext;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.IsNavigationBeingBuilt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavigationSystem::STATIC_IsNavigationBeingBuilt(class UObject* WorldContext) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b6fa80d);

		UNavigationSystem_IsNavigationBeingBuilt_Params params;
		params.WorldContext = WorldContext;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.GetRandomReachablePointInRadius
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class ANavigationData*         NavData                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UNavigationSystem::STATIC_GetRandomReachablePointInRadius(class UObject* WorldContext, const struct FVector& Origin, float Radius, class ANavigationData* NavData, class UClass* FilterClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8126b48f);

		UNavigationSystem_GetRandomReachablePointInRadius_Params params;
		params.WorldContext = WorldContext;
		params.Origin = Origin;
		params.Radius = Radius;
		params.NavData = NavData;
		params.FilterClass = FilterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.GetRandomPointInNavigableRadius
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class ANavigationData*         NavData                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UNavigationSystem::STATIC_GetRandomPointInNavigableRadius(class UObject* WorldContext, const struct FVector& Origin, float Radius, class ANavigationData* NavData, class UClass* FilterClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9f34c8ad);

		UNavigationSystem_GetRandomPointInNavigableRadius_Params params;
		params.WorldContext = WorldContext;
		params.Origin = Origin;
		params.Radius = Radius;
		params.NavData = NavData;
		params.FilterClass = FilterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.GetPathLength
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PathStart                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 PathEnd                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          PathLength                     (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class ANavigationData*         NavData                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ENavigationQueryResult> ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<ENavigationQueryResult> UNavigationSystem::STATIC_GetPathLength(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, class ANavigationData* NavData, class UClass* FilterClass, float* PathLength) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c903179);

		UNavigationSystem_GetPathLength_Params params;
		params.WorldContext = WorldContext;
		params.PathStart = PathStart;
		params.PathEnd = PathEnd;
		params.NavData = NavData;
		params.FilterClass = FilterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (PathLength != nullptr)
			*PathLength = params.PathLength;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.GetPathCost
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PathStart                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 PathEnd                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          PathCost                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class ANavigationData*         NavData                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ENavigationQueryResult> ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<ENavigationQueryResult> UNavigationSystem::STATIC_GetPathCost(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, class ANavigationData* NavData, class UClass* FilterClass, float* PathCost) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd2925fb6);

		UNavigationSystem_GetPathCost_Params params;
		params.WorldContext = WorldContext;
		params.PathStart = PathStart;
		params.PathEnd = PathEnd;
		params.NavData = NavData;
		params.FilterClass = FilterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (PathCost != nullptr)
			*PathCost = params.PathCost;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.GetNavigationSystem
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UNavigationSystem*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UNavigationSystem* UNavigationSystem::STATIC_GetNavigationSystem(class UObject* WorldContext) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xde0fd3fd);

		UNavigationSystem_GetNavigationSystem_Params params;
		params.WorldContext = WorldContext;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.FindPathToLocationSynchronously
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PathStart                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 PathEnd                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class AActor*                  PathfindingContext             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UNavigationPath*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UNavigationPath* UNavigationSystem::STATIC_FindPathToLocationSynchronously(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, class UClass* FilterClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9707e2f8);

		UNavigationSystem_FindPathToLocationSynchronously_Params params;
		params.WorldContext = WorldContext;
		params.PathStart = PathStart;
		params.PathEnd = PathEnd;
		params.PathfindingContext = PathfindingContext;
		params.FilterClass = FilterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationSystem.FindPathToActorSynchronously
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PathStart                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class AActor*                  GoalActor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TetherDistance                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  PathfindingContext             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UNavigationPath*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UNavigationPath* UNavigationSystem::STATIC_FindPathToActorSynchronously(class UObject* WorldContext, const struct FVector& PathStart, class AActor* GoalActor, float TetherDistance, class AActor* PathfindingContext, class UClass* FilterClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf9664ccc);

		UNavigationSystem_FindPathToActorSynchronously_Params params;
		params.WorldContext = WorldContext;
		params.PathStart = PathStart;
		params.GoalActor = GoalActor;
		params.TetherDistance = TetherDistance;
		params.PathfindingContext = PathfindingContext;
		params.FilterClass = FilterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ProjectileMovementComponent.StopSimulating
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FHitResult              HitResult                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UProjectileMovementComponent::StopSimulating(const struct FHitResult& HitResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x849e8a03);

		UProjectileMovementComponent_StopSimulating_Params params;
		params.HitResult = HitResult;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewVelocity                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UProjectileMovementComponent::SetVelocityInLocalSpace(const struct FVector& NewVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef3c6441);

		UProjectileMovementComponent_SetVelocityInLocalSpace_Params params;
		params.NewVelocity = NewVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate, FUNC_HasOutParms)
	// Parameters:
	// struct FHitResult              ImpactResult                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UProjectileMovementComponent::OnProjectileStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x87a6ad);

		UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature_Params params;
		params.ImpactResult = ImpactResult;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate, FUNC_HasOutParms, FUNC_HasDefaults)
	// Parameters:
	// struct FHitResult              ImpactResult                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 ImpactVelocity                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UProjectileMovementComponent::OnProjectileBounceDelegate__DelegateSignature(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbcfb81b5);

		UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature_Params params;
		params.ImpactResult = ImpactResult;
		params.ImpactVelocity = ImpactVelocity;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ProjectileMovementComponent.LimitVelocity
	// (FUNC_Final, FUNC_Native, FUNC_Protected, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 NewVelocity                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UProjectileMovementComponent::LimitVelocity(const struct FVector& NewVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd7420db8);

		UProjectileMovementComponent_LimitVelocity_Params params;
		params.NewVelocity = NewVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SimpleWheeledVehicleMovementComponent.SetSteerAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          SteerAngle                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            WheelIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USimpleWheeledVehicleMovementComponent::SetSteerAngle(float SteerAngle, int WheelIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdff1ba3f);

		USimpleWheeledVehicleMovementComponent_SetSteerAngle_Params params;
		params.SteerAngle = SteerAngle;
		params.WheelIndex = WheelIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SimpleWheeledVehicleMovementComponent.SetDriveTorque
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          DriveTorque                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            WheelIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USimpleWheeledVehicleMovementComponent::SetDriveTorque(float DriveTorque, int WheelIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7dbe3ea7);

		USimpleWheeledVehicleMovementComponent_SetDriveTorque_Params params;
		params.DriveTorque = DriveTorque;
		params.WheelIndex = WheelIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SimpleWheeledVehicleMovementComponent.SetBrakeTorque
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          BrakeTorque                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            WheelIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USimpleWheeledVehicleMovementComponent::SetBrakeTorque(float BrakeTorque, int WheelIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x36098112);

		USimpleWheeledVehicleMovementComponent_SetBrakeTorque_Params params;
		params.BrakeTorque = BrakeTorque;
		params.WheelIndex = WheelIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavRelevantComponent.SetNavigationRelevancy
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bRelevant                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavRelevantComponent::SetNavigationRelevancy(bool bRelevant) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37627de7);

		UNavRelevantComponent_SetNavigationRelevancy_Params params;
		params.bRelevant = bRelevant;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavModifierComponent.SetAreaClass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  NewAreaClass                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavModifierComponent::SetAreaClass(class UClass* NewAreaClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9d4ed481);

		UNavModifierComponent_SetAreaClass_Params params;
		params.NewAreaClass = NewAreaClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PawnNoiseEmitterComponent.MakeNoise
	// (FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  NoiseMaker                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Loudness                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NoiseLocation                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UPawnNoiseEmitterComponent::MakeNoise(class AActor* NoiseMaker, float Loudness, const struct FVector& NoiseLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb2cb96ac);

		UPawnNoiseEmitterComponent_MakeNoise_Params params;
		params.NoiseMaker = NoiseMaker;
		params.Loudness = Loudness;
		params.NoiseLocation = NoiseLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicalAnimationComponent.SetStrengthMultiplyer
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InStrengthMultiplyer           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicalAnimationComponent::SetStrengthMultiplyer(float InStrengthMultiplyer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x57843c93);

		UPhysicalAnimationComponent_SetStrengthMultiplyer_Params params;
		params.InStrengthMultiplyer = InStrengthMultiplyer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicalAnimationComponent.SetSkeletalMeshComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USkeletalMeshComponent*  InSkeletalMeshComponent        (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void UPhysicalAnimationComponent::SetSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b9581a4);

		UPhysicalAnimationComponent_SetSkeletalMeshComponent_Params params;
		params.InSkeletalMeshComponent = InSkeletalMeshComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettingsBelow
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BodyName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FPhysicalAnimationData  PhysicalAnimationData          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           bIncludeSelf                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicalAnimationComponent::ApplyPhysicalAnimationSettingsBelow(const struct FName& BodyName, const struct FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b6c806a);

		UPhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow_Params params;
		params.BodyName = BodyName;
		params.PhysicalAnimationData = PhysicalAnimationData;
		params.bIncludeSelf = bIncludeSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettings
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BodyName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FPhysicalAnimationData  PhysicalAnimationData          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UPhysicalAnimationComponent::ApplyPhysicalAnimationSettings(const struct FName& BodyName, const struct FPhysicalAnimationData& PhysicalAnimationData) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x851e522b);

		UPhysicalAnimationComponent_ApplyPhysicalAnimationSettings_Params params;
		params.BodyName = BodyName;
		params.PhysicalAnimationData = PhysicalAnimationData;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationProfileBelow
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BodyName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ProfileName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIncludeSelf                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bClearNotFound                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicalAnimationComponent::ApplyPhysicalAnimationProfileBelow(const struct FName& BodyName, const struct FName& ProfileName, bool bIncludeSelf, bool bClearNotFound) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc87e1e12);

		UPhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow_Params params;
		params.BodyName = BodyName;
		params.ProfileName = ProfileName;
		params.bIncludeSelf = bIncludeSelf;
		params.bClearNotFound = bClearNotFound;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.SetTargetRotation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::SetTargetRotation(const struct FRotator& NewRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3f7b9606);

		UPhysicsHandleComponent_SetTargetRotation_Params params;
		params.NewRotation = NewRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewRotation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::SetTargetLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x99a325e6);

		UPhysicsHandleComponent_SetTargetLocationAndRotation_Params params;
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.SetTargetLocation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::SetTargetLocation(const struct FVector& NewLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe0746809);

		UPhysicsHandleComponent_SetTargetLocation_Params params;
		params.NewLocation = NewLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.SetLinearStiffness
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewLinearStiffness             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::SetLinearStiffness(float NewLinearStiffness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1b2794a3);

		UPhysicsHandleComponent_SetLinearStiffness_Params params;
		params.NewLinearStiffness = NewLinearStiffness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.SetLinearDamping
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewLinearDamping               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::SetLinearDamping(float NewLinearDamping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xce9b1d36);

		UPhysicsHandleComponent_SetLinearDamping_Params params;
		params.NewLinearDamping = NewLinearDamping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.SetInterpolationSpeed
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewInterpolationSpeed          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::SetInterpolationSpeed(float NewInterpolationSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16c2b024);

		UPhysicsHandleComponent_SetInterpolationSpeed_Params params;
		params.NewInterpolationSpeed = NewInterpolationSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.SetAngularStiffness
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewAngularStiffness            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::SetAngularStiffness(float NewAngularStiffness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2305a322);

		UPhysicsHandleComponent_SetAngularStiffness_Params params;
		params.NewAngularStiffness = NewAngularStiffness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.SetAngularDamping
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewAngularDamping              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::SetAngularDamping(float NewAngularDamping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4784cbf7);

		UPhysicsHandleComponent_SetAngularDamping_Params params;
		params.NewAngularDamping = NewAngularDamping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.ReleaseComponent
	// (FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UPhysicsHandleComponent::ReleaseComponent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x19792cdd);

		UPhysicsHandleComponent_ReleaseComponent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.GrabComponentAtLocationWithRotation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   InBoneName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::GrabComponentAtLocationWithRotation(class UPrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& Location, const struct FRotator& Rotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa529be54);

		UPhysicsHandleComponent_GrabComponentAtLocationWithRotation_Params params;
		params.Component = Component;
		params.InBoneName = InBoneName;
		params.Location = Location;
		params.Rotation = Rotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.GrabComponentAtLocation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   InBoneName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 GrabLocation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::GrabComponentAtLocation(class UPrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& GrabLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x119fbc3e);

		UPhysicsHandleComponent_GrabComponentAtLocation_Params params;
		params.Component = Component;
		params.InBoneName = InBoneName;
		params.GrabLocation = GrabLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.GrabComponent
	// (FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   InBoneName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 GrabLocation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bConstrainRotation             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::GrabComponent(class UPrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3b9118c);

		UPhysicsHandleComponent_GrabComponent_Params params;
		params.Component = Component;
		params.InBoneName = InBoneName;
		params.GrabLocation = GrabLocation;
		params.bConstrainRotation = bConstrainRotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 TargetLocation                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                TargetRotation                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsHandleComponent::GetTargetLocationAndRotation(struct FVector* TargetLocation, struct FRotator* TargetRotation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3b9a9c2);

		UPhysicsHandleComponent_GetTargetLocationAndRotation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (TargetLocation != nullptr)
			*TargetLocation = params.TargetLocation;
		if (TargetRotation != nullptr)
			*TargetRotation = params.TargetRotation;
	}


	// Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPlatformEventsComponent::SupportsConvertibleLaptops() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa18663a0);

		UPlatformEventsComponent_SupportsConvertibleLaptops_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// DelegateFunction Engine.PlatformEventsComponent.PlatformEventDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)

	void UPlatformEventsComponent::PlatformEventDelegate__DelegateSignature() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x93bedec4);

		UPlatformEventsComponent_PlatformEventDelegate__DelegateSignature_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlatformEventsComponent.IsInTabletMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPlatformEventsComponent::IsInTabletMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x718dd0);

		UPlatformEventsComponent_IsInTabletMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlatformEventsComponent.IsInLaptopMode
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UPlatformEventsComponent::IsInLaptopMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4bb5f8cc);

		UPlatformEventsComponent_IsInLaptopMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AtmosphericFogComponent.StartPrecompute
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UAtmosphericFogComponent::StartPrecompute() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd53fd25b);

		UAtmosphericFogComponent_StartPrecompute_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetSunMultiplier
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewSunMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetSunMultiplier(float NewSunMultiplier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x450aeb20);

		UAtmosphericFogComponent_SetSunMultiplier_Params params;
		params.NewSunMultiplier = NewSunMultiplier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetStartDistance
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewStartDistance               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetStartDistance(float NewStartDistance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e636042);

		UAtmosphericFogComponent_SetStartDistance_Params params;
		params.NewStartDistance = NewStartDistance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetPrecomputeParams
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          DensityHeight                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaxScatteringOrder             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            InscatterAltitudeSampleNum     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetPrecomputeParams(float DensityHeight, int MaxScatteringOrder, int InscatterAltitudeSampleNum) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3b0a8be1);

		UAtmosphericFogComponent_SetPrecomputeParams_Params params;
		params.DensityHeight = DensityHeight;
		params.MaxScatteringOrder = MaxScatteringOrder;
		params.InscatterAltitudeSampleNum = InscatterAltitudeSampleNum;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetFogMultiplier
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewFogMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetFogMultiplier(float NewFogMultiplier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf2d2881a);

		UAtmosphericFogComponent_SetFogMultiplier_Params params;
		params.NewFogMultiplier = NewFogMultiplier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetDistanceScale
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewDistanceScale               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetDistanceScale(float NewDistanceScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc918bfca);

		UAtmosphericFogComponent_SetDistanceScale_Params params;
		params.NewDistanceScale = NewDistanceScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetDistanceOffset
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewDistanceOffset              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetDistanceOffset(float NewDistanceOffset) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc9ff95d);

		UAtmosphericFogComponent_SetDistanceOffset_Params params;
		params.NewDistanceOffset = NewDistanceOffset;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetDensityOffset
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewDensityOffset               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetDensityOffset(float NewDensityOffset) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24bb2be);

		UAtmosphericFogComponent_SetDensityOffset_Params params;
		params.NewDensityOffset = NewDensityOffset;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetDensityMultiplier
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewDensityMultiplier           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetDensityMultiplier(float NewDensityMultiplier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75de4ed2);

		UAtmosphericFogComponent_SetDensityMultiplier_Params params;
		params.NewDensityMultiplier = NewDensityMultiplier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetDefaultLightColor
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            NewLightColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetDefaultLightColor(const struct FLinearColor& NewLightColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x794dd025);

		UAtmosphericFogComponent_SetDefaultLightColor_Params params;
		params.NewLightColor = NewLightColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetDefaultBrightness
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewBrightness                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetDefaultBrightness(float NewBrightness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x88e52439);

		UAtmosphericFogComponent_SetDefaultBrightness_Params params;
		params.NewBrightness = NewBrightness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.SetAltitudeScale
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewAltitudeScale               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::SetAltitudeScale(float NewAltitudeScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa34ce02b);

		UAtmosphericFogComponent_SetAltitudeScale_Params params;
		params.NewAltitudeScale = NewAltitudeScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.DisableSunDisk
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           NewSunDisk                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::DisableSunDisk(bool NewSunDisk) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4e2b10b6);

		UAtmosphericFogComponent_DisableSunDisk_Params params;
		params.NewSunDisk = NewSunDisk;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AtmosphericFogComponent.DisableGroundScattering
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           NewGroundScattering            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAtmosphericFogComponent::DisableGroundScattering(bool NewGroundScattering) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbcb8674a);

		UAtmosphericFogComponent_DisableGroundScattering_Params params;
		params.NewGroundScattering = NewGroundScattering;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.Stop
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UAudioComponent::Stop() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x91b50756);

		UAudioComponent_Stop_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetWaveParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundWave*              InWave                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetWaveParameter(const struct FName& InName, class USoundWave* InWave) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc9ab3536);

		UAudioComponent_SetWaveParameter_Params params;
		params.InName = InName;
		params.InWave = InWave;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetVolumeMultiplier
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewVolumeMultiplier            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetVolumeMultiplier(float NewVolumeMultiplier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb48c2039);

		UAudioComponent_SetVolumeMultiplier_Params params;
		params.NewVolumeMultiplier = NewVolumeMultiplier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetUISound
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInUISound                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetUISound(bool bInUISound) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9e96c2c9);

		UAudioComponent_SetUISound_Params params;
		params.bInUISound = bInUISound;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetSound
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USoundBase*              NewSound                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetSound(class USoundBase* NewSound) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf4a238b3);

		UAudioComponent_SetSound_Params params;
		params.NewSound = NewSound;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetPitchMultiplier
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewPitchMultiplier             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetPitchMultiplier(float NewPitchMultiplier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x38e229ad);

		UAudioComponent_SetPitchMultiplier_Params params;
		params.NewPitchMultiplier = NewPitchMultiplier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetPaused
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bPause                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetPaused(bool bPause) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x497c5d8);

		UAudioComponent_SetPaused_Params params;
		params.bPause = bPause;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetIntParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            inInt                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetIntParameter(const struct FName& InName, int inInt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9dbd16ce);

		UAudioComponent_SetIntParameter_Params params;
		params.InName = InName;
		params.inInt = inInt;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetFloatParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          inFloat                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetFloatParameter(const struct FName& InName, float inFloat) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b575685);

		UAudioComponent_SetFloatParameter_Params params;
		params.InName = InName;
		params.inFloat = inFloat;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.SetBoolParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           InBool                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::SetBoolParameter(const struct FName& InName, bool InBool) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1166e733);

		UAudioComponent_SetBoolParameter_Params params;
		params.InName = InName;
		params.InBool = InBool;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.Play
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::Play(float StartTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1723f2dc);

		UAudioComponent_Play_Params params;
		params.StartTime = StartTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.IsPlaying
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAudioComponent::IsPlaying() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2b29d6c8);

		UAudioComponent_IsPlaying_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AudioComponent.FadeOut
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          FadeOutDuration                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FadeVolumeLevel                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::FadeOut(float FadeOutDuration, float FadeVolumeLevel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd622190);

		UAudioComponent_FadeOut_Params params;
		params.FadeOutDuration = FadeOutDuration;
		params.FadeVolumeLevel = FadeVolumeLevel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.FadeIn
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          FadeInDuration                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FadeVolumeLevel                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9cbbd159);

		UAudioComponent_FadeIn_Params params;
		params.FadeInDuration = FadeInDuration;
		params.FadeVolumeLevel = FadeVolumeLevel;
		params.StartTime = StartTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FAttenuationSettings    OutAttenuationSettings         (CPF_Parm, CPF_OutParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAudioComponent::BP_GetAttenuationSettingsToApply(struct FAttenuationSettings* OutAttenuationSettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x776efe49);

		UAudioComponent_BP_GetAttenuationSettingsToApply_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutAttenuationSettings != nullptr)
			*OutAttenuationSettings = params.OutAttenuationSettings;

		return params.ReturnValue;
	}


	// Function Engine.AudioComponent.AdjustVolume
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          AdjustVolumeDuration           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          AdjustVolumeLevel              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAudioComponent::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5a3bf109);

		UAudioComponent_AdjustVolume_Params params;
		params.AdjustVolumeDuration = AdjustVolumeDuration;
		params.AdjustVolumeLevel = AdjustVolumeLevel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AudioComponent.AdjustAttenuation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FAttenuationSettings    InAttenuationSettings          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UAudioComponent::AdjustAttenuation(const struct FAttenuationSettings& InAttenuationSettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76c05d69);

		UAudioComponent_AdjustAttenuation_Params params;
		params.InAttenuationSettings = InAttenuationSettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ChildActorComponent.SetChildActorClass
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  InClass                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UChildActorComponent::SetChildActorClass(class UClass* InClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2216f61c);

		UChildActorComponent_SetChildActorClass_Params params;
		params.InClass = InClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DecalComponent.SetSortOrder
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDecalComponent::SetSortOrder(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfc5fbf07);

		UDecalComponent_SetSortOrder_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DecalComponent.SetFadeOut
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          StartDelay                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           DestroyOwnerAfterFade          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDecalComponent::SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89e1c1c5);

		UDecalComponent_SetFadeOut_Params params;
		params.StartDelay = StartDelay;
		params.Duration = Duration;
		params.DestroyOwnerAfterFade = DestroyOwnerAfterFade;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DecalComponent.SetDecalMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      NewDecalMaterial               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDecalComponent::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xde10c87f);

		UDecalComponent_SetDecalMaterial_Params params;
		params.NewDecalMaterial = NewDecalMaterial;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DecalComponent.GetFadeStartDelay
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UDecalComponent::GetFadeStartDelay() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x28926b0e);

		UDecalComponent_GetFadeStartDelay_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.DecalComponent.GetFadeDuration
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UDecalComponent::GetFadeDuration() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf19e0e1b);

		UDecalComponent_GetFadeDuration_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.DecalComponent.GetDecalMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UMaterialInterface*      ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInterface* UDecalComponent::GetDecalMaterial() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb7c6bcdb);

		UDecalComponent_GetDecalMaterial_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.DecalComponent.CreateDynamicMaterialInstance
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInstanceDynamic* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInstanceDynamic* UDecalComponent::CreateDynamicMaterialInstance() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf4065ae8);

		UDecalComponent_CreateDynamicMaterialInstance_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ExponentialHeightFogComponent.SetUpDensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetUpDensity(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd8739ff);

		UExponentialHeightFogComponent_SetUpDensity_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetStartDistance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetStartDistance(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc11834d7);

		UExponentialHeightFogComponent_SetStartDistance_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetIntensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetIntensity(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x657b8ff5);

		UExponentialHeightFogComponent_SetIntensity_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetFogMaxOpacity(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x72bbc5bf);

		UExponentialHeightFogComponent_SetFogMaxOpacity_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetFogInscatteringColor(const struct FLinearColor& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x72b378d6);

		UExponentialHeightFogComponent_SetFogInscatteringColor_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetFogHeightFalloff(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa8c9c71f);

		UExponentialHeightFogComponent_SetFogHeightFalloff_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetFogDensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetFogDensity(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc17e30fe);

		UExponentialHeightFogComponent_SetFogDensity_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetExtendedHeightFallOff
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetExtendedHeightFallOff(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3e7dd6e);

		UExponentialHeightFogComponent_SetExtendedHeightFallOff_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetExtendedHeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetExtendedHeight(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3615f79c);

		UExponentialHeightFogComponent_SetExtendedHeight_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetExtendedFogStartFalloffDistance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetExtendedFogStartFalloffDistance(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe70d37e4);

		UExponentialHeightFogComponent_SetExtendedFogStartFalloffDistance_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetExtendedFogStartDistance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetExtendedFogStartDistance(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x757d2ad0);

		UExponentialHeightFogComponent_SetExtendedFogStartDistance_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetExtendedFogDensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetExtendedFogDensity(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x35eb6239);

		UExponentialHeightFogComponent_SetExtendedFogDensity_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetDownDensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetDownDensity(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa263615e);

		UExponentialHeightFogComponent_SetDownDensity_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetDirectionalInscatteringStartDistance(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5100f092);

		UExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetDirectionalInscatteringExponent(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa29fac38);

		UExponentialHeightFogComponent_SetDirectionalInscatteringExponent_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UExponentialHeightFogComponent::SetDirectionalInscatteringColor(const struct FLinearColor& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2061ffde);

		UExponentialHeightFogComponent_SetDirectionalInscatteringColor_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetShadowDistanceFadeoutFraction(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x29089d);

		UDirectionalLightComponent_SetShadowDistanceFadeoutFraction_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetOcclusionMaskDarkness(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xda45e8a4);

		UDirectionalLightComponent_SetOcclusionMaskDarkness_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetLightShaftOverrideDirection(const struct FVector& NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18a22f81);

		UDirectionalLightComponent_SetLightShaftOverrideDirection_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetEnableLightShaftOcclusion(bool bNewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa4321a52);

		UDirectionalLightComponent_SetEnableLightShaftOcclusion_Params params;
		params.bNewValue = bNewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetDynamicShadowDistanceStationaryLight(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xec8a016a);

		UDirectionalLightComponent_SetDynamicShadowDistanceStationaryLight_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetDynamicShadowDistanceMovableLight(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ac5f74e);

		UDirectionalLightComponent_SetDynamicShadowDistanceMovableLight_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetDynamicShadowCascades
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetDynamicShadowCascades(int NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf47a0f24);

		UDirectionalLightComponent_SetDynamicShadowCascades_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetCascadeTransitionFraction(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x95372c9b);

		UDirectionalLightComponent_SetCascadeTransitionFraction_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UDirectionalLightComponent::SetCascadeDistributionExponent(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30278b8b);

		UDirectionalLightComponent_SetCascadeDistributionExponent_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PointLightComponent.SetSourceRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          bNewValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPointLightComponent::SetSourceRadius(float bNewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3888d625);

		UPointLightComponent_SetSourceRadius_Params params;
		params.bNewValue = bNewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PointLightComponent.SetSourceLength
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewValue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPointLightComponent::SetSourceLength(float NewValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x319c0413);

		UPointLightComponent_SetSourceLength_Params params;
		params.NewValue = NewValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PointLightComponent.SetLightFalloffExponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewLightFalloffExponent        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPointLightComponent::SetLightFalloffExponent(float NewLightFalloffExponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcb57d273);

		UPointLightComponent_SetLightFalloffExponent_Params params;
		params.NewLightFalloffExponent = NewLightFalloffExponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PointLightComponent.SetAttenuationRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewRadius                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPointLightComponent::SetAttenuationRadius(float NewRadius) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2995356);

		UPointLightComponent_SetAttenuationRadius_Params params;
		params.NewRadius = NewRadius;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SpotLightComponent.SetOuterConeAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewOuterConeAngle              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USpotLightComponent::SetOuterConeAngle(float NewOuterConeAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd7d990ad);

		USpotLightComponent_SetOuterConeAngle_Params params;
		params.NewOuterConeAngle = NewOuterConeAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SpotLightComponent.SetInnerConeAngle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewInnerConeAngle              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USpotLightComponent::SetInnerConeAngle(float NewInnerConeAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x38403c46);

		USpotLightComponent_SetInnerConeAngle_Params params;
		params.NewInnerConeAngle = NewInnerConeAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLightComponent.SetOcclusionTint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FColor                  InTint                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void USkyLightComponent::SetOcclusionTint(const struct FColor& InTint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x68c651ef);

		USkyLightComponent_SetOcclusionTint_Params params;
		params.InTint = InTint;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLightComponent.SetMinOcclusion
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InMinOcclusion                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkyLightComponent::SetMinOcclusion(float InMinOcclusion) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2db47122);

		USkyLightComponent_SetMinOcclusion_Params params;
		params.InMinOcclusion = InMinOcclusion;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLightComponent.SetLightColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            NewLightColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkyLightComponent::SetLightColor(const struct FLinearColor& NewLightColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd1de2de4);

		USkyLightComponent_SetLightColor_Params params;
		params.NewLightColor = NewLightColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLightComponent.SetIntensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewIntensity                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkyLightComponent::SetIntensity(float NewIntensity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3cb5324);

		USkyLightComponent_SetIntensity_Params params;
		params.NewIntensity = NewIntensity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLightComponent.SetIndirectLightingIntensity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewIntensity                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkyLightComponent::SetIndirectLightingIntensity(float NewIntensity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xca8b8f22);

		USkyLightComponent_SetIndirectLightingIntensity_Params params;
		params.NewIntensity = NewIntensity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLightComponent.SetCubemapBlend
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTextureCube*            SourceCubemap                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTextureCube*            DestinationCubemap             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InBlendFraction                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkyLightComponent::SetCubemapBlend(class UTextureCube* SourceCubemap, class UTextureCube* DestinationCubemap, float InBlendFraction) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3cd49ccd);

		USkyLightComponent_SetCubemapBlend_Params params;
		params.SourceCubemap = SourceCubemap;
		params.DestinationCubemap = DestinationCubemap;
		params.InBlendFraction = InBlendFraction;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLightComponent.SetCubemap
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTextureCube*            NewCubemap                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkyLightComponent::SetCubemap(class UTextureCube* NewCubemap) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2bd86a64);

		USkyLightComponent_SetCubemap_Params params;
		params.NewCubemap = NewCubemap;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkyLightComponent.RecaptureSky
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USkyLightComponent::RecaptureSky() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3fb1cca5);

		USkyLightComponent_RecaptureSky_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetLinearZLimit
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ELinearConstraintMotion> ConstraintType                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LimitSize                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetLinearZLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5ac5682);

		UPhysicsConstraintComponent_SetLinearZLimit_Params params;
		params.ConstraintType = ConstraintType;
		params.LimitSize = LimitSize;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetLinearYLimit
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ELinearConstraintMotion> ConstraintType                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LimitSize                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetLinearYLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd6649fd7);

		UPhysicsConstraintComponent_SetLinearYLimit_Params params;
		params.ConstraintType = ConstraintType;
		params.LimitSize = LimitSize;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetLinearXLimit
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ELinearConstraintMotion> ConstraintType                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LimitSize                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetLinearXLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x46ed3c70);

		UPhysicsConstraintComponent_SetLinearXLimit_Params params;
		params.ConstraintType = ConstraintType;
		params.LimitSize = LimitSize;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 InVelTarget                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetLinearVelocityTarget(const struct FVector& InVelTarget) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f0923b7);

		UPhysicsConstraintComponent_SetLinearVelocityTarget_Params params;
		params.InVelTarget = InVelTarget;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnableDriveX                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableDriveY                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableDriveZ                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa1d6e044);

		UPhysicsConstraintComponent_SetLinearVelocityDrive_Params params;
		params.bEnableDriveX = bEnableDriveX;
		params.bEnableDriveY = bEnableDriveY;
		params.bEnableDriveZ = bEnableDriveZ;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 InPosTarget                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetLinearPositionTarget(const struct FVector& InPosTarget) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbee321cb);

		UPhysicsConstraintComponent_SetLinearPositionTarget_Params params;
		params.InPosTarget = InPosTarget;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnableDriveX                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableDriveY                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableDriveZ                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18e09508);

		UPhysicsConstraintComponent_SetLinearPositionDrive_Params params;
		params.bEnableDriveX = bEnableDriveX;
		params.bEnableDriveY = bEnableDriveY;
		params.bEnableDriveZ = bEnableDriveZ;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetLinearDriveParams
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InSpring                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InDamping                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InForceLimit                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetLinearDriveParams(float InSpring, float InDamping, float InForceLimit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x91459a7d);

		UPhysicsConstraintComponent_SetLinearDriveParams_Params params;
		params.InSpring = InSpring;
		params.InDamping = InDamping;
		params.InForceLimit = InForceLimit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetDisableCollision
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bDisableCollision              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetDisableCollision(bool bDisableCollision) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x77b5466e);

		UPhysicsConstraintComponent_SetDisableCollision_Params params;
		params.bDisableCollision = bDisableCollision;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EConstraintFrame>  Frame                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 RefPosition                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetConstraintReferencePosition(TEnumAsByte<EConstraintFrame> Frame, const struct FVector& RefPosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x773b931b);

		UPhysicsConstraintComponent_SetConstraintReferencePosition_Params params;
		params.Frame = Frame;
		params.RefPosition = RefPosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EConstraintFrame>  Frame                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PriAxis                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 SecAxis                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetConstraintReferenceOrientation(TEnumAsByte<EConstraintFrame> Frame, const struct FVector& PriAxis, const struct FVector& SecAxis) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd420a980);

		UPhysicsConstraintComponent_SetConstraintReferenceOrientation_Params params;
		params.Frame = Frame;
		params.PriAxis = PriAxis;
		params.SecAxis = SecAxis;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EConstraintFrame>  Frame                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              RefFrame                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetConstraintReferenceFrame(TEnumAsByte<EConstraintFrame> Frame, const struct FTransform& RefFrame) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c39931d);

		UPhysicsConstraintComponent_SetConstraintReferenceFrame_Params params;
		params.Frame = Frame;
		params.RefFrame = RefFrame;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetConstrainedComponents
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component1                     (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   BoneName1                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     Component2                     (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   BoneName2                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetConstrainedComponents(class UPrimitiveComponent* Component1, const struct FName& BoneName1, class UPrimitiveComponent* Component2, const struct FName& BoneName2) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c7c833e);

		UPhysicsConstraintComponent_SetConstrainedComponents_Params params;
		params.Component1 = Component1;
		params.BoneName1 = BoneName1;
		params.Component2 = Component2;
		params.BoneName2 = BoneName2;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 InVelTarget                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetAngularVelocityTarget(const struct FVector& InVelTarget) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf0ccf80a);

		UPhysicsConstraintComponent_SetAngularVelocityTarget_Params params;
		params.InVelTarget = InVelTarget;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnableSwingDrive              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableTwistDrive              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1aa7373);

		UPhysicsConstraintComponent_SetAngularVelocityDrive_Params params;
		params.bEnableSwingDrive = bEnableSwingDrive;
		params.bEnableTwistDrive = bEnableTwistDrive;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EAngularConstraintMotion> ConstraintType                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TwistLimitAngle                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetAngularTwistLimit(TEnumAsByte<EAngularConstraintMotion> ConstraintType, float TwistLimitAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdeb3e6a6);

		UPhysicsConstraintComponent_SetAngularTwistLimit_Params params;
		params.ConstraintType = ConstraintType;
		params.TwistLimitAngle = TwistLimitAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EAngularConstraintMotion> MotionType                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Swing2LimitAngle               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetAngularSwing2Limit(TEnumAsByte<EAngularConstraintMotion> MotionType, float Swing2LimitAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x491e9a45);

		UPhysicsConstraintComponent_SetAngularSwing2Limit_Params params;
		params.MotionType = MotionType;
		params.Swing2LimitAngle = Swing2LimitAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EAngularConstraintMotion> MotionType                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Swing1LimitAngle               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetAngularSwing1Limit(TEnumAsByte<EAngularConstraintMotion> MotionType, float Swing1LimitAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6461ad64);

		UPhysicsConstraintComponent_SetAngularSwing1Limit_Params params;
		params.MotionType = MotionType;
		params.Swing1LimitAngle = Swing1LimitAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRotator                InPosTarget                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetAngularOrientationTarget(const struct FRotator& InPosTarget) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc3edac69);

		UPhysicsConstraintComponent_SetAngularOrientationTarget_Params params;
		params.InPosTarget = InPosTarget;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnableSwingDrive              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEnableTwistDrive              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9e8d18e2);

		UPhysicsConstraintComponent_SetAngularOrientationDrive_Params params;
		params.bEnableSwingDrive = bEnableSwingDrive;
		params.bEnableTwistDrive = bEnableTwistDrive;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.SetAngularDriveParams
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InSpring                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InDamping                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InForceLimit                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::SetAngularDriveParams(float InSpring, float InDamping, float InForceLimit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x47e850e2);

		UPhysicsConstraintComponent_SetAngularDriveParams_Params params;
		params.InSpring = InSpring;
		params.InDamping = InDamping;
		params.InForceLimit = InForceLimit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsConstraintComponent.GetCurrentTwist
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPhysicsConstraintComponent::GetCurrentTwist() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x353db20a);

		UPhysicsConstraintComponent_GetCurrentTwist_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PhysicsConstraintComponent.GetCurrentSwing2
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPhysicsConstraintComponent::GetCurrentSwing2() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf7743865);

		UPhysicsConstraintComponent_GetCurrentSwing2_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PhysicsConstraintComponent.GetCurrentSwing1
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPhysicsConstraintComponent::GetCurrentSwing1() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1d76b2ce);

		UPhysicsConstraintComponent_GetCurrentSwing1_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PhysicsConstraintComponent.GetConstraintForce
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 OutLinearForce                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutAngularForce                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPhysicsConstraintComponent::GetConstraintForce(struct FVector* OutLinearForce, struct FVector* OutAngularForce) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef8a24c);

		UPhysicsConstraintComponent_GetConstraintForce_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutLinearForce != nullptr)
			*OutLinearForce = params.OutLinearForce;
		if (OutAngularForce != nullptr)
			*OutAngularForce = params.OutAngularForce;
	}


	// Function Engine.PhysicsConstraintComponent.BreakConstraint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UPhysicsConstraintComponent::BreakConstraint() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x12470972);

		UPhysicsConstraintComponent_BreakConstraint_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PhysicsSpringComponent.GetSpringRestingPoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPhysicsSpringComponent::GetSpringRestingPoint() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf476db);

		UPhysicsSpringComponent_GetSpringRestingPoint_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PhysicsSpringComponent.GetSpringDirection
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPhysicsSpringComponent::GetSpringDirection() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3eb3121a);

		UPhysicsSpringComponent_GetSpringDirection_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPhysicsSpringComponent::GetSpringCurrentEndPoint() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfec03841);

		UPhysicsSpringComponent_GetSpringCurrentEndPoint_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UPhysicsSpringComponent::GetNormalizedCompressionScalar() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc31f706b);

		UPhysicsSpringComponent_GetNormalizedCompressionScalar_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PostProcessComponent.AddOrUpdateBlendable
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TScriptInterface<class UBlendableInterface> InBlendableObject              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InWeight                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPostProcessComponent::AddOrUpdateBlendable(const TScriptInterface<class UBlendableInterface>& InBlendableObject, float InWeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75a9d95b);

		UPostProcessComponent_AddOrUpdateBlendable_Params params;
		params.InBlendableObject = InBlendableObject;
		params.InWeight = InWeight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ArrowComponent.SetArrowColor_New
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FLinearColor            NewColor                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UArrowComponent::SetArrowColor_New(const struct FLinearColor& NewColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8e0a56ea);

		UArrowComponent_SetArrowColor_New_Params params;
		params.NewColor = NewColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ArrowComponent.SetArrowColor_DEPRECATED
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FColor                  NewColor                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UArrowComponent::SetArrowColor_DEPRECATED(const struct FColor& NewColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd928463b);

		UArrowComponent_SetArrowColor_DEPRECATED_Params params;
		params.NewColor = NewColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BillboardComponent.SetUV
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            NewU                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NewUL                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NewV                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NewVL                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UBillboardComponent::SetUV(int NewU, int NewUL, int NewV, int NewVL) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa0e90cb2);

		UBillboardComponent_SetUV_Params params;
		params.NewU = NewU;
		params.NewUL = NewUL;
		params.NewV = NewV;
		params.NewVL = NewVL;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BillboardComponent.SetSpriteAndUV
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture2D*              NewSprite                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NewU                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NewUL                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NewV                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NewVL                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UBillboardComponent::SetSpriteAndUV(class UTexture2D* NewSprite, int NewU, int NewUL, int NewV, int NewVL) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc742512);

		UBillboardComponent_SetSpriteAndUV_Params params;
		params.NewSprite = NewSprite;
		params.NewU = NewU;
		params.NewUL = NewUL;
		params.NewV = NewV;
		params.NewVL = NewVL;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BillboardComponent.SetSprite
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture2D*              NewSprite                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UBillboardComponent::SetSprite(class UTexture2D* NewSprite) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xff4891f0);

		UBillboardComponent_SetSprite_Params params;
		params.NewSprite = NewSprite;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialBillboardComponent.SetElements
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<struct FMaterialSpriteElement> NewElements                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UMaterialBillboardComponent::SetElements(TArray<struct FMaterialSpriteElement> NewElements) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd788db7f);

		UMaterialBillboardComponent_SetElements_Params params;
		params.NewElements = NewElements;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialBillboardComponent.AddElement
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UCurveFloat*             DistanceToOpacityCurve         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSizeIsInScreenSpace           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BaseSizeX                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BaseSizeY                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UCurveFloat*             DistanceToSizeCurve            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMaterialBillboardComponent::AddElement(class UMaterialInterface* Material, class UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UCurveFloat* DistanceToSizeCurve) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2c5eb113);

		UMaterialBillboardComponent_AddElement_Params params;
		params.Material = Material;
		params.DistanceToOpacityCurve = DistanceToOpacityCurve;
		params.bSizeIsInScreenSpace = bSizeIsInScreenSpace;
		params.BaseSizeX = BaseSizeX;
		params.BaseSizeY = BaseSizeY;
		params.DistanceToSizeCurve = DistanceToSizeCurve;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PoseableMeshComponent.SetBoneTransformByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              InTransform                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<EBoneSpaces>       BoneSpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPoseableMeshComponent::SetBoneTransformByName(const struct FName& BoneName, const struct FTransform& InTransform, TEnumAsByte<EBoneSpaces> BoneSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6a061afa);

		UPoseableMeshComponent_SetBoneTransformByName_Params params;
		params.BoneName = BoneName;
		params.InTransform = InTransform;
		params.BoneSpace = BoneSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PoseableMeshComponent.SetBoneScaleByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InScale3D                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBoneSpaces>       BoneSpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPoseableMeshComponent::SetBoneScaleByName(const struct FName& BoneName, const struct FVector& InScale3D, TEnumAsByte<EBoneSpaces> BoneSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x21de3b5c);

		UPoseableMeshComponent_SetBoneScaleByName_Params params;
		params.BoneName = BoneName;
		params.InScale3D = InScale3D;
		params.BoneSpace = BoneSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PoseableMeshComponent.SetBoneRotationByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                InRotation                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBoneSpaces>       BoneSpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPoseableMeshComponent::SetBoneRotationByName(const struct FName& BoneName, const struct FRotator& InRotation, TEnumAsByte<EBoneSpaces> BoneSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8b673f80);

		UPoseableMeshComponent_SetBoneRotationByName_Params params;
		params.BoneName = BoneName;
		params.InRotation = InRotation;
		params.BoneSpace = BoneSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PoseableMeshComponent.SetBoneLocationByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InLocation                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBoneSpaces>       BoneSpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPoseableMeshComponent::SetBoneLocationByName(const struct FName& BoneName, const struct FVector& InLocation, TEnumAsByte<EBoneSpaces> BoneSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x98cd41b7);

		UPoseableMeshComponent_SetBoneLocationByName_Params params;
		params.BoneName = BoneName;
		params.InLocation = InLocation;
		params.BoneSpace = BoneSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PoseableMeshComponent.ResetBoneTransformByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPoseableMeshComponent::ResetBoneTransformByName(const struct FName& BoneName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76a09c89);

		UPoseableMeshComponent_ResetBoneTransformByName_Params params;
		params.BoneName = BoneName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PoseableMeshComponent.GetBoneTransformByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBoneSpaces>       BoneSpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UPoseableMeshComponent::GetBoneTransformByName(const struct FName& BoneName, TEnumAsByte<EBoneSpaces> BoneSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc591676e);

		UPoseableMeshComponent_GetBoneTransformByName_Params params;
		params.BoneName = BoneName;
		params.BoneSpace = BoneSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PoseableMeshComponent.GetBoneScaleByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBoneSpaces>       BoneSpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPoseableMeshComponent::GetBoneScaleByName(const struct FName& BoneName, TEnumAsByte<EBoneSpaces> BoneSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x70b7bc88);

		UPoseableMeshComponent_GetBoneScaleByName_Params params;
		params.BoneName = BoneName;
		params.BoneSpace = BoneSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PoseableMeshComponent.GetBoneRotationByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBoneSpaces>       BoneSpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UPoseableMeshComponent::GetBoneRotationByName(const struct FName& BoneName, TEnumAsByte<EBoneSpaces> BoneSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaaef7b6c);

		UPoseableMeshComponent_GetBoneRotationByName_Params params;
		params.BoneName = BoneName;
		params.BoneSpace = BoneSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PoseableMeshComponent.GetBoneLocationByName
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   BoneName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBoneSpaces>       BoneSpace                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UPoseableMeshComponent::GetBoneLocationByName(const struct FName& BoneName, TEnumAsByte<EBoneSpaces> BoneSpace) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x112fb033);

		UPoseableMeshComponent_GetBoneLocationByName_Params params;
		params.BoneName = BoneName;
		params.BoneSpace = BoneSpace;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PoseableMeshComponent.CopyPoseFromSkeletalComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USkeletalMeshComponent*  InComponentToCopy              (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void UPoseableMeshComponent::CopyPoseFromSkeletalComponent(class USkeletalMeshComponent* InComponentToCopy) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe0cbc958);

		UPoseableMeshComponent_CopyPoseFromSkeletalComponent_Params params;
		params.InComponentToCopy = InComponentToCopy;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.UpdateMesh
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USplineMeshComponent::UpdateMesh() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2be2d5a2);

		USplineMeshComponent_UpdateMesh_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetStartTangent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 StartTangent                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetStartTangent(const struct FVector& StartTangent, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc6105899);

		USplineMeshComponent_SetStartTangent_Params params;
		params.StartTangent = StartTangent;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetStartScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               StartScale                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetStartScale(const struct FVector2D& StartScale, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe1ebe6a8);

		USplineMeshComponent_SetStartScale_Params params;
		params.StartScale = StartScale;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetStartRoll
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          StartRoll                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetStartRoll(float StartRoll, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x69fb1c57);

		USplineMeshComponent_SetStartRoll_Params params;
		params.StartRoll = StartRoll;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetStartPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 StartPos                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetStartPosition(const struct FVector& StartPos, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf5a61747);

		USplineMeshComponent_SetStartPosition_Params params;
		params.StartPos = StartPos;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetStartOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               StartOffset                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetStartOffset(const struct FVector2D& StartOffset, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x52ace45f);

		USplineMeshComponent_SetStartOffset_Params params;
		params.StartOffset = StartOffset;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetStartAndEnd
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 StartPos                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 StartTangent                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 EndPos                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 EndTangent                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetStartAndEnd(const struct FVector& StartPos, const struct FVector& StartTangent, const struct FVector& EndPos, const struct FVector& EndTangent, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa34dc110);

		USplineMeshComponent_SetStartAndEnd_Params params;
		params.StartPos = StartPos;
		params.StartTangent = StartTangent;
		params.EndPos = EndPos;
		params.EndTangent = EndTangent;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetSplineUpDir
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 InSplineUpDir                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetSplineUpDir(const struct FVector& InSplineUpDir, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2deeb5f);

		USplineMeshComponent_SetSplineUpDir_Params params;
		params.InSplineUpDir = InSplineUpDir;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetForwardAxis
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ESplineMeshAxis>   InForwardAxis                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetForwardAxis(TEnumAsByte<ESplineMeshAxis> InForwardAxis, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x602e7686);

		USplineMeshComponent_SetForwardAxis_Params params;
		params.InForwardAxis = InForwardAxis;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetEndTangent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 EndTangent                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetEndTangent(const struct FVector& EndTangent, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9e32ca74);

		USplineMeshComponent_SetEndTangent_Params params;
		params.EndTangent = EndTangent;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetEndScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               EndScale                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetEndScale(const struct FVector2D& EndScale, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x90ba4485);

		USplineMeshComponent_SetEndScale_Params params;
		params.EndScale = EndScale;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetEndRoll
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          EndRoll                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetEndRoll(float EndRoll, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x84849728);

		USplineMeshComponent_SetEndRoll_Params params;
		params.EndRoll = EndRoll;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetEndPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 EndPos                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetEndPosition(const struct FVector& EndPos, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1e4e6cbc);

		USplineMeshComponent_SetEndPosition_Params params;
		params.EndPos = EndPos;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetEndOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               EndOffset                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetEndOffset(const struct FVector2D& EndOffset, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4622f214);

		USplineMeshComponent_SetEndOffset_Params params;
		params.EndOffset = EndOffset;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetBoundaryMin
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InBoundaryMin                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4fc483a4);

		USplineMeshComponent_SetBoundaryMin_Params params;
		params.InBoundaryMin = InBoundaryMin;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.SetBoundaryMax
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InBoundaryMax                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateMesh                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USplineMeshComponent::SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d288eba);

		USplineMeshComponent_SetBoundaryMax_Params params;
		params.InBoundaryMax = InBoundaryMax;
		params.bUpdateMesh = bUpdateMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SplineMeshComponent.GetStartTangent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineMeshComponent::GetStartTangent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe7f562d);

		USplineMeshComponent_GetStartTangent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetStartScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D USplineMeshComponent::GetStartScale() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdcc788bc);

		USplineMeshComponent_GetStartScale_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetStartRoll
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineMeshComponent::GetStartRoll() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2eae3c1b);

		USplineMeshComponent_GetStartRoll_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetStartPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineMeshComponent::GetStartPosition() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbb96f4d3);

		USplineMeshComponent_GetStartPosition_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetStartOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D USplineMeshComponent::GetStartOffset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6c93c563);

		USplineMeshComponent_GetStartOffset_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetSplineUpDir
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineMeshComponent::GetSplineUpDir() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfccc28b3);

		USplineMeshComponent_GetSplineUpDir_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetForwardAxis
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// TEnumAsByte<ESplineMeshAxis>   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<ESplineMeshAxis> USplineMeshComponent::GetForwardAxis() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x627011d2);

		USplineMeshComponent_GetForwardAxis_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetEndTangent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineMeshComponent::GetEndTangent() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76fc0830);

		USplineMeshComponent_GetEndTangent_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetEndScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D USplineMeshComponent::GetEndScale() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5bc8f6d1);

		USplineMeshComponent_GetEndScale_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetEndRoll
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineMeshComponent::GetEndRoll() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79639044);

		USplineMeshComponent_GetEndRoll_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetEndPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USplineMeshComponent::GetEndPosition() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa11e26a0);

		USplineMeshComponent_GetEndPosition_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetEndOffset
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D USplineMeshComponent::GetEndOffset() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb7f478a0);

		USplineMeshComponent_GetEndOffset_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetBoundaryMin
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineMeshComponent::GetBoundaryMin() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcb8c490);

		USplineMeshComponent_GetBoundaryMin_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SplineMeshComponent.GetBoundaryMax
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USplineMeshComponent::GetBoundaryMax() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb9e155ce);

		USplineMeshComponent_GetBoundaryMax_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystem.ContainsEmitterType
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  TypeData                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UParticleSystem::ContainsEmitterType(class UClass* TypeData) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4a77cc2f);

		UParticleSystem_ContainsEmitterType_Params params;
		params.TypeData = TypeData;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.SetVectorParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x64001ccd);

		UParticleSystemComponent_SetVectorParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetTrailSourceData
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InFirstSocketName              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   InSecondSocketName             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETrailWidthMode>   InWidthMode                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InWidth                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetTrailSourceData(const struct FName& InFirstSocketName, const struct FName& InSecondSocketName, TEnumAsByte<ETrailWidthMode> InWidthMode, float InWidth) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16a56d04);

		UParticleSystemComponent_SetTrailSourceData_Params params;
		params.InFirstSocketName = InFirstSocketName;
		params.InSecondSocketName = InSecondSocketName;
		params.InWidthMode = InWidthMode;
		params.InWidth = InWidth;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetTemplate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UParticleSystem*         NewTemplate                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetTemplate(class UParticleSystem* NewTemplate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfe55b3d3);

		UParticleSystemComponent_SetTemplate_Params params;
		params.NewTemplate = NewTemplate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetMaterialParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetMaterialParameter(const struct FName& ParameterName, class UMaterialInterface* Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76a6ac7);

		UParticleSystemComponent_SetMaterialParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetFloatParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetFloatParameter(const struct FName& ParameterName, float Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8cb1b3c2);

		UParticleSystemComponent_SetFloatParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetEmitterEnable
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   EmitterName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bNewEnableState                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetEmitterEnable(const struct FName& EmitterName, bool bNewEnableState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x271372f4);

		UParticleSystemComponent_SetEmitterEnable_Params params;
		params.EmitterName = EmitterName;
		params.bNewEnableState = bNewEnableState;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetColorParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetColorParameter(const struct FName& ParameterName, const struct FLinearColor& Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1452933f);

		UParticleSystemComponent_SetColorParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetBeamTargetTangent
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewTangentPoint                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TargetIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetBeamTargetTangent(int emitterIndex, const struct FVector& NewTangentPoint, int TargetIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76a4e5f6);

		UParticleSystemComponent_SetBeamTargetTangent_Params params;
		params.emitterIndex = emitterIndex;
		params.NewTangentPoint = NewTangentPoint;
		params.TargetIndex = TargetIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetBeamTargetStrength
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NewTargetStrength              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TargetIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetBeamTargetStrength(int emitterIndex, float NewTargetStrength, int TargetIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76fb94c0);

		UParticleSystemComponent_SetBeamTargetStrength_Params params;
		params.emitterIndex = emitterIndex;
		params.NewTargetStrength = NewTargetStrength;
		params.TargetIndex = TargetIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetBeamTargetPoint
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewTargetPoint                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TargetIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetBeamTargetPoint(int emitterIndex, const struct FVector& NewTargetPoint, int TargetIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x49096153);

		UParticleSystemComponent_SetBeamTargetPoint_Params params;
		params.emitterIndex = emitterIndex;
		params.NewTargetPoint = NewTargetPoint;
		params.TargetIndex = TargetIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetBeamSourceTangent
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewTangentPoint                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            SourceIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetBeamSourceTangent(int emitterIndex, const struct FVector& NewTangentPoint, int SourceIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3c7b8dea);

		UParticleSystemComponent_SetBeamSourceTangent_Params params;
		params.emitterIndex = emitterIndex;
		params.NewTangentPoint = NewTangentPoint;
		params.SourceIndex = SourceIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetBeamSourceStrength
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NewSourceStrength              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            SourceIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetBeamSourceStrength(int emitterIndex, float NewSourceStrength, int SourceIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9f83ad94);

		UParticleSystemComponent_SetBeamSourceStrength_Params params;
		params.emitterIndex = emitterIndex;
		params.NewSourceStrength = NewSourceStrength;
		params.SourceIndex = SourceIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetBeamSourcePoint
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewSourcePoint                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            SourceIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetBeamSourcePoint(int emitterIndex, const struct FVector& NewSourcePoint, int SourceIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x92de826f);

		UParticleSystemComponent_SetBeamSourcePoint_Params params;
		params.emitterIndex = emitterIndex;
		params.NewSourcePoint = NewSourcePoint;
		params.SourceIndex = SourceIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetBeamEndPoint
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewEndPoint                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetBeamEndPoint(int emitterIndex, const struct FVector& NewEndPoint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54377647);

		UParticleSystemComponent_SetBeamEndPoint_Params params;
		params.emitterIndex = emitterIndex;
		params.NewEndPoint = NewEndPoint;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetAutoAttachParams
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         Parent                         (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   SocketName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachLocation>   LocationType                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetAutoAttachParams(class USceneComponent* Parent, const struct FName& SocketName, TEnumAsByte<EAttachLocation> LocationType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x946d8e31);

		UParticleSystemComponent_SetAutoAttachParams_Params params;
		params.Parent = Parent;
		params.SocketName = SocketName;
		params.LocationType = LocationType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetAutoAttachmentParameters
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         Parent                         (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   SocketName                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   LocationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   RotationRule                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachmentRule>   ScaleRule                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetAutoAttachmentParameters(class USceneComponent* Parent, const struct FName& SocketName, TEnumAsByte<EAttachmentRule> LocationRule, TEnumAsByte<EAttachmentRule> RotationRule, TEnumAsByte<EAttachmentRule> ScaleRule) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c027b2b);

		UParticleSystemComponent_SetAutoAttachmentParameters_Params params;
		params.Parent = Parent;
		params.SocketName = SocketName;
		params.LocationRule = LocationRule;
		params.RotationRule = RotationRule;
		params.ScaleRule = ScaleRule;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.SetActorParameter
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  Param                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::SetActorParameter(const struct FName& ParameterName, class AActor* Param) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5bbce2d5);

		UParticleSystemComponent_SetActorParameter_Params params;
		params.ParameterName = ParameterName;
		params.Param = Param;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.GetNumActiveParticles
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UParticleSystemComponent::GetNumActiveParticles() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1fb31ce2);

		UParticleSystemComponent_GetNumActiveParticles_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GetNamedMaterial
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInterface* UParticleSystemComponent::GetNamedMaterial(const struct FName& InName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaa813f3b);

		UParticleSystemComponent_GetNamedMaterial_Params params;
		params.InName = InName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GetBeamTargetTangent
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TargetIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutTangentPoint                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UParticleSystemComponent::GetBeamTargetTangent(int emitterIndex, int TargetIndex, struct FVector* OutTangentPoint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x88f96fca);

		UParticleSystemComponent_GetBeamTargetTangent_Params params;
		params.emitterIndex = emitterIndex;
		params.TargetIndex = TargetIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutTangentPoint != nullptr)
			*OutTangentPoint = params.OutTangentPoint;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GetBeamTargetStrength
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TargetIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutTargetStrength              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UParticleSystemComponent::GetBeamTargetStrength(int emitterIndex, int TargetIndex, float* OutTargetStrength) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x954eb7f4);

		UParticleSystemComponent_GetBeamTargetStrength_Params params;
		params.emitterIndex = emitterIndex;
		params.TargetIndex = TargetIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutTargetStrength != nullptr)
			*OutTargetStrength = params.OutTargetStrength;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GetBeamTargetPoint
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            TargetIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutTargetPoint                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UParticleSystemComponent::GetBeamTargetPoint(int emitterIndex, int TargetIndex, struct FVector* OutTargetPoint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5781274f);

		UParticleSystemComponent_GetBeamTargetPoint_Params params;
		params.emitterIndex = emitterIndex;
		params.TargetIndex = TargetIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutTargetPoint != nullptr)
			*OutTargetPoint = params.OutTargetPoint;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GetBeamSourceTangent
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            SourceIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutTangentPoint                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UParticleSystemComponent::GetBeamSourceTangent(int emitterIndex, int SourceIndex, struct FVector* OutTangentPoint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaa725d16);

		UParticleSystemComponent_GetBeamSourceTangent_Params params;
		params.emitterIndex = emitterIndex;
		params.SourceIndex = SourceIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutTangentPoint != nullptr)
			*OutTangentPoint = params.OutTangentPoint;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GetBeamSourceStrength
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            SourceIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutSourceStrength              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UParticleSystemComponent::GetBeamSourceStrength(int emitterIndex, int SourceIndex, float* OutSourceStrength) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x42ad9560);

		UParticleSystemComponent_GetBeamSourceStrength_Params params;
		params.emitterIndex = emitterIndex;
		params.SourceIndex = SourceIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutSourceStrength != nullptr)
			*OutSourceStrength = params.OutSourceStrength;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GetBeamSourcePoint
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            SourceIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutSourcePoint                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UParticleSystemComponent::GetBeamSourcePoint(int emitterIndex, int SourceIndex, struct FVector* OutSourcePoint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8eb2c573);

		UParticleSystemComponent_GetBeamSourcePoint_Params params;
		params.emitterIndex = emitterIndex;
		params.SourceIndex = SourceIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutSourcePoint != nullptr)
			*OutSourcePoint = params.OutSourcePoint;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GetBeamEndPoint
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            emitterIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutEndPoint                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UParticleSystemComponent::GetBeamEndPoint(int emitterIndex, struct FVector* OutEndPoint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc6064053);

		UParticleSystemComponent_GetBeamEndPoint_Params params;
		params.emitterIndex = emitterIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutEndPoint != nullptr)
			*OutEndPoint = params.OutEndPoint;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.GenerateParticleEvent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InEventName                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InEmitterTime                  (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InLocation                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InDirection                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InVelocity                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::GenerateParticleEvent(const struct FName& InEventName, float InEmitterTime, const struct FVector& InLocation, const struct FVector& InDirection, const struct FVector& InVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x46a2a0dc);

		UParticleSystemComponent_GenerateParticleEvent_Params params;
		params.InEventName = InEventName;
		params.InEmitterTime = InEmitterTime;
		params.InLocation = InLocation;
		params.InDirection = InDirection;
		params.InVelocity = InVelocity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.EndTrails
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UParticleSystemComponent::EndTrails() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x516f1dd5);

		UParticleSystemComponent_EndTrails_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      SourceMaterial                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInstanceDynamic* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInstanceDynamic* UParticleSystemComponent::CreateNamedDynamicMaterialInstance(const struct FName& InName, class UMaterialInterface* SourceMaterial) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x31e5fca7);

		UParticleSystemComponent_CreateNamedDynamicMaterialInstance_Params params;
		params.InName = InName;
		params.SourceMaterial = SourceMaterial;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.ParticleSystemComponent.BeginTrails
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   InFirstSocketName              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   InSecondSocketName             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETrailWidthMode>   InWidthMode                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InWidth                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UParticleSystemComponent::BeginTrails(const struct FName& InFirstSocketName, const struct FName& InSecondSocketName, TEnumAsByte<ETrailWidthMode> InWidthMode, float InWidth) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x364fe591);

		UParticleSystemComponent_BeginTrails_Params params;
		params.InFirstSocketName = InFirstSocketName;
		params.InSecondSocketName = InSecondSocketName;
		params.InWidthMode = InWidthMode;
		params.InWidth = InWidth;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CapsuleComponent.SetCapsuleSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InRadius                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InHalfHeight                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateOverlaps                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCapsuleComponent::SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x73023953);

		UCapsuleComponent_SetCapsuleSize_Params params;
		params.InRadius = InRadius;
		params.InHalfHeight = InHalfHeight;
		params.bUpdateOverlaps = bUpdateOverlaps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CapsuleComponent.SetCapsuleRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateOverlaps                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCapsuleComponent::SetCapsuleRadius(float Radius, bool bUpdateOverlaps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4beeb942);

		UCapsuleComponent_SetCapsuleRadius_Params params;
		params.Radius = Radius;
		params.bUpdateOverlaps = bUpdateOverlaps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CapsuleComponent.SetCapsuleHalfHeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateOverlaps                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCapsuleComponent::SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b7948ca);

		UCapsuleComponent_SetCapsuleHalfHeight_Params params;
		params.HalfHeight = HalfHeight;
		params.bUpdateOverlaps = bUpdateOverlaps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize_WithoutHemisphere
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          OutRadius                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutHalfHeightWithoutHemisphere (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCapsuleComponent::GetUnscaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa97dab23);

		UCapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutRadius != nullptr)
			*OutRadius = params.OutRadius;
		if (OutHalfHeightWithoutHemisphere != nullptr)
			*OutHalfHeightWithoutHemisphere = params.OutHalfHeightWithoutHemisphere;
	}


	// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          OutRadius                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutHalfHeight                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCapsuleComponent::GetUnscaledCapsuleSize(float* OutRadius, float* OutHalfHeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef3f22ce);

		UCapsuleComponent_GetUnscaledCapsuleSize_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutRadius != nullptr)
			*OutRadius = params.OutRadius;
		if (OutHalfHeight != nullptr)
			*OutHalfHeight = params.OutHalfHeight;
	}


	// Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCapsuleComponent::GetUnscaledCapsuleRadius() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4e1c2c3b);

		UCapsuleComponent_GetUnscaledCapsuleRadius_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCapsuleComponent::GetUnscaledCapsuleHalfHeight_WithoutHemisphere() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb18262ba);

		UCapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCapsuleComponent::GetUnscaledCapsuleHalfHeight() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2e5903f);

		UCapsuleComponent_GetUnscaledCapsuleHalfHeight_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CapsuleComponent.GetShapeScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCapsuleComponent::GetShapeScale() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f26914c);

		UCapsuleComponent_GetShapeScale_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CapsuleComponent.GetScaledCapsuleSize_WithoutHemisphere
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          OutRadius                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutHalfHeightWithoutHemisphere (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCapsuleComponent::GetScaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc9b5c0a0);

		UCapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutRadius != nullptr)
			*OutRadius = params.OutRadius;
		if (OutHalfHeightWithoutHemisphere != nullptr)
			*OutHalfHeightWithoutHemisphere = params.OutHalfHeightWithoutHemisphere;
	}


	// Function Engine.CapsuleComponent.GetScaledCapsuleSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          OutRadius                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutHalfHeight                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCapsuleComponent::GetScaledCapsuleSize(float* OutRadius, float* OutHalfHeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa3d21971);

		UCapsuleComponent_GetScaledCapsuleSize_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutRadius != nullptr)
			*OutRadius = params.OutRadius;
		if (OutHalfHeight != nullptr)
			*OutHalfHeight = params.OutHalfHeight;
	}


	// Function Engine.CapsuleComponent.GetScaledCapsuleRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCapsuleComponent::GetScaledCapsuleRadius() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79541b0);

		UCapsuleComponent_GetScaledCapsuleRadius_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCapsuleComponent::GetScaledCapsuleHalfHeight_WithoutHemisphere() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbf809519);

		UCapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UCapsuleComponent::GetScaledCapsuleHalfHeight() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x925cf050);

		UCapsuleComponent_GetScaledCapsuleHalfHeight_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SphereComponent.SetSphereRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InSphereRadius                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUpdateOverlaps                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USphereComponent::SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xacc8fc92);

		USphereComponent_SetSphereRadius_Params params;
		params.InSphereRadius = InSphereRadius;
		params.bUpdateOverlaps = bUpdateOverlaps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SphereComponent.GetUnscaledSphereRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USphereComponent::GetUnscaledSphereRadius() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xee5bfd69);

		USphereComponent_GetUnscaledSphereRadius_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SphereComponent.GetShapeScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USphereComponent::GetShapeScale() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x456dc548);

		USphereComponent_GetShapeScale_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SphereComponent.GetScaledSphereRadius
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float USphereComponent::GetScaledSphereRadius() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96c4a5f4);

		USphereComponent_GetScaledSphereRadius_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.SubDSurfaceComponent.SetMesh
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USubDSurface*            NewMesh                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool USubDSurfaceComponent::SetMesh(class USubDSurface* NewMesh) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc4e26002);

		USubDSurfaceComponent_SetMesh_Params params;
		params.NewMesh = NewMesh;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TextRenderComponent.SetYScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetYScale(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2eeae080);

		UTextRenderComponent_SetYScale_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetXScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetXScale(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b30bbeb);

		UTextRenderComponent_SetXScale_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetWorldSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetWorldSize(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ec31894);

		UTextRenderComponent_SetWorldSize_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetVertSpacingAdjust
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetVertSpacingAdjust(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe1d4596a);

		UTextRenderComponent_SetVertSpacingAdjust_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetVerticalAlignment
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EVerticalTextAligment> Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetVerticalAlignment(TEnumAsByte<EVerticalTextAligment> Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x80752626);

		UTextRenderComponent_SetVerticalAlignment_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetTextRenderColor
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FColor                  Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetTextRenderColor(const struct FColor& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x19b2fd15);

		UTextRenderComponent_SetTextRenderColor_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetTextMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetTextMaterial(class UMaterialInterface* Material) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb90b476b);

		UTextRenderComponent_SetTextMaterial_Params params;
		params.Material = Material;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetText
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 Value                          (CPF_Parm, CPF_ZeroConstructor)

	void UTextRenderComponent::SetText(const struct FString& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96328dd0);

		UTextRenderComponent_SetText_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetHorizSpacingAdjust
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetHorizSpacingAdjust(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf054f7b9);

		UTextRenderComponent_SetHorizSpacingAdjust_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetHorizontalAlignment
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EHorizTextAligment> Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetHorizontalAlignment(TEnumAsByte<EHorizTextAligment> Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xee4de420);

		UTextRenderComponent_SetHorizontalAlignment_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.SetFont
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UFont*                   Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTextRenderComponent::SetFont(class UFont* Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf8637d1a);

		UTextRenderComponent_SetFont_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.K2_SetText
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FText                   Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UTextRenderComponent::K2_SetText(const struct FText& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9236f7d0);

		UTextRenderComponent_K2_SetText_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TextRenderComponent.GetTextWorldSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UTextRenderComponent::GetTextWorldSize() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18732fe3);

		UTextRenderComponent_GetTextWorldSize_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TextRenderComponent.GetTextLocalSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UTextRenderComponent::GetTextLocalSize() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc6927072);

		UTextRenderComponent_GetTextLocalSize_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.VectorFieldComponent.SetIntensity
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewIntensity                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UVectorFieldComponent::SetIntensity(float NewIntensity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9d94a940);

		UVectorFieldComponent_SetIntensity_Params params;
		params.NewIntensity = NewIntensity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.RadialForceComponent.RemoveObjectTypeToAffect
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EObjectTypeQuery>  ObjectType                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void URadialForceComponent::RemoveObjectTypeToAffect(TEnumAsByte<EObjectTypeQuery> ObjectType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x460d737);

		URadialForceComponent_RemoveObjectTypeToAffect_Params params;
		params.ObjectType = ObjectType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.RadialForceComponent.FireImpulse
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void URadialForceComponent::FireImpulse() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x27c6c2e7);

		URadialForceComponent_FireImpulse_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.RadialForceComponent.AddObjectTypeToAffect
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EObjectTypeQuery>  ObjectType                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void URadialForceComponent::AddObjectTypeToAffect(TEnumAsByte<EObjectTypeQuery> ObjectType) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6e3e36fa);

		URadialForceComponent_AddObjectTypeToAffect_Params params;
		params.ObjectType = ObjectType;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SceneCaptureComponentCube.CaptureScene
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void USceneCaptureComponentCube::CaptureScene() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d3715ab);

		USceneCaptureComponentCube_CaptureScene_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerComponent.SetUVRect
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FBox2D                  InUVRect                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStereoLayerComponent::SetUVRect(const struct FBox2D& InUVRect) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd0c9dc6);

		UStereoLayerComponent_SetUVRect_Params params;
		params.InUVRect = InUVRect;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerComponent.SetTexture
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture*                InTexture                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStereoLayerComponent::SetTexture(class UTexture* InTexture) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4d20513e);

		UStereoLayerComponent_SetTexture_Params params;
		params.InTexture = InTexture;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerComponent.SetQuadSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               InQuadSize                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStereoLayerComponent::SetQuadSize(const struct FVector2D& InQuadSize) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5269948f);

		UStereoLayerComponent_SetQuadSize_Params params;
		params.InQuadSize = InQuadSize;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerComponent.SetPriority
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            InPriority                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStereoLayerComponent::SetPriority(int InPriority) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x97f3e159);

		UStereoLayerComponent_SetPriority_Params params;
		params.InPriority = InPriority;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerComponent.MarkTextureForUpdate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UStereoLayerComponent::MarkTextureForUpdate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2b473dbd);

		UStereoLayerComponent_MarkTextureForUpdate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerComponent.GetUVRect
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FBox2D                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FBox2D UStereoLayerComponent::GetUVRect() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b3c89b2);

		UStereoLayerComponent_GetUVRect_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StereoLayerComponent.GetTexture
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class UTexture*                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UTexture* UStereoLayerComponent::GetTexture() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfe8124ea);

		UStereoLayerComponent_GetTexture_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StereoLayerComponent.GetQuadSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UStereoLayerComponent::GetQuadSize() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdefc06f3);

		UStereoLayerComponent_GetQuadSize_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StereoLayerComponent.GetPriority
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UStereoLayerComponent::GetPriority() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc47a20d5);

		UStereoLayerComponent_GetPriority_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TimelineComponent.Stop
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UTimelineComponent::Stop() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30ee237);

		UTimelineComponent_Stop_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetVectorCurve
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UCurveVector*            NewVectorCurve                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   VectorTrackName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetVectorCurve(class UCurveVector* NewVectorCurve, const struct FName& VectorTrackName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x48003b9);

		UTimelineComponent_SetVectorCurve_Params params;
		params.NewVectorCurve = NewVectorCurve;
		params.VectorTrackName = VectorTrackName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetTimelineLengthMode
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ETimelineLengthMode> NewLengthMode                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetTimelineLengthMode(TEnumAsByte<ETimelineLengthMode> NewLengthMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2e2a5abd);

		UTimelineComponent_SetTimelineLengthMode_Params params;
		params.NewLengthMode = NewLengthMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetTimelineLength
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewLength                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetTimelineLength(float NewLength) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa31d7584);

		UTimelineComponent_SetTimelineLength_Params params;
		params.NewLength = NewLength;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetPlayRate
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewRate                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetPlayRate(float NewRate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4e7b4449);

		UTimelineComponent_SetPlayRate_Params params;
		params.NewRate = NewRate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetPlaybackPosition
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewPosition                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFireEvents                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFireUpdate                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x241d854b);

		UTimelineComponent_SetPlaybackPosition_Params params;
		params.NewPosition = NewPosition;
		params.bFireEvents = bFireEvents;
		params.bFireUpdate = bFireUpdate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetNewTime
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewTime                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetNewTime(float NewTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76b32236);

		UTimelineComponent_SetNewTime_Params params;
		params.NewTime = NewTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetLooping
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewLooping                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetLooping(bool bNewLooping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6cf7da75);

		UTimelineComponent_SetLooping_Params params;
		params.bNewLooping = bNewLooping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetLinearColorCurve
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UCurveLinearColor*       NewLinearColorCurve            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   LinearColorTrackName           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetLinearColorCurve(class UCurveLinearColor* NewLinearColorCurve, const struct FName& LinearColorTrackName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x63284d48);

		UTimelineComponent_SetLinearColorCurve_Params params;
		params.NewLinearColorCurve = NewLinearColorCurve;
		params.LinearColorTrackName = LinearColorTrackName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetIgnoreTimeDilation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bNewIgnoreTimeDilation         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe130bdee);

		UTimelineComponent_SetIgnoreTimeDilation_Params params;
		params.bNewIgnoreTimeDilation = bNewIgnoreTimeDilation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.SetFloatCurve
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UCurveFloat*             NewFloatCurve                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   FloatTrackName                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UTimelineComponent::SetFloatCurve(class UCurveFloat* NewFloatCurve, const struct FName& FloatTrackName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x64dc7c6a);

		UTimelineComponent_SetFloatCurve_Params params;
		params.NewFloatCurve = NewFloatCurve;
		params.FloatTrackName = FloatTrackName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.ReverseFromEnd
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UTimelineComponent::ReverseFromEnd() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3a397986);

		UTimelineComponent_ReverseFromEnd_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.Reverse
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UTimelineComponent::Reverse() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb8e36d77);

		UTimelineComponent_Reverse_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.PlayFromStart
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UTimelineComponent::PlayFromStart() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x149eae27);

		UTimelineComponent_PlayFromStart_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.Play
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UTimelineComponent::Play() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ebc5181);

		UTimelineComponent_Play_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.OnRep_Timeline
	// (FUNC_Final, FUNC_Native, FUNC_Public)

	void UTimelineComponent::OnRep_Timeline() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc90bf225);

		UTimelineComponent_OnRep_Timeline_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TimelineComponent.IsReversing
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UTimelineComponent::IsReversing() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc929932);

		UTimelineComponent_IsReversing_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TimelineComponent.IsPlaying
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UTimelineComponent::IsPlaying() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4a474287);

		UTimelineComponent_IsPlaying_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TimelineComponent.IsLooping
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UTimelineComponent::IsLooping() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb368a1f);

		UTimelineComponent_IsLooping_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TimelineComponent.GetTimelineLength
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UTimelineComponent::GetTimelineLength() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x23322fb8);

		UTimelineComponent_GetTimelineLength_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TimelineComponent.GetPlayRate
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UTimelineComponent::GetPlayRate() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf2343add);

		UTimelineComponent_GetPlayRate_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TimelineComponent.GetPlaybackPosition
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UTimelineComponent::GetPlaybackPosition() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd644721f);

		UTimelineComponent_GetPlaybackPosition_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TimelineComponent.GetIgnoreTimeDilation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UTimelineComponent::GetIgnoreTimeDilation() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xed9bc6ca);

		UTimelineComponent_GetIgnoreTimeDilation_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimSequenceBase.GetPlayLength
	// (FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimSequenceBase::GetPlayLength() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf27a400);

		UAnimSequenceBase_GetPlayLength_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimSingleNodeInstance.StopAnim
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UAnimSingleNodeInstance::StopAnim() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef196896);

		UAnimSingleNodeInstance_StopAnim_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetReverse
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bInReverse                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetReverse(bool bInReverse) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x38eaef9b);

		UAnimSingleNodeInstance_SetReverse_Params params;
		params.bInReverse = bInReverse;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetPreviewCurveOverride
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   PoseName                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bRemoveIfZero                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetPreviewCurveOverride(const struct FName& PoseName, float Value, bool bRemoveIfZero) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6054ff46);

		UAnimSingleNodeInstance_SetPreviewCurveOverride_Params params;
		params.PoseName = PoseName;
		params.Value = Value;
		params.bRemoveIfZero = bRemoveIfZero;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetPositionWithPreviousTime
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InPosition                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPreviousTime                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFireNotifies                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x67184202);

		UAnimSingleNodeInstance_SetPositionWithPreviousTime_Params params;
		params.InPosition = InPosition;
		params.InPreviousTime = InPreviousTime;
		params.bFireNotifies = bFireNotifies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetPosition
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InPosition                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFireNotifies                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetPosition(float InPosition, bool bFireNotifies) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcbb4bec2);

		UAnimSingleNodeInstance_SetPosition_Params params;
		params.InPosition = InPosition;
		params.bFireNotifies = bFireNotifies;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetPlayRate
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          InPlayRate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetPlayRate(float InPlayRate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6d8b68b7);

		UAnimSingleNodeInstance_SetPlayRate_Params params;
		params.InPlayRate = InPlayRate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetPlaying
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bIsPlaying                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetPlaying(bool bIsPlaying) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x36b51d23);

		UAnimSingleNodeInstance_SetPlaying_Params params;
		params.bIsPlaying = bIsPlaying;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetLooping
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bIsLooping                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetLooping(bool bIsLooping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x98b67c5b);

		UAnimSingleNodeInstance_SetLooping_Params params;
		params.bIsLooping = bIsLooping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 InBlendInput                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetBlendSpaceInput(const struct FVector& InBlendInput) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa7738ce2);

		UAnimSingleNodeInstance_SetBlendSpaceInput_Params params;
		params.InBlendInput = InBlendInput;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.SetAnimationAsset
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UAnimationAsset*         NewAsset                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bIsLooping                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPlayRate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::SetAnimationAsset(class UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x10fdc445);

		UAnimSingleNodeInstance_SetAnimationAsset_Params params;
		params.NewAsset = NewAsset;
		params.bIsLooping = bIsLooping;
		params.InPlayRate = InPlayRate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.PlayAnim
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bIsLooping                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPlayRate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InStartPosition                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UAnimSingleNodeInstance::PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe80691bc);

		UAnimSingleNodeInstance_PlayAnim_Params params;
		params.bIsLooping = bIsLooping;
		params.InPlayRate = InPlayRate;
		params.InStartPosition = InStartPosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.AnimSingleNodeInstance.GetLength
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UAnimSingleNodeInstance::GetLength() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x820deb67);

		UAnimSingleNodeInstance_GetLength_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.VehicleAnimInstance.GetVehicle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AWheeledVehicle*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AWheeledVehicle* UVehicleAnimInstance::GetVehicle() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcdbdcc33);

		UVehicleAnimInstance_GetVehicle_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimNotifyState.Received_NotifyTick
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// class USkeletalMeshComponent*  MeshComp                       (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// class UAnimSequenceBase*       Animation                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FrameDeltaTime                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimNotifyState::Received_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4f150ee4);

		UAnimNotifyState_Received_NotifyTick_Params params;
		params.MeshComp = MeshComp;
		params.Animation = Animation;
		params.FrameDeltaTime = FrameDeltaTime;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimNotifyState.Received_NotifyEnd
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// class USkeletalMeshComponent*  MeshComp                       (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// class UAnimSequenceBase*       Animation                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimNotifyState::Received_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdb174e36);

		UAnimNotifyState_Received_NotifyEnd_Params params;
		params.MeshComp = MeshComp;
		params.Animation = Animation;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimNotifyState.Received_NotifyBegin
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// class USkeletalMeshComponent*  MeshComp                       (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// class UAnimSequenceBase*       Animation                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TotalDuration                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAnimNotifyState::Received_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6738062);

		UAnimNotifyState_Received_NotifyBegin_Params params;
		params.MeshComp = MeshComp;
		params.Animation = Animation;
		params.TotalDuration = TotalDuration;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimNotifyState.GetNotifyName
	// (FUNC_Native, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UAnimNotifyState::GetNotifyName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c1faa5a);

		UAnimNotifyState_GetNotifyName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AnimNotifyState_Trail.OverridePSTemplate
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent, FUNC_Const)
	// Parameters:
	// class USkeletalMeshComponent*  MeshComp                       (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// class UAnimSequenceBase*       Animation                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UParticleSystem*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UParticleSystem* UAnimNotifyState_Trail::OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc16335a);

		UAnimNotifyState_Trail_OverridePSTemplate_Params params;
		params.MeshComp = MeshComp;
		params.Animation = Animation;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AvoidanceManager.RegisterMovementComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMovementComponent*      MovementComp                   (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// float                          AvoidanceWeight                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UAvoidanceManager::RegisterMovementComponent(class UMovementComponent* MovementComp, float AvoidanceWeight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37ae08a7);

		UAvoidanceManager_RegisterMovementComponent_Params params;
		params.MovementComp = MovementComp;
		params.AvoidanceWeight = AvoidanceWeight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AvoidanceManager.GetObjectCount
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UAvoidanceManager::GetObjectCount() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd5297408);

		UAvoidanceManager_GetObjectCount_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AvoidanceManager.GetNewAvoidanceUID
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UAvoidanceManager::GetNewAvoidanceUID() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf109c78);

		UAvoidanceManager_GetNewAvoidanceUID_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AvoidanceManager.GetAvoidanceVelocityIgnoringUID
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FNavAvoidanceData       AvoidanceData                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            IgnoreThisUID                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UAvoidanceManager::GetAvoidanceVelocityIgnoringUID(const struct FNavAvoidanceData& AvoidanceData, float DeltaTime, int IgnoreThisUID) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4ad8e2f4);

		UAvoidanceManager_GetAvoidanceVelocityIgnoringUID_Params params;
		params.AvoidanceData = AvoidanceData;
		params.DeltaTime = DeltaTime;
		params.IgnoreThisUID = IgnoreThisUID;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UMovementComponent*      MovementComp                   (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UAvoidanceManager::GetAvoidanceVelocityForComponent(class UMovementComponent* MovementComp) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x38300723);

		UAvoidanceManager_GetAvoidanceVelocityForComponent_Params params;
		params.MovementComp = MovementComp;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.AvoidanceManager.GetAvoidanceVelocity
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FNavAvoidanceData       AvoidanceData                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UAvoidanceManager::GetAvoidanceVelocity(const struct FNavAvoidanceData& AvoidanceData, float DeltaTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c98d0e5);

		UAvoidanceManager_GetAvoidanceVelocity_Params params;
		params.AvoidanceData = AvoidanceData;
		params.DeltaTime = DeltaTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// DelegateFunction Engine.PlatformGameInstance.PlatformScreenOrientationChangedDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)
	// Parameters:
	// TEnumAsByte<EScreenOrientation> inScreenOrientation            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPlatformGameInstance::PlatformScreenOrientationChangedDelegate__DelegateSignature(TEnumAsByte<EScreenOrientation> inScreenOrientation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeef68d3b);

		UPlatformGameInstance_PlatformScreenOrientationChangedDelegate__DelegateSignature_Params params;
		params.inScreenOrientation = inScreenOrientation;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.PlatformGameInstance.PlatformRegisteredForUserNotificationsDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)
	// Parameters:
	// int                            inInt                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPlatformGameInstance::PlatformRegisteredForUserNotificationsDelegate__DelegateSignature(int inInt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7dd7ba39);

		UPlatformGameInstance_PlatformRegisteredForUserNotificationsDelegate__DelegateSignature_Params params;
		params.inInt = inInt;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.PlatformGameInstance.PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)
	// Parameters:
	// TArray<unsigned char>          inArray                        (CPF_Parm, CPF_ZeroConstructor)

	void UPlatformGameInstance::PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature(TArray<unsigned char> inArray) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b53a92);

		UPlatformGameInstance_PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature_Params params;
		params.inArray = inArray;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.PlatformGameInstance.PlatformReceivedRemoteNotificationDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)

	void UPlatformGameInstance::PlatformReceivedRemoteNotificationDelegate__DelegateSignature(const struct FString& inString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x86d039f);

		UPlatformGameInstance_PlatformReceivedRemoteNotificationDelegate__DelegateSignature_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.PlatformGameInstance.PlatformReceivedLocalNotificationDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// int                            inInt                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPlatformGameInstance::PlatformReceivedLocalNotificationDelegate__DelegateSignature(const struct FString& inString, int inInt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x25b24bc6);

		UPlatformGameInstance_PlatformReceivedLocalNotificationDelegate__DelegateSignature_Params params;
		params.inString = inString;
		params.inInt = inInt;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.PlatformGameInstance.PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)

	void UPlatformGameInstance::PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature(const struct FString& inString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ba63f0f);

		UPlatformGameInstance_PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.PlatformGameInstance.PlatformDelegate__DelegateSignature
	// (FUNC_MulticastDelegate, FUNC_Public, FUNC_Delegate)

	void UPlatformGameInstance::PlatformDelegate__DelegateSignature() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa876398d);

		UPlatformGameInstance_PlatformDelegate__DelegateSignature_Params params;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationFromNow
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// int                            inSecondsFromNow               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   Title                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   Body                           (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   Action                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FString                 ActivationEvent                (CPF_Parm, CPF_ZeroConstructor)

	void UBlueprintPlatformLibrary::STATIC_ScheduleLocalNotificationFromNow(int inSecondsFromNow, const struct FText& Title, const struct FText& Body, const struct FText& Action, const struct FString& ActivationEvent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18df1acb);

		UBlueprintPlatformLibrary_ScheduleLocalNotificationFromNow_Params params;
		params.inSecondsFromNow = inSecondsFromNow;
		params.Title = Title;
		params.Body = Body;
		params.Action = Action;
		params.ActivationEvent = ActivationEvent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationAtTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FDateTime               FireDateTime                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           LocalTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   Title                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   Body                           (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   Action                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FString                 ActivationEvent                (CPF_Parm, CPF_ZeroConstructor)

	void UBlueprintPlatformLibrary::STATIC_ScheduleLocalNotificationAtTime(const struct FDateTime& FireDateTime, bool LocalTime, const struct FText& Title, const struct FText& Body, const struct FText& Action, const struct FString& ActivationEvent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f4975dd);

		UBlueprintPlatformLibrary_ScheduleLocalNotificationAtTime_Params params;
		params.FireDateTime = FireDateTime;
		params.LocalTime = LocalTime;
		params.Title = Title;
		params.Body = Body;
		params.Action = Action;
		params.ActivationEvent = ActivationEvent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintPlatformLibrary.GetLaunchNotification
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           NotificationLaunchedApp        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ActivationEvent                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// int                            FireDate                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UBlueprintPlatformLibrary::STATIC_GetLaunchNotification(bool* NotificationLaunchedApp, struct FString* ActivationEvent, int* FireDate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfbd56b24);

		UBlueprintPlatformLibrary_GetLaunchNotification_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (NotificationLaunchedApp != nullptr)
			*NotificationLaunchedApp = params.NotificationLaunchedApp;
		if (ActivationEvent != nullptr)
			*ActivationEvent = params.ActivationEvent;
		if (FireDate != nullptr)
			*FireDate = params.FireDate;
	}


	// Function Engine.BlueprintPlatformLibrary.ClearAllLocalNotifications
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UBlueprintPlatformLibrary::STATIC_ClearAllLocalNotifications() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85911c8f);

		UBlueprintPlatformLibrary_ClearAllLocalNotifications_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintPlatformLibrary.CancelLocalNotification
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 ActivationEvent                (CPF_Parm, CPF_ZeroConstructor)

	void UBlueprintPlatformLibrary::STATIC_CancelLocalNotification(const struct FString& ActivationEvent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ad9f8ba);

		UBlueprintPlatformLibrary_CancelLocalNotification_Params params;
		params.ActivationEvent = ActivationEvent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintSetLibrary.Set_Union
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)

	void UBlueprintSetLibrary::STATIC_Set_Union() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x329230eb);

		UBlueprintSetLibrary_Set_Union_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintSetLibrary.Set_ToArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    Result                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UBlueprintSetLibrary::STATIC_Set_ToArray(TArray<int>* Result) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcd203fd4);

		UBlueprintSetLibrary_Set_ToArray_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Result != nullptr)
			*Result = params.Result;
	}


	// Function Engine.BlueprintSetLibrary.Set_RemoveItems
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    Items                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UBlueprintSetLibrary::STATIC_Set_RemoveItems(TArray<int> Items) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x21b2cbfe);

		UBlueprintSetLibrary_Set_RemoveItems_Params params;
		params.Items = Items;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintSetLibrary.Set_Remove
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Item                           (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UBlueprintSetLibrary::STATIC_Set_Remove(int Item) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xceb3a57a);

		UBlueprintSetLibrary_Set_Remove_Params params;
		params.Item = Item;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.BlueprintSetLibrary.Set_Length
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UBlueprintSetLibrary::STATIC_Set_Length() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xed3242da);

		UBlueprintSetLibrary_Set_Length_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.BlueprintSetLibrary.Set_Intersection
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)

	void UBlueprintSetLibrary::STATIC_Set_Intersection() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x678c7415);

		UBlueprintSetLibrary_Set_Intersection_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintSetLibrary.Set_Difference
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)

	void UBlueprintSetLibrary::STATIC_Set_Difference() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9b804243);

		UBlueprintSetLibrary_Set_Difference_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintSetLibrary.Set_Contains
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ItemToFind                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UBlueprintSetLibrary::STATIC_Set_Contains(int ItemToFind) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x264f80f5);

		UBlueprintSetLibrary_Set_Contains_Params params;
		params.ItemToFind = ItemToFind;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.BlueprintSetLibrary.Set_Clear
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)

	void UBlueprintSetLibrary::STATIC_Set_Clear() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89761d39);

		UBlueprintSetLibrary_Set_Clear_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintSetLibrary.Set_AddItems
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    NewItems                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UBlueprintSetLibrary::STATIC_Set_AddItems(TArray<int> NewItems) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd2cbae71);

		UBlueprintSetLibrary_Set_AddItems_Params params;
		params.NewItems = NewItems;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.BlueprintSetLibrary.Set_Add
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// int                            NewItem                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UBlueprintSetLibrary::STATIC_Set_Add(int NewItem) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7d50ac93);

		UBlueprintSetLibrary_Set_Add_Params params;
		params.NewItem = NewItem;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.DataTableFunctionLibrary.GetDataTableRowNames
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UDataTable*              Table                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FName>           OutRowNames                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UDataTableFunctionLibrary::STATIC_GetDataTableRowNames(class UDataTable* Table, TArray<struct FName>* OutRowNames) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24629c34);

		UDataTableFunctionLibrary_GetDataTableRowNames_Params params;
		params.Table = Table;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutRowNames != nullptr)
			*OutRowNames = params.OutRowNames;
	}


	// Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UDataTable*              Table                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   RowName                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTableRowBase           OutRow                         (CPF_Parm, CPF_OutParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UDataTableFunctionLibrary::STATIC_GetDataTableRowFromName(class UDataTable* Table, const struct FName& RowName, struct FTableRowBase* OutRow) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3d159dd);

		UDataTableFunctionLibrary_GetDataTableRowFromName_Params params;
		params.Table = Table;
		params.RowName = RowName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutRow != nullptr)
			*OutRow = params.OutRow;

		return params.ReturnValue;
	}


	// Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UCurveTable*             CurveTable                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   RowName                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InXY                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EEvaluateCurveTableResult> OutResult                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutXY                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ContextString                  (CPF_Parm, CPF_ZeroConstructor)

	void UDataTableFunctionLibrary::STATIC_EvaluateCurveTableRow(class UCurveTable* CurveTable, const struct FName& RowName, float InXY, const struct FString& ContextString, TEnumAsByte<EEvaluateCurveTableResult>* OutResult, float* OutXY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7cd5c53e);

		UDataTableFunctionLibrary_EvaluateCurveTableRow_Params params;
		params.CurveTable = CurveTable;
		params.RowName = RowName;
		params.InXY = InXY;
		params.ContextString = ContextString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutResult != nullptr)
			*OutResult = params.OutResult;
		if (OutXY != nullptr)
			*OutXY = params.OutXY;
	}


	// Function Engine.KismetSystemLibrary.StackTrace
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UKismetSystemLibrary::STATIC_StackTrace() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd1bb3ed);

		UKismetSystemLibrary_StackTrace_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x67fd97df);

		UKismetSystemLibrary_SphereTraceSingleForObjects_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereTraceSingleByObject_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x684f3a22);

		UKismetSystemLibrary_SphereTraceSingleByObject_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereTraceSingle_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x41933e13);

		UKismetSystemLibrary_SphereTraceSingle_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereTraceSingle_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3e9376fc);

		UKismetSystemLibrary_SphereTraceSingle_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x245a5208);

		UKismetSystemLibrary_SphereTraceMultiForObjects_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereTraceMultiByObject_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2aabfbb);

		UKismetSystemLibrary_SphereTraceMultiByObject_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereTraceMulti_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3091e1e4);

		UKismetSystemLibrary_SphereTraceMulti_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereTraceMulti_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf8c916d1);

		UKismetSystemLibrary_SphereTraceMulti_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereOverlapComponents_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SpherePos                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          SphereRadius                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ComponentClassFilter           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class UPrimitiveComponent*> OutComponents                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd32006c9);

		UKismetSystemLibrary_SphereOverlapComponents_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.ObjectTypes = ObjectTypes;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereOverlapComponents_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SpherePos                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          SphereRadius                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EOverlapFilterOption> Filter                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ComponentClassFilter           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class UPrimitiveComponent*> OutComponents                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TEnumAsByte<EOverlapFilterOption> Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6bf0139e);

		UKismetSystemLibrary_SphereOverlapComponents_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.Filter = Filter;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereOverlapActors_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SpherePos                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          SphereRadius                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6af2b6c3);

		UKismetSystemLibrary_SphereOverlapActors_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.ObjectTypes = ObjectTypes;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.SphereOverlapActors_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SpherePos                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          SphereRadius                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EOverlapFilterOption> Filter                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_SphereOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TEnumAsByte<EOverlapFilterOption> Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x15bd910c);

		UKismetSystemLibrary_SphereOverlapActors_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.Filter = Filter;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 CategoryName                   (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_ShowPlatformSpecificLeaderboardScreen(const struct FString& CategoryName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x66865b99);

		UKismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen_Params params;
		params.CategoryName = CategoryName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class APlayerController*       SpecificPlayer                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_ShowPlatformSpecificAchievementsScreen(class APlayerController* SpecificPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xafee3170);

		UKismetSystemLibrary_ShowPlatformSpecificAchievementsScreen_Params params;
		params.SpecificPlayer = SpecificPlayer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.ShowInterstitialAd
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UKismetSystemLibrary::STATIC_ShowInterstitialAd() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x39feb9b4);

		UKismetSystemLibrary_ShowInterstitialAd_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.ShowAdBanner
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            AdIdIndex                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShowOnBottomOfScreen          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_ShowAdBanner(int AdIdIndex, bool bShowOnBottomOfScreen) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x20df8758);

		UKismetSystemLibrary_ShowAdBanner_Params params;
		params.AdIdIndex = AdIdIndex;
		params.bShowOnBottomOfScreen = bShowOnBottomOfScreen;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetWindowTitle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FText                   Title                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetSystemLibrary::STATIC_SetWindowTitle(const struct FText& Title) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa7300cb8);

		UKismetSystemLibrary_SetWindowTitle_Params params;
		params.Title = Title;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnabled                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetVolumeButtonsHandledBySystem(bool bEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1e9c718b);

		UKismetSystemLibrary_SetVolumeButtonsHandledBySystem_Params params;
		params.bEnabled = bEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetVectorPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetVectorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FVector& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6a3af97e);

		UKismetSystemLibrary_SetVectorPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetUserActivity
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FUserActivity           UserActivity                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetSystemLibrary::STATIC_SetUserActivity(const struct FUserActivity& UserActivity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2d88c4a4);

		UKismetSystemLibrary_SetUserActivity_Params params;
		params.UserActivity = UserActivity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetTransformPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetTransformPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FTransform& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f36e5f3);

		UKismetSystemLibrary_SetTransformPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetTextPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetSystemLibrary::STATIC_SetTextPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FText& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x56aa851e);

		UKismetSystemLibrary_SetTextPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetSuppressViewportTransitionMessage
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bState                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetSuppressViewportTransitionMessage(class UObject* WorldContextObject, bool bState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x888c0041);

		UKismetSystemLibrary_SetSuppressViewportTransitionMessage_Params params;
		params.WorldContextObject = WorldContextObject;
		params.bState = bState;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetStructurePropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FGenericStruct          Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetStructurePropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FGenericStruct& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6d71a4b0);

		UKismetSystemLibrary_SetStructurePropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetStringPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Value                          (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_SetStringPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FString& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9a4a74e0);

		UKismetSystemLibrary_SetStringPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetRotatorPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetRotatorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FRotator& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9abfcd8);

		UKismetSystemLibrary_SetRotatorPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetObjectPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UObject*                 Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetObjectPropertyByName(class UObject* Object, const struct FName& PropertyName, class UObject* Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf74c614e);

		UKismetSystemLibrary_SetObjectPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetNamePropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetNamePropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FName& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x631fa53e);

		UKismetSystemLibrary_SetNamePropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetLinearColorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FLinearColor& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaebaaecb);

		UKismetSystemLibrary_SetLinearColorPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetIntPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetIntPropertyByName(class UObject* Object, const struct FName& PropertyName, int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbb3e46a0);

		UKismetSystemLibrary_SetIntPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetInterfacePropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TScriptInterface<class UInterface> Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetInterfacePropertyByName(class UObject* Object, const struct FName& PropertyName, const TScriptInterface<class UInterface>& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24603aee);

		UKismetSystemLibrary_SetInterfacePropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetFloatPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetFloatPropertyByName(class UObject* Object, const struct FName& PropertyName, float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2c34a721);

		UKismetSystemLibrary_SetFloatPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FCollisionProfileName   Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetSystemLibrary::STATIC_SetCollisionProfileNameProperty(class UObject* Object, const struct FName& PropertyName, const struct FCollisionProfileName& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf5c5cc7);

		UKismetSystemLibrary_SetCollisionProfileNameProperty_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetClassPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetClassPropertyByName(class UObject* Object, const struct FName& PropertyName, class UClass* Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb3d4ba3b);

		UKismetSystemLibrary_SetClassPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetBytePropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetBytePropertyByName(class UObject* Object, const struct FName& PropertyName, unsigned char Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc82a5629);

		UKismetSystemLibrary_SetBytePropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetBoolPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_SetBoolPropertyByName(class UObject* Object, const struct FName& PropertyName, bool Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4f098edf);

		UKismetSystemLibrary_SetBoolPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetAssetPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TAssetPtr<class UObject>       Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetSystemLibrary::STATIC_SetAssetPropertyByName(class UObject* Object, const struct FName& PropertyName, TAssetPtr<class UObject> Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c312137);

		UKismetSystemLibrary_SetAssetPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.SetAssetClassPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TAssetPtr<class UClass>        Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetSystemLibrary::STATIC_SetAssetClassPropertyByName(class UObject* Object, const struct FName& PropertyName, TAssetPtr<class UClass> Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe7bc8ff7);

		UKismetSystemLibrary_SetAssetClassPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.RetriggerableDelay
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLatentActionInfo       LatentInfo                     (CPF_Parm)

	void UKismetSystemLibrary::STATIC_RetriggerableDelay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x147cd9fc);

		UKismetSystemLibrary_RetriggerableDelay_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Duration = Duration;
		params.LatentInfo = LatentInfo;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            ControllerId                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_ResetGamepadAssignmentToController(int ControllerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x83aa7618);

		UKismetSystemLibrary_ResetGamepadAssignmentToController_Params params;
		params.ControllerId = ControllerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.ResetGamepadAssignments
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UKismetSystemLibrary::STATIC_ResetGamepadAssignments() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x86e6afa2);

		UKismetSystemLibrary_ResetGamepadAssignments_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UKismetSystemLibrary::STATIC_RegisterForRemoteNotifications() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6814a190);

		UKismetSystemLibrary_RegisterForRemoteNotifications_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.QuitGame
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APlayerController*       SpecificPlayer                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EQuitPreference>   QuitPreference                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_QuitGame(class UObject* WorldContextObject, class APlayerController* SpecificPlayer, TEnumAsByte<EQuitPreference> QuitPreference) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6c68a469);

		UKismetSystemLibrary_QuitGame_Params params;
		params.WorldContextObject = WorldContextObject;
		params.SpecificPlayer = SpecificPlayer;
		params.QuitPreference = QuitPreference;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.PrintWarning
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_PrintWarning(const struct FString& inString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcfcabc1d);

		UKismetSystemLibrary_PrintWarning_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.PrintText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   InText                         (CPF_ConstParm, CPF_Parm)
	// bool                           bPrintToScreen                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPrintToLog                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TextColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_PrintText(class UObject* WorldContextObject, const struct FText& InText, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x19377ffa);

		UKismetSystemLibrary_PrintText_Params params;
		params.WorldContextObject = WorldContextObject;
		params.InText = InText;
		params.bPrintToScreen = bPrintToScreen;
		params.bPrintToLog = bPrintToLog;
		params.TextColor = TextColor;
		params.Duration = Duration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.PrintString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// bool                           bPrintToScreen                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPrintToLog                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TextColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_PrintString(class UObject* WorldContextObject, const struct FString& inString, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96d7f88);

		UKismetSystemLibrary_PrintString_Params params;
		params.WorldContextObject = WorldContextObject;
		params.inString = inString;
		params.bPrintToScreen = bPrintToScreen;
		params.bPrintToLog = bPrintToLog;
		params.TextColor = TextColor;
		params.Duration = Duration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature
	// (FUNC_Public, FUNC_Delegate)
	// Parameters:
	// class UObject*                 Loaded                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::OnAssetLoaded__DelegateSignature(class UObject* Loaded) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5bee79aa);

		UKismetSystemLibrary_OnAssetLoaded__DelegateSignature_Params params;
		params.Loaded = Loaded;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature
	// (FUNC_Public, FUNC_Delegate)
	// Parameters:
	// class UClass*                  Loaded                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::OnAssetClassLoaded__DelegateSignature(class UClass* Loaded) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8348e652);

		UKismetSystemLibrary_OnAssetClassLoaded__DelegateSignature_Params params;
		params.Loaded = Loaded;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.MoveComponentTo
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class USceneComponent*         Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FVector                 TargetRelativeLocation         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                TargetRelativeRotation         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEaseOut                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bEaseIn                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OverTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bForceShortestRotationPath     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EMoveComponentAction> MoveAction                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLatentActionInfo       LatentInfo                     (CPF_Parm)

	void UKismetSystemLibrary::STATIC_MoveComponentTo(class USceneComponent* Component, const struct FVector& TargetRelativeLocation, const struct FRotator& TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, TEnumAsByte<EMoveComponentAction> MoveAction, const struct FLatentActionInfo& LatentInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c2529d);

		UKismetSystemLibrary_MoveComponentTo_Params params;
		params.Component = Component;
		params.TargetRelativeLocation = TargetRelativeLocation;
		params.TargetRelativeRotation = TargetRelativeRotation;
		params.bEaseOut = bEaseOut;
		params.bEaseIn = bEaseIn;
		params.OverTime = OverTime;
		params.bForceShortestRotationPath = bForceShortestRotationPath;
		params.MoveAction = MoveAction;
		params.LatentInfo = LatentInfo;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.MakeLiteralText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   Value                          (CPF_Parm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetSystemLibrary::STATIC_MakeLiteralText(const struct FText& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7ff42e20);

		UKismetSystemLibrary_MakeLiteralText_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.MakeLiteralString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 Value                          (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_MakeLiteralString(const struct FString& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9966ac76);

		UKismetSystemLibrary_MakeLiteralString_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.MakeLiteralName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FName                   Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName UKismetSystemLibrary::STATIC_MakeLiteralName(const struct FName& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb7e7f22c);

		UKismetSystemLibrary_MakeLiteralName_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.MakeLiteralInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetSystemLibrary::STATIC_MakeLiteralInt(int Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfbd4a698);

		UKismetSystemLibrary_MakeLiteralInt_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.MakeLiteralFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetSystemLibrary::STATIC_MakeLiteralFloat(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x23a7a959);

		UKismetSystemLibrary_MakeLiteralFloat_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.MakeLiteralByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetSystemLibrary::STATIC_MakeLiteralByte(unsigned char Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x81bde4cf);

		UKismetSystemLibrary_MakeLiteralByte_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.MakeLiteralBool
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_MakeLiteralBool(bool Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcbaae3a9);

		UKismetSystemLibrary_MakeLiteralBool_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LoadInterstitialAd
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            AdIdIndex                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_LoadInterstitialAd(int AdIdIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x40cc1dab);

		UKismetSystemLibrary_LoadInterstitialAd_Params params;
		params.AdIdIndex = AdIdIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.LoadAssetClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TAssetPtr<class UClass>        AssetClass                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FScriptDelegate         OnLoaded                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FLatentActionInfo       LatentInfo                     (CPF_Parm)

	void UKismetSystemLibrary::STATIC_LoadAssetClass(class UObject* WorldContextObject, TAssetPtr<class UClass> AssetClass, const struct FScriptDelegate& OnLoaded, const struct FLatentActionInfo& LatentInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96df825a);

		UKismetSystemLibrary_LoadAssetClass_Params params;
		params.WorldContextObject = WorldContextObject;
		params.AssetClass = AssetClass;
		params.OnLoaded = OnLoaded;
		params.LatentInfo = LatentInfo;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.LoadAsset
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TAssetPtr<class UObject>       Asset                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FScriptDelegate         OnLoaded                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FLatentActionInfo       LatentInfo                     (CPF_Parm)

	void UKismetSystemLibrary::STATIC_LoadAsset(class UObject* WorldContextObject, TAssetPtr<class UObject> Asset, const struct FScriptDelegate& OnLoaded, const struct FLatentActionInfo& LatentInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7fbf7f9a);

		UKismetSystemLibrary_LoadAsset_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Asset = Asset;
		params.OnLoaded = OnLoaded;
		params.LatentInfo = LatentInfo;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.LineTraceSingleForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceHitColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_LineTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x24c399ac);

		UKismetSystemLibrary_LineTraceSingleForObjects_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		params.TraceColor = TraceColor;
		params.TraceHitColor = TraceHitColor;
		params.DrawTime = DrawTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LineTraceSingleByObject_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceHitColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_LineTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb6813c0f);

		UKismetSystemLibrary_LineTraceSingleByObject_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		params.TraceColor = TraceColor;
		params.TraceHitColor = TraceHitColor;
		params.DrawTime = DrawTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LineTraceSingle_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceHitColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_LineTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc03c8b90);

		UKismetSystemLibrary_LineTraceSingle_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		params.TraceColor = TraceColor;
		params.TraceHitColor = TraceHitColor;
		params.DrawTime = DrawTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LineTraceSingle_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceHitColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_LineTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x94f52e7d);

		UKismetSystemLibrary_LineTraceSingle_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		params.TraceColor = TraceColor;
		params.TraceHitColor = TraceHitColor;
		params.DrawTime = DrawTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LineTraceMultiForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceHitColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_LineTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2854751);

		UKismetSystemLibrary_LineTraceMultiForObjects_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		params.TraceColor = TraceColor;
		params.TraceHitColor = TraceHitColor;
		params.DrawTime = DrawTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LineTraceMultiByObject_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceHitColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_LineTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4e32e2f0);

		UKismetSystemLibrary_LineTraceMultiByObject_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		params.TraceColor = TraceColor;
		params.TraceHitColor = TraceHitColor;
		params.DrawTime = DrawTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LineTraceMulti_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceHitColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_LineTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x15798a9);

		UKismetSystemLibrary_LineTraceMulti_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		params.TraceColor = TraceColor;
		params.TraceHitColor = TraceHitColor;
		params.DrawTime = DrawTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LineTraceMulti_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TraceHitColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_LineTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfedba9be);

		UKismetSystemLibrary_LineTraceMulti_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		params.TraceColor = TraceColor;
		params.TraceHitColor = TraceHitColor;
		params.DrawTime = DrawTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.LaunchURL
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 URL                            (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_LaunchURL(const struct FString& URL) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc97718fa);

		UKismetSystemLibrary_LaunchURL_Params params;
		params.URL = URL;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm)

	void UKismetSystemLibrary::STATIC_K2_UnPauseTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd579e48e);

		UKismetSystemLibrary_K2_UnPauseTimerHandle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_K2_UnPauseTimerDelegate(const struct FScriptDelegate& Delegate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2dc0549);

		UKismetSystemLibrary_K2_UnPauseTimerDelegate_Params params;
		params.Delegate = Delegate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_UnPauseTimer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_K2_UnPauseTimer(class UObject* Object, const struct FString& FunctionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x468177fc);

		UKismetSystemLibrary_K2_UnPauseTimer_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_TimerExistsHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_TimerExistsHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6a06e919);

		UKismetSystemLibrary_K2_TimerExistsHandle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_TimerExistsDelegate(const struct FScriptDelegate& Delegate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x84893dae);

		UKismetSystemLibrary_K2_TimerExistsDelegate_Params params;
		params.Delegate = Delegate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_TimerExists
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_TimerExists(class UObject* Object, const struct FString& FunctionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1425b9ef);

		UKismetSystemLibrary_K2_TimerExists_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_SetTimerDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLooping                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FTimerHandle UKismetSystemLibrary::STATIC_K2_SetTimerDelegate(const struct FScriptDelegate& Delegate, float Time, bool bLooping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85f70be);

		UKismetSystemLibrary_K2_SetTimerDelegate_Params params;
		params.Delegate = Delegate;
		params.Time = Time;
		params.bLooping = bLooping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_SetTimer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bLooping                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FTimerHandle UKismetSystemLibrary::STATIC_K2_SetTimer(class UObject* Object, const struct FString& FunctionName, float Time, bool bLooping) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x56e4451f);

		UKismetSystemLibrary_K2_SetTimer_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;
		params.Time = Time;
		params.bLooping = bLooping;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_PauseTimerHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm)

	void UKismetSystemLibrary::STATIC_K2_PauseTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x954aacb);

		UKismetSystemLibrary_K2_PauseTimerHandle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_K2_PauseTimerDelegate(const struct FScriptDelegate& Delegate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x58c3b050);

		UKismetSystemLibrary_K2_PauseTimerDelegate_Params params;
		params.Delegate = Delegate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_PauseTimer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_K2_PauseTimer(class UObject* Object, const struct FString& FunctionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe95a6265);

		UKismetSystemLibrary_K2_PauseTimer_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimerHandle            Handle                         (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_IsValidTimerHandle(const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x60c1b9fb);

		UKismetSystemLibrary_K2_IsValidTimerHandle_Params params;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_IsTimerPausedHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5e378667);

		UKismetSystemLibrary_K2_IsTimerPausedHandle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_IsTimerPausedDelegate(const struct FScriptDelegate& Delegate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd25c4d94);

		UKismetSystemLibrary_K2_IsTimerPausedDelegate_Params params;
		params.Delegate = Delegate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_IsTimerPaused
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_IsTimerPaused(class UObject* Object, const struct FString& FunctionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4b5a0851);

		UKismetSystemLibrary_K2_IsTimerPaused_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_IsTimerActiveHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x847512f3);

		UKismetSystemLibrary_K2_IsTimerActiveHandle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_IsTimerActiveDelegate(const struct FScriptDelegate& Delegate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x738da818);

		UKismetSystemLibrary_K2_IsTimerActiveDelegate_Params params;
		params.Delegate = Delegate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_IsTimerActive
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_K2_IsTimerActive(class UObject* Object, const struct FString& FunctionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x28f43cbd);

		UKismetSystemLibrary_K2_IsTimerActive_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FTimerHandle            Handle                         (CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FTimerHandle            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FTimerHandle UKismetSystemLibrary::STATIC_K2_InvalidateTimerHandle(struct FTimerHandle* Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9b9e35cc);

		UKismetSystemLibrary_K2_InvalidateTimerHandle_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Handle != nullptr)
			*Handle = params.Handle;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetSystemLibrary::STATIC_K2_GetTimerRemainingTimeHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa48c4dd0);

		UKismetSystemLibrary_K2_GetTimerRemainingTimeHandle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetSystemLibrary::STATIC_K2_GetTimerRemainingTimeDelegate(const struct FScriptDelegate& Delegate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5a9db273);

		UKismetSystemLibrary_K2_GetTimerRemainingTimeDelegate_Params params;
		params.Delegate = Delegate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetSystemLibrary::STATIC_K2_GetTimerRemainingTime(class UObject* Object, const struct FString& FunctionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d7c7902);

		UKismetSystemLibrary_K2_GetTimerRemainingTime_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetSystemLibrary::STATIC_K2_GetTimerElapsedTimeHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x88142390);

		UKismetSystemLibrary_K2_GetTimerElapsedTimeHandle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetSystemLibrary::STATIC_K2_GetTimerElapsedTimeDelegate(const struct FScriptDelegate& Delegate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5cc64833);

		UKismetSystemLibrary_K2_GetTimerElapsedTimeDelegate_Params params;
		params.Delegate = Delegate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetSystemLibrary::STATIC_K2_GetTimerElapsedTime(class UObject* Object, const struct FString& FunctionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd0511bc2);

		UKismetSystemLibrary_K2_GetTimerElapsedTime_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.K2_ClearTimerHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm)

	void UKismetSystemLibrary::STATIC_K2_ClearTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2116e248);

		UKismetSystemLibrary_K2_ClearTimerHandle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Handle = Handle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FScriptDelegate         Delegate                       (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_K2_ClearTimerDelegate(const struct FScriptDelegate& Delegate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfde111ab);

		UKismetSystemLibrary_K2_ClearTimerDelegate_Params params;
		params.Delegate = Delegate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_ClearTimer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FunctionName                   (CPF_Parm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_K2_ClearTimer(class UObject* Object, const struct FString& FunctionName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5d47afaa);

		UKismetSystemLibrary_K2_ClearTimer_Params params;
		params.Object = Object;
		params.FunctionName = FunctionName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.K2_ClearAndInvalidateTimerHandle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimerHandle            Handle                         (CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetSystemLibrary::STATIC_K2_ClearAndInvalidateTimerHandle(class UObject* WorldContextObject, struct FTimerHandle* Handle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x206eecc2);

		UKismetSystemLibrary_K2_ClearAndInvalidateTimerHandle_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Handle != nullptr)
			*Handle = params.Handle;
	}


	// Function Engine.KismetSystemLibrary.IsValidClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UClass*                  Class                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsValidClass(class UClass* Class) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb31195b0);

		UKismetSystemLibrary_IsValidClass_Params params;
		params.Class = Class;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsValid
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsValid(class UObject* Object) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab2a5b28);

		UKismetSystemLibrary_IsValid_Params params;
		params.Object = Object;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsStandalone
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsStandalone(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x342fd94f);

		UKismetSystemLibrary_IsStandalone_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsServer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsServer(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa1aef363);

		UKismetSystemLibrary_IsServer_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsPackagedForDistribution
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsPackagedForDistribution() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96636d39);

		UKismetSystemLibrary_IsPackagedForDistribution_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsLoggedIn
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class APlayerController*       SpecificPlayer                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsLoggedIn(class APlayerController* SpecificPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x596d9575);

		UKismetSystemLibrary_IsLoggedIn_Params params;
		params.SpecificPlayer = SpecificPlayer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsInterstitialAdRequested
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsInterstitialAdRequested() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7dbcd731);

		UKismetSystemLibrary_IsInterstitialAdRequested_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsInterstitialAdAvailable
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsInterstitialAdAvailable() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdc0c0250);

		UKismetSystemLibrary_IsInterstitialAdAvailable_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsDedicatedServer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsDedicatedServer(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x552de5ec);

		UKismetSystemLibrary_IsDedicatedServer_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ControllerId                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_IsControllerAssignedToGamepad(int ControllerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3426bdd2);

		UKismetSystemLibrary_IsControllerAssignedToGamepad_Params params;
		params.ControllerId = ControllerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.HideAdBanner
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UKismetSystemLibrary::STATIC_HideAdBanner() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ef67dd3);

		UKismetSystemLibrary_HideAdBanner_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_GetVolumeButtonsHandledBySystem() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa124ed67);

		UKismetSystemLibrary_GetVolumeButtonsHandledBySystem_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetUniqueDeviceId
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetUniqueDeviceId() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x615783fe);

		UKismetSystemLibrary_GetUniqueDeviceId_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<struct FIntPoint>       Resolutions                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_GetSupportedFullscreenResolutions(TArray<struct FIntPoint>* Resolutions) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x45090244);

		UKismetSystemLibrary_GetSupportedFullscreenResolutions_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Resolutions != nullptr)
			*Resolutions = params.Resolutions;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetSystemLibrary::STATIC_GetRenderingMaterialQualityLevel() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa0ed6f5a);

		UKismetSystemLibrary_GetRenderingMaterialQualityLevel_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetRenderingDetailMode
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetSystemLibrary::STATIC_GetRenderingDetailMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6f6954b8);

		UKismetSystemLibrary_GetRenderingDetailMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetPreferredLanguages
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<struct FString>         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<struct FString> UKismetSystemLibrary::STATIC_GetPreferredLanguages() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1ee2475a);

		UKismetSystemLibrary_GetPreferredLanguages_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetPlatformUserName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetPlatformUserName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfbb3a2b3);

		UKismetSystemLibrary_GetPlatformUserName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetPathName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetPathName(class UObject* Object) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9f4abd62);

		UKismetSystemLibrary_GetPathName_Params params;
		params.Object = Object;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetObjectName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetObjectName(class UObject* Object) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x788ce99a);

		UKismetSystemLibrary_GetObjectName_Params params;
		params.Object = Object;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetMinYResolutionForUI
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetSystemLibrary::STATIC_GetMinYResolutionForUI() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4f09a6b8);

		UKismetSystemLibrary_GetMinYResolutionForUI_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetMinYResolutionFor3DView
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetSystemLibrary::STATIC_GetMinYResolutionFor3DView() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd16dae3c);

		UKismetSystemLibrary_GetMinYResolutionFor3DView_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetLocalCurrencySymbol() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb21e2cca);

		UKismetSystemLibrary_GetLocalCurrencySymbol_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetLocalCurrencyCode
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetLocalCurrencyCode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf914a871);

		UKismetSystemLibrary_GetLocalCurrencyCode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetGameTimeInSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetSystemLibrary::STATIC_GetGameTimeInSeconds(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x353865f1);

		UKismetSystemLibrary_GetGameTimeInSeconds_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetGameName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetGameName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30cf379d);

		UKismetSystemLibrary_GetGameName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetGameBundleId
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetGameBundleId() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f98cc0b);

		UKismetSystemLibrary_GetGameBundleId_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetEngineVersion
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetEngineVersion() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x35d2f8b0);

		UKismetSystemLibrary_GetEngineVersion_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetDisplayName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetDisplayName(class UObject* Object) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfa9d8845);

		UKismetSystemLibrary_GetDisplayName_Params params;
		params.Object = Object;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetConvenientWindowedResolutions
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<struct FIntPoint>       Resolutions                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_GetConvenientWindowedResolutions(TArray<struct FIntPoint>* Resolutions) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x36a98c57);

		UKismetSystemLibrary_GetConvenientWindowedResolutions_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Resolutions != nullptr)
			*Resolutions = params.Resolutions;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetComponentBounds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class USceneComponent*         Component                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxExtent                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          SphereRadius                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_GetComponentBounds(class USceneComponent* Component, struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79001570);

		UKismetSystemLibrary_GetComponentBounds_Params params;
		params.Component = Component;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Origin != nullptr)
			*Origin = params.Origin;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
		if (SphereRadius != nullptr)
			*SphereRadius = params.SphereRadius;
	}


	// Function Engine.KismetSystemLibrary.GetClassDisplayName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UClass*                  Class                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetSystemLibrary::STATIC_GetClassDisplayName(class UClass* Class) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa0d9a345);

		UKismetSystemLibrary_GetClassDisplayName_Params params;
		params.Class = Class;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetAdIDCount
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetSystemLibrary::STATIC_GetAdIDCount() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3f3c7cf);

		UKismetSystemLibrary_GetAdIDCount_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.GetActorListFromComponentList
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<class UPrimitiveComponent*> ComponentList                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          OutActorList                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UKismetSystemLibrary::STATIC_GetActorListFromComponentList(TArray<class UPrimitiveComponent*> ComponentList, class UClass* ActorClassFilter, TArray<class AActor*>* OutActorList) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x90b1d5e);

		UKismetSystemLibrary_GetActorListFromComponentList_Params params;
		params.ComponentList = ComponentList;
		params.ActorClassFilter = ActorClassFilter;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActorList != nullptr)
			*OutActorList = params.OutActorList;
	}


	// Function Engine.KismetSystemLibrary.GetActorBounds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class AActor*                  Actor                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxExtent                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_GetActorBounds(class AActor* Actor, struct FVector* Origin, struct FVector* BoxExtent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc11bc246);

		UKismetSystemLibrary_GetActorBounds_Params params;
		params.Actor = Actor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Origin != nullptr)
			*Origin = params.Origin;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
	}


	// Function Engine.KismetSystemLibrary.ForceCloseAdBanner
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UKismetSystemLibrary::STATIC_ForceCloseAdBanner() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbb190868);

		UKismetSystemLibrary_ForceCloseAdBanner_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.FlushPersistentDebugLines
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_FlushPersistentDebugLines(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37ed4ee5);

		UKismetSystemLibrary_FlushPersistentDebugLines_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.FlushDebugStrings
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_FlushDebugStrings(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18eb407d);

		UKismetSystemLibrary_FlushDebugStrings_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.ExecuteConsoleCommand
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Command                        (CPF_Parm, CPF_ZeroConstructor)
	// class APlayerController*       SpecificPlayer                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_ExecuteConsoleCommand(class UObject* WorldContextObject, const struct FString& Command, class APlayerController* SpecificPlayer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfd445a95);

		UKismetSystemLibrary_ExecuteConsoleCommand_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Command = Command;
		params.SpecificPlayer = SpecificPlayer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 TextLocation                   (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Text                           (CPF_Parm, CPF_ZeroConstructor)
	// class AActor*                  TestBaseActor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            TextColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugString(class UObject* WorldContextObject, const struct FVector& TextLocation, const struct FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x62b2110a);

		UKismetSystemLibrary_DrawDebugString_Params params;
		params.WorldContextObject = WorldContextObject;
		params.TextLocation = TextLocation;
		params.Text = Text;
		params.TestBaseActor = TestBaseActor;
		params.TextColor = TextColor;
		params.Duration = Duration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugSphere
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Center                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Segments                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugSphere(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int Segments, const struct FLinearColor& LineColor, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3b73a342);

		UKismetSystemLibrary_DrawDebugSphere_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Center = Center;
		params.Radius = Radius;
		params.Segments = Segments;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugPoint
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Position                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Size                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            PointColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugPoint(class UObject* WorldContextObject, const struct FVector& Position, float Size, const struct FLinearColor& PointColor, float Duration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe12c9149);

		UKismetSystemLibrary_DrawDebugPoint_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Position = Position;
		params.Size = Size;
		params.PointColor = PointColor;
		params.Duration = Duration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugPlane
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FPlane                  PlaneCoordinates               (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Size                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            PlaneColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugPlane(class UObject* WorldContextObject, const struct FPlane& PlaneCoordinates, const struct FVector& Location, float Size, const struct FLinearColor& PlaneColor, float Duration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc683829);

		UKismetSystemLibrary_DrawDebugPlane_Params params;
		params.WorldContextObject = WorldContextObject;
		params.PlaneCoordinates = PlaneCoordinates;
		params.Location = Location;
		params.Size = Size;
		params.PlaneColor = PlaneColor;
		params.Duration = Duration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugLine
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LineStart                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LineEnd                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugLine(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f409053);

		UKismetSystemLibrary_DrawDebugLine_Params params;
		params.WorldContextObject = WorldContextObject;
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugFrustum
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              FrustumTransform               (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FLinearColor            FrustumColor                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugFrustum(class UObject* WorldContextObject, const struct FTransform& FrustumTransform, const struct FLinearColor& FrustumColor, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d3f2971);

		UKismetSystemLibrary_DrawDebugFrustum_Params params;
		params.WorldContextObject = WorldContextObject;
		params.FrustumTransform = FrustumTransform;
		params.FrustumColor = FrustumColor;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDebugFloatHistory      FloatHistory                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FTransform              DrawTransform                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector2D               DrawSize                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            DrawColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugFloatHistoryTransform(class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FTransform& DrawTransform, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b9d25e5);

		UKismetSystemLibrary_DrawDebugFloatHistoryTransform_Params params;
		params.WorldContextObject = WorldContextObject;
		params.FloatHistory = FloatHistory;
		params.DrawTransform = DrawTransform;
		params.DrawSize = DrawSize;
		params.DrawColor = DrawColor;
		params.Duration = Duration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDebugFloatHistory      FloatHistory                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FVector                 DrawLocation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               DrawSize                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            DrawColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugFloatHistoryLocation(class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FVector& DrawLocation, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf02a882e);

		UKismetSystemLibrary_DrawDebugFloatHistoryLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.FloatHistory = FloatHistory;
		params.DrawLocation = DrawLocation;
		params.DrawSize = DrawSize;
		params.DrawColor = DrawColor;
		params.Duration = Duration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugCylinder
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Segments                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugCylinder(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, int Segments, const struct FLinearColor& LineColor, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75ad51e3);

		UKismetSystemLibrary_DrawDebugCylinder_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.Segments = Segments;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 AxisLoc                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                AxisRot                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugCoordinateSystem(class UObject* WorldContextObject, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4c26bd4c);

		UKismetSystemLibrary_DrawDebugCoordinateSystem_Params params;
		params.WorldContextObject = WorldContextObject;
		params.AxisLoc = AxisLoc;
		params.AxisRot = AxisRot;
		params.Scale = Scale;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Direction                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Length                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          AngleWidth                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          AngleHeight                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumSides                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugConeInDegrees(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x61d5fd7c);

		UKismetSystemLibrary_DrawDebugConeInDegrees_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Origin = Origin;
		params.Direction = Direction;
		params.Length = Length;
		params.AngleWidth = AngleWidth;
		params.AngleHeight = AngleHeight;
		params.NumSides = NumSides;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugCone
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Direction                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Length                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          AngleWidth                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          AngleHeight                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumSides                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugCone(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1b4fc944);

		UKismetSystemLibrary_DrawDebugCone_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Origin = Origin;
		params.Direction = Direction;
		params.Length = Length;
		params.AngleWidth = AngleWidth;
		params.AngleHeight = AngleHeight;
		params.NumSides = NumSides;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugCircle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Center                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumSegments                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 YAxis                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ZAxis                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bDrawAxis                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugCircle(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int NumSegments, const struct FLinearColor& LineColor, float Duration, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9339fe09);

		UKismetSystemLibrary_DrawDebugCircle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Center = Center;
		params.Radius = Radius;
		params.NumSegments = NumSegments;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;
		params.YAxis = YAxis;
		params.ZAxis = ZAxis;
		params.bDrawAxis = bDrawAxis;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugCapsule
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Center                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugCapsule(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c38a74a);

		UKismetSystemLibrary_DrawDebugCapsule_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Center = Center;
		params.HalfHeight = HalfHeight;
		params.Radius = Radius;
		params.Rotation = Rotation;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugCamera
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class ACameraActor*            CameraActor                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            CameraColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugCamera(class ACameraActor* CameraActor, const struct FLinearColor& CameraColor, float Duration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc26c8834);

		UKismetSystemLibrary_DrawDebugCamera_Params params;
		params.CameraActor = CameraActor;
		params.CameraColor = CameraColor;
		params.Duration = Duration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugBox
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Center                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Extent                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugBox(class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdfc75db4);

		UKismetSystemLibrary_DrawDebugBox_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Center = Center;
		params.Extent = Extent;
		params.LineColor = LineColor;
		params.Rotation = Rotation;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DrawDebugArrow
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LineStart                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LineEnd                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ArrowSize                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            LineColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_DrawDebugArrow(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Duration, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x216fdb20);

		UKismetSystemLibrary_DrawDebugArrow_Params params;
		params.WorldContextObject = WorldContextObject;
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.ArrowSize = ArrowSize;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.DoesImplementInterface
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 TestObject                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  Interface                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_DoesImplementInterface(class UObject* TestObject, class UClass* Interface) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x64440a29);

		UKismetSystemLibrary_DoesImplementInterface_Params params;
		params.TestObject = TestObject;
		params.Interface = Interface;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.Delay
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Duration                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLatentActionInfo       LatentInfo                     (CPF_Parm)

	void UKismetSystemLibrary::STATIC_Delay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xae05cb3f);

		UKismetSystemLibrary_Delay_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Duration = Duration;
		params.LatentInfo = LatentInfo;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 ObjectToModify                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_CreateCopyForUndoBuffer(class UObject* ObjectToModify) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeafaddd2);

		UKismetSystemLibrary_CreateCopyForUndoBuffer_Params params;
		params.ObjectToModify = ObjectToModify;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.Conv_InterfaceToObject
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TScriptInterface<class UInterface> Interface                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class UObject*                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UObject* UKismetSystemLibrary::STATIC_Conv_InterfaceToObject(const TScriptInterface<class UInterface>& Interface) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b0f4ec2);

		UKismetSystemLibrary_Conv_InterfaceToObject_Params params;
		params.Interface = Interface;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.Conv_AssetToObject
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TAssetPtr<class UObject>       Asset                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// class UObject*                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UObject* UKismetSystemLibrary::STATIC_Conv_AssetToObject(TAssetPtr<class UObject> Asset) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2862a4f);

		UKismetSystemLibrary_Conv_AssetToObject_Params params;
		params.Asset = Asset;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.Conv_AssetClassToClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TAssetPtr<class UClass>        AssetClass                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// class UClass*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UClass* UKismetSystemLibrary::STATIC_Conv_AssetClassToClass(TAssetPtr<class UClass> AssetClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf20a214c);

		UKismetSystemLibrary_Conv_AssetClassToClass_Params params;
		params.AssetClass = AssetClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.ControlScreensaver
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bAllowScreenSaver              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetSystemLibrary::STATIC_ControlScreensaver(bool bAllowScreenSaver) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x744ed514);

		UKismetSystemLibrary_ControlScreensaver_Params params;
		params.bAllowScreenSaver = bAllowScreenSaver;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.ComponentOverlapComponents_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FTransform              ComponentTransform             (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ComponentClassFilter           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class UPrimitiveComponent*> OutComponents                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_ComponentOverlapComponents_NEW(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x15d26b23);

		UKismetSystemLibrary_ComponentOverlapComponents_NEW_Params params;
		params.Component = Component;
		params.ComponentTransform = ComponentTransform;
		params.ObjectTypes = ObjectTypes;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.ComponentOverlapComponents_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FTransform              ComponentTransform             (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<EOverlapFilterOption> Filter                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ComponentClassFilter           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class UPrimitiveComponent*> OutComponents                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_ComponentOverlapComponents_DEPRECATED(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TEnumAsByte<EOverlapFilterOption> Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdaef9f2c);

		UKismetSystemLibrary_ComponentOverlapComponents_DEPRECATED_Params params;
		params.Component = Component;
		params.ComponentTransform = ComponentTransform;
		params.Filter = Filter;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.ComponentOverlapActors_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FTransform              ComponentTransform             (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_ComponentOverlapActors_NEW(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x22e4a435);

		UKismetSystemLibrary_ComponentOverlapActors_NEW_Params params;
		params.Component = Component;
		params.ComponentTransform = ComponentTransform;
		params.ObjectTypes = ObjectTypes;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.ComponentOverlapActors_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UPrimitiveComponent*     Component                      (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FTransform              ComponentTransform             (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<EOverlapFilterOption> Filter                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_ComponentOverlapActors_DEPRECATED(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TEnumAsByte<EOverlapFilterOption> Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x566283ca);

		UKismetSystemLibrary_ComponentOverlapActors_DEPRECATED_Params params;
		params.Component = Component;
		params.ComponentTransform = ComponentTransform;
		params.Filter = Filter;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CollectGarbage
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UKismetSystemLibrary::STATIC_CollectGarbage() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8aa176e5);

		UKismetSystemLibrary_CollectGarbage_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc01ff21);

		UKismetSystemLibrary_CapsuleTraceSingleForObjects_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleTraceSingleByObject_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9d10ba40);

		UKismetSystemLibrary_CapsuleTraceSingleByObject_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleTraceSingle_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf7dd359);

		UKismetSystemLibrary_CapsuleTraceSingle_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleTraceSingle_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf106f24e);

		UKismetSystemLibrary_CapsuleTraceSingle_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x859ffd82);

		UKismetSystemLibrary_CapsuleTraceMultiForObjects_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleTraceMultiByObject_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x44934229);

		UKismetSystemLibrary_CapsuleTraceMultiByObject_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleTraceMulti_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3b8cf31a);

		UKismetSystemLibrary_CapsuleTraceMulti_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleTraceMulti_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcd76758b);

		UKismetSystemLibrary_CapsuleTraceMulti_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 CapsulePos                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ComponentClassFilter           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class UPrimitiveComponent*> OutComponents                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ca0917);

		UKismetSystemLibrary_CapsuleOverlapComponents_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.CapsulePos = CapsulePos;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectTypes = ObjectTypes;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 CapsulePos                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EOverlapFilterOption> Filter                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ComponentClassFilter           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class UPrimitiveComponent*> OutComponents                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TEnumAsByte<EOverlapFilterOption> Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2b45f1d0);

		UKismetSystemLibrary_CapsuleOverlapComponents_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.CapsulePos = CapsulePos;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.Filter = Filter;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleOverlapActors_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 CapsulePos                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6a9f9c01);

		UKismetSystemLibrary_CapsuleOverlapActors_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.CapsulePos = CapsulePos;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectTypes = ObjectTypes;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CapsuleOverlapActors_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 CapsulePos                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HalfHeight                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EOverlapFilterOption> Filter                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CapsuleOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TEnumAsByte<EOverlapFilterOption> Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab9737f6);

		UKismetSystemLibrary_CapsuleOverlapActors_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.CapsulePos = CapsulePos;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.Filter = Filter;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.CanLaunchURL
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 URL                            (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_CanLaunchURL(const struct FString& URL) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb327fa24);

		UKismetSystemLibrary_CanLaunchURL_Params params;
		params.URL = URL;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HalfSize                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Orientation                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_BoxTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x146c4a4f);

		UKismetSystemLibrary_BoxTraceSingleForObjects_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.HalfSize = HalfSize;
		params.Orientation = Orientation;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.BoxTraceSingle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HalfSize                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Orientation                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_BoxTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, struct FHitResult* OutHit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe63ec508);

		UKismetSystemLibrary_BoxTraceSingle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.HalfSize = HalfSize;
		params.Orientation = Orientation;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HalfSize                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Orientation                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_BoxTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x739a5238);

		UKismetSystemLibrary_BoxTraceMultiForObjects_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.HalfSize = HalfSize;
		params.Orientation = Orientation;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.BoxTraceMulti
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 End                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HalfSize                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Orientation                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ETraceTypeQuery>   TraceChannel                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FHitResult>      OutHits                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           bIgnoreSelf                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_BoxTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, TArray<struct FHitResult>* OutHits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x508dd17b);

		UKismetSystemLibrary_BoxTraceMulti_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.HalfSize = HalfSize;
		params.Orientation = Orientation;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHits != nullptr)
			*OutHits = params.OutHits;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.BoxOverlapComponents_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxPos                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Extent                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ComponentClassFilter           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class UPrimitiveComponent*> OutComponents                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_BoxOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaef680b9);

		UKismetSystemLibrary_BoxOverlapComponents_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.BoxPos = BoxPos;
		params.Extent = Extent;
		params.ObjectTypes = ObjectTypes;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.BoxOverlapComponents_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxPos                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Extent                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EOverlapFilterOption> Filter                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ComponentClassFilter           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class UPrimitiveComponent*> OutComponents                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_BoxOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, TEnumAsByte<EOverlapFilterOption> Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x40f7676e);

		UKismetSystemLibrary_BoxOverlapComponents_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.BoxPos = BoxPos;
		params.Extent = Extent;
		params.Filter = Filter;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.BoxOverlapActors_NEW
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxPos                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxExtent                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_BoxOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3552f033);

		UKismetSystemLibrary_BoxOverlapActors_NEW_Params params;
		params.WorldContextObject = WorldContextObject;
		params.BoxPos = BoxPos;
		params.BoxExtent = BoxExtent;
		params.ObjectTypes = ObjectTypes;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.BoxOverlapActors_DEPRECATED
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxPos                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxExtent                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EOverlapFilterOption> Filter                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ActorClassFilter               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetSystemLibrary::STATIC_BoxOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, TEnumAsByte<EOverlapFilterOption> Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb22b355c);

		UKismetSystemLibrary_BoxOverlapActors_DEPRECATED_Params params;
		params.WorldContextObject = WorldContextObject;
		params.BoxPos = BoxPos;
		params.BoxExtent = BoxExtent;
		params.Filter = Filter;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;

		return params.ReturnValue;
	}


	// Function Engine.KismetSystemLibrary.AddFloatHistorySample
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDebugFloatHistory      FloatHistory                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FDebugFloatHistory      ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FDebugFloatHistory UKismetSystemLibrary::STATIC_AddFloatHistorySample(float Value, const struct FDebugFloatHistory& FloatHistory) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc411e4b);

		UKismetSystemLibrary_AddFloatHistorySample_Params params;
		params.Value = Value;
		params.FloatHistory = FloatHistory;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.UnloadStreamLevel
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   LevelName                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLatentActionInfo       LatentInfo                     (CPF_Parm)

	void UGameplayStatics::STATIC_UnloadStreamLevel(class UObject* WorldContextObject, const struct FName& LevelName, const struct FLatentActionInfo& LatentInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9df083ab);

		UGameplayStatics_UnloadStreamLevel_Params params;
		params.WorldContextObject = WorldContextObject;
		params.LevelName = LevelName;
		params.LatentInfo = LatentInfo;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SuggestProjectileVelocity_CustomArc
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 OutLaunchVelocity              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 StartPos                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 EndPos                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OverrideGravityZ               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ArcParam                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_SuggestProjectileVelocity_CustomArc(class UObject* WorldContextObject, const struct FVector& StartPos, const struct FVector& EndPos, float OverrideGravityZ, float ArcParam, struct FVector* OutLaunchVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c89b082);

		UGameplayStatics_SuggestProjectileVelocity_CustomArc_Params params;
		params.WorldContextObject = WorldContextObject;
		params.StartPos = StartPos;
		params.EndPos = EndPos;
		params.OverrideGravityZ = OverrideGravityZ;
		params.ArcParam = ArcParam;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutLaunchVelocity != nullptr)
			*OutLaunchVelocity = params.OutLaunchVelocity;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnSoundAttached
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class USoundBase*              Sound                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USceneComponent*         AttachToComponent              (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   AttachPointName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachLocation>   LocationType                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bStopWhenAttachedToDestroyed   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundAttenuation*       AttenuationSettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundConcurrency*       ConcurrencySettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAudioComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UAudioComponent* UGameplayStatics::STATIC_SpawnSoundAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<EAttachLocation> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x463d18a0);

		UGameplayStatics_SpawnSoundAttached_Params params;
		params.Sound = Sound;
		params.AttachToComponent = AttachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		params.ConcurrencySettings = ConcurrencySettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnSoundAtLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundBase*              Sound                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundAttenuation*       AttenuationSettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundConcurrency*       ConcurrencySettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAudioComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UAudioComponent* UGameplayStatics::STATIC_SpawnSoundAtLocation(class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf19049de);

		UGameplayStatics_SpawnSoundAtLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Sound = Sound;
		params.Location = Location;
		params.Rotation = Rotation;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		params.ConcurrencySettings = ConcurrencySettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnSound2D
	// (FUNC_Final, FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundBase*              Sound                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundConcurrency*       ConcurrencySettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPersistAcrossLevelTransition  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAudioComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UAudioComponent* UGameplayStatics::STATIC_SpawnSound2D(class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6f80b1d6);

		UGameplayStatics_SpawnSound2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Sound = Sound;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.ConcurrencySettings = ConcurrencySettings;
		params.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnObject
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  ObjectClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UObject*                 Outer                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UObject*                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UObject* UGameplayStatics::STATIC_SpawnObject(class UClass* ObjectClass, class UObject* Outer) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3aa59efe);

		UGameplayStatics_SpawnObject_Params params;
		params.ObjectClass = ObjectClass;
		params.Outer = Outer;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnEmitterAttached
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UParticleSystem*         EmitterTemplate                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USceneComponent*         AttachToComponent              (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   AttachPointName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachLocation>   LocationType                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAutoDestroy                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UParticleSystemComponent* ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UParticleSystemComponent* UGameplayStatics::STATIC_SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<EAttachLocation> LocationType, bool bAutoDestroy) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb2d8cf47);

		UGameplayStatics_SpawnEmitterAttached_Params params;
		params.EmitterTemplate = EmitterTemplate;
		params.AttachToComponent = AttachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.bAutoDestroy = bAutoDestroy;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnEmitterAtLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UParticleSystem*         EmitterTemplate                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAutoDestroy                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UParticleSystemComponent* ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UParticleSystemComponent* UGameplayStatics::STATIC_SpawnEmitterAtLocation(class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, bool bAutoDestroy) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xed173865);

		UGameplayStatics_SpawnEmitterAtLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.EmitterTemplate = EmitterTemplate;
		params.Location = Location;
		params.Rotation = Rotation;
		params.bAutoDestroy = bAutoDestroy;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnDialogueAttached
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UDialogueWave*           Dialogue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDialogueContext        Context                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// class USceneComponent*         AttachToComponent              (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   AttachPointName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachLocation>   LocationType                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bStopWhenAttachedToDestroyed   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundAttenuation*       AttenuationSettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAudioComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UAudioComponent* UGameplayStatics::STATIC_SpawnDialogueAttached(class UDialogueWave* Dialogue, const struct FDialogueContext& Context, class USceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<EAttachLocation> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdcab98dd);

		UGameplayStatics_SpawnDialogueAttached_Params params;
		params.Dialogue = Dialogue;
		params.Context = Context;
		params.AttachToComponent = AttachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnDialogueAtLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDialogueWave*           Dialogue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDialogueContext        Context                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundAttenuation*       AttenuationSettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAudioComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UAudioComponent* UGameplayStatics::STATIC_SpawnDialogueAtLocation(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ea85287);

		UGameplayStatics_SpawnDialogueAtLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Dialogue = Dialogue;
		params.Context = Context;
		params.Location = Location;
		params.Rotation = Rotation;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnDialogue2D
	// (FUNC_Final, FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDialogueWave*           Dialogue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDialogueContext        Context                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAudioComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UAudioComponent* UGameplayStatics::STATIC_SpawnDialogue2D(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1550669f);

		UGameplayStatics_SpawnDialogue2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Dialogue = Dialogue;
		params.Context = Context;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnDecalAttached
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      DecalMaterial                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 DecalSize                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USceneComponent*         AttachToComponent              (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   AttachPointName                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EAttachLocation>   LocationType                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LifeSpan                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDecalComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UDecalComponent* UGameplayStatics::STATIC_SpawnDecalAttached(class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<EAttachLocation> LocationType, float LifeSpan) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc8a7c232);

		UGameplayStatics_SpawnDecalAttached_Params params;
		params.DecalMaterial = DecalMaterial;
		params.DecalSize = DecalSize;
		params.AttachToComponent = AttachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.LifeSpan = LifeSpan;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SpawnDecalAtLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      DecalMaterial                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 DecalSize                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LifeSpan                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDecalComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UDecalComponent* UGameplayStatics::STATIC_SpawnDecalAtLocation(class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbd503d14);

		UGameplayStatics_SpawnDecalAtLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.DecalMaterial = DecalMaterial;
		params.DecalSize = DecalSize;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LifeSpan = LifeSpan;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SetWorldOriginLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FIntVector              NewLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_SetWorldOriginLocation(class UObject* WorldContextObject, const struct FIntVector& NewLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbb8da0a9);

		UGameplayStatics_SetWorldOriginLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.NewLocation = NewLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SetSubtitlesEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnabled                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_SetSubtitlesEnabled(bool bEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x290c6df0);

		UGameplayStatics_SetSubtitlesEnabled_Params params;
		params.bEnabled = bEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SetSoundMixClassOverride
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundMix*               InSoundMixModifier             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundClass*             InSoundClass                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Volume                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Pitch                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FadeInTime                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bApplyToChildren               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_SetSoundMixClassOverride(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xee58521);

		UGameplayStatics_SetSoundMixClassOverride_Params params;
		params.WorldContextObject = WorldContextObject;
		params.InSoundMixModifier = InSoundMixModifier;
		params.InSoundClass = InSoundClass;
		params.Volume = Volume;
		params.Pitch = Pitch;
		params.FadeInTime = FadeInTime;
		params.bApplyToChildren = bApplyToChildren;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SetPlayerControllerID
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class APlayerController*       Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ControllerId                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_SetPlayerControllerID(class APlayerController* Player, int ControllerId) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe76d152);

		UGameplayStatics_SetPlayerControllerID_Params params;
		params.Player = Player;
		params.ControllerId = ControllerId;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SetGlobalTimeDilation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TimeDilation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_SetGlobalTimeDilation(class UObject* WorldContextObject, float TimeDilation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdce47ee6);

		UGameplayStatics_SetGlobalTimeDilation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.TimeDilation = TimeDilation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SetGlobalPitchModulation
	// (FUNC_Final, FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchModulation                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TimeSec                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_SetGlobalPitchModulation(class UObject* WorldContextObject, float PitchModulation, float TimeSec) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8441a2a1);

		UGameplayStatics_SetGlobalPitchModulation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.PitchModulation = PitchModulation;
		params.TimeSec = TimeSec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SetGlobalListenerFocusParameters
	// (FUNC_Final, FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FocusAzimuthScale              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NonFocusAzimuthScale           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FocusDistanceScale             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NonFocusDistanceScale          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FocusVolumeScale               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NonFocusVolumeScale            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FocusPriorityScale             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NonFocusPriorityScale          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_SetGlobalListenerFocusParameters(class UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ddc77a9);

		UGameplayStatics_SetGlobalListenerFocusParameters_Params params;
		params.WorldContextObject = WorldContextObject;
		params.FocusAzimuthScale = FocusAzimuthScale;
		params.NonFocusAzimuthScale = NonFocusAzimuthScale;
		params.FocusDistanceScale = FocusDistanceScale;
		params.NonFocusDistanceScale = NonFocusDistanceScale;
		params.FocusVolumeScale = FocusVolumeScale;
		params.NonFocusVolumeScale = NonFocusVolumeScale;
		params.FocusPriorityScale = FocusPriorityScale;
		params.NonFocusPriorityScale = NonFocusPriorityScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SetGamePaused
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPaused                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_SetGamePaused(class UObject* WorldContextObject, bool bPaused) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9b243aba);

		UGameplayStatics_SetGamePaused_Params params;
		params.WorldContextObject = WorldContextObject;
		params.bPaused = bPaused;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.SetBaseSoundMix
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundMix*               InSoundMix                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_SetBaseSoundMix(class UObject* WorldContextObject, class USoundMix* InSoundMix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd9780a94);

		UGameplayStatics_SetBaseSoundMix_Params params;
		params.WorldContextObject = WorldContextObject;
		params.InSoundMix = InSoundMix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.SaveGameToSlot
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class USaveGame*               SaveGameObject                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 SlotName                       (CPF_Parm, CPF_ZeroConstructor)
	// int                            UserIndex                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_SaveGameToSlot(class USaveGame* SaveGameObject, const struct FString& SlotName, int UserIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb1faae04);

		UGameplayStatics_SaveGameToSlot_Params params;
		params.SaveGameObject = SaveGameObject;
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.RemovePlayer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class APlayerController*       Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bDestroyPawn                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_RemovePlayer(class APlayerController* Player, bool bDestroyPawn) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37e0d0d1);

		UGameplayStatics_RemovePlayer_Params params;
		params.Player = Player;
		params.bDestroyPawn = bDestroyPawn;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.RebaseZeroOriginOntoLocal
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UGameplayStatics::STATIC_RebaseZeroOriginOntoLocal(class UObject* WorldContextObject, const struct FVector& WorldLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb1cdcb9b);

		UGameplayStatics_RebaseZeroOriginOntoLocal_Params params;
		params.WorldContextObject = WorldContextObject;
		params.WorldLocation = WorldLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.RebaseLocalOriginOntoZero
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UGameplayStatics::STATIC_RebaseLocalOriginOntoZero(class UObject* WorldContextObject, const struct FVector& WorldLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89330f1b);

		UGameplayStatics_RebaseLocalOriginOntoZero_Params params;
		params.WorldContextObject = WorldContextObject;
		params.WorldLocation = WorldLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.PushSoundMixModifier
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundMix*               InSoundMixModifier             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_PushSoundMixModifier(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1bf237f4);

		UGameplayStatics_PushSoundMixModifier_Params params;
		params.WorldContextObject = WorldContextObject;
		params.InSoundMixModifier = InSoundMixModifier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.ProjectWorldToScreen
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class APlayerController*       Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldPosition                  (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector2D               ScreenPosition                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPlayerViewportRelative        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_ProjectWorldToScreen(class APlayerController* Player, const struct FVector& WorldPosition, bool bPlayerViewportRelative, struct FVector2D* ScreenPosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x278dd6e0);

		UGameplayStatics_ProjectWorldToScreen_Params params;
		params.Player = Player;
		params.WorldPosition = WorldPosition;
		params.bPlayerViewportRelative = bPlayerViewportRelative;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (ScreenPosition != nullptr)
			*ScreenPosition = params.ScreenPosition;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.PredictProjectilePath
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              OutHit                         (CPF_Parm, CPF_OutParm, CPF_IsPlainOldData)
	// TArray<struct FVector>         OutPathPositions               (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// struct FVector                 OutLastTraceDestination        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 StartPos                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LaunchVelocity                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bTracePath                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ProjectileRadius               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bTraceComplex                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          ActorsToIgnore                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DrawDebugTime                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          SimFrequency                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxSimTime                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OverrideGravityZ               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_PredictProjectilePath(class UObject* WorldContextObject, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x47d3849);

		UGameplayStatics_PredictProjectilePath_Params params;
		params.WorldContextObject = WorldContextObject;
		params.StartPos = StartPos;
		params.LaunchVelocity = LaunchVelocity;
		params.bTracePath = bTracePath;
		params.ProjectileRadius = ProjectileRadius;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.DrawDebugTime = DrawDebugTime;
		params.SimFrequency = SimFrequency;
		params.MaxSimTime = MaxSimTime;
		params.OverrideGravityZ = OverrideGravityZ;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		if (OutPathPositions != nullptr)
			*OutPathPositions = params.OutPathPositions;
		if (OutLastTraceDestination != nullptr)
			*OutLastTraceDestination = params.OutLastTraceDestination;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.PopSoundMixModifier
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundMix*               InSoundMixModifier             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_PopSoundMixModifier(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1371b75);

		UGameplayStatics_PopSoundMixModifier_Params params;
		params.WorldContextObject = WorldContextObject;
		params.InSoundMixModifier = InSoundMixModifier;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.PlayWorldCameraShake
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  Shake                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Epicenter                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InnerRadius                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OuterRadius                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Falloff                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bOrientShakeTowardsEpicenter   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_PlayWorldCameraShake(class UObject* WorldContextObject, class UClass* Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc2f660b5);

		UGameplayStatics_PlayWorldCameraShake_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Shake = Shake;
		params.Epicenter = Epicenter;
		params.InnerRadius = InnerRadius;
		params.OuterRadius = OuterRadius;
		params.Falloff = Falloff;
		params.bOrientShakeTowardsEpicenter = bOrientShakeTowardsEpicenter;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.PlaySoundAtLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundBase*              Sound                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundAttenuation*       AttenuationSettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundConcurrency*       ConcurrencySettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_PlaySoundAtLocation(class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3e9bcca3);

		UGameplayStatics_PlaySoundAtLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Sound = Sound;
		params.Location = Location;
		params.Rotation = Rotation;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		params.ConcurrencySettings = ConcurrencySettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.PlaySound2D
	// (FUNC_Final, FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundBase*              Sound                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundConcurrency*       ConcurrencySettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_PlaySound2D(class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7870fc43);

		UGameplayStatics_PlaySound2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Sound = Sound;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.ConcurrencySettings = ConcurrencySettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.PlayDialogueAtLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDialogueWave*           Dialogue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDialogueContext        Context                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundAttenuation*       AttenuationSettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_PlayDialogueAtLocation(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe973bb3c);

		UGameplayStatics_PlayDialogueAtLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Dialogue = Dialogue;
		params.Context = Context;
		params.Location = Location;
		params.Rotation = Rotation;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.PlayDialogue2D
	// (FUNC_Final, FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UDialogueWave*           Dialogue                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDialogueContext        Context                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_PlayDialogue2D(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3a50f578);

		UGameplayStatics_PlayDialogue2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Dialogue = Dialogue;
		params.Context = Context;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.ParseOption
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 Options                        (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Key                            (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UGameplayStatics::STATIC_ParseOption(const struct FString& Options, const struct FString& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x148dca28);

		UGameplayStatics_ParseOption_Params params;
		params.Options = Options;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.OpenLevel
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   LevelName                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bAbsolute                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Options                        (CPF_Parm, CPF_ZeroConstructor)

	void UGameplayStatics::STATIC_OpenLevel(class UObject* WorldContextObject, const struct FName& LevelName, bool bAbsolute, const struct FString& Options) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3860668c);

		UGameplayStatics_OpenLevel_Params params;
		params.WorldContextObject = WorldContextObject;
		params.LevelName = LevelName;
		params.bAbsolute = bAbsolute;
		params.Options = Options;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.MakeHitResult
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           bBlockingHit                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bInitialOverlap                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Time                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ImpactPoint                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Normal                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ImpactNormal                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPhysicalMaterial*       PhysMat                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  HitActor                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     HitComponent                   (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   HitBoneName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            HitItem                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            FaceIndex                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 TraceStart                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 TraceEnd                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FHitResult              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FHitResult UGameplayStatics::STATIC_MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, const struct FVector& Location, const struct FVector& ImpactPoint, const struct FVector& Normal, const struct FVector& ImpactNormal, class UPhysicalMaterial* PhysMat, class AActor* HitActor, class UPrimitiveComponent* HitComponent, const struct FName& HitBoneName, int HitItem, int FaceIndex, const struct FVector& TraceStart, const struct FVector& TraceEnd) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6a1716d0);

		UGameplayStatics_MakeHitResult_Params params;
		params.bBlockingHit = bBlockingHit;
		params.bInitialOverlap = bInitialOverlap;
		params.Time = Time;
		params.Location = Location;
		params.ImpactPoint = ImpactPoint;
		params.Normal = Normal;
		params.ImpactNormal = ImpactNormal;
		params.PhysMat = PhysMat;
		params.HitActor = HitActor;
		params.HitComponent = HitComponent;
		params.HitBoneName = HitBoneName;
		params.HitItem = HitItem;
		params.FaceIndex = FaceIndex;
		params.TraceStart = TraceStart;
		params.TraceEnd = TraceEnd;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.LoadStreamLevel
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   LevelName                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bMakeVisibleAfterLoad          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShouldBlockOnLoad             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLatentActionInfo       LatentInfo                     (CPF_Parm)

	void UGameplayStatics::STATIC_LoadStreamLevel(class UObject* WorldContextObject, const struct FName& LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FLatentActionInfo& LatentInfo) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbba2aa3c);

		UGameplayStatics_LoadStreamLevel_Params params;
		params.WorldContextObject = WorldContextObject;
		params.LevelName = LevelName;
		params.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
		params.bShouldBlockOnLoad = bShouldBlockOnLoad;
		params.LatentInfo = LatentInfo;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.LoadGameFromSlot
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 SlotName                       (CPF_Parm, CPF_ZeroConstructor)
	// int                            UserIndex                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USaveGame*               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class USaveGame* UGameplayStatics::STATIC_LoadGameFromSlot(const struct FString& SlotName, int UserIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x94aacee8);

		UGameplayStatics_LoadGameFromSlot_Params params;
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.IsGamePaused
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_IsGamePaused(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc37d75ae);

		UGameplayStatics_IsGamePaused_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.HasOption
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 Options                        (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 InKey                          (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_HasOption(const struct FString& Options, const struct FString& InKey) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa259c5c1);

		UGameplayStatics_HasOption_Params params;
		params.Options = Options;
		params.InKey = InKey;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GrassOverlappingSphereCount
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UStaticMesh*             StaticMesh                     (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 CenterPosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameplayStatics::STATIC_GrassOverlappingSphereCount(class UObject* WorldContextObject, class UStaticMesh* StaticMesh, const struct FVector& CenterPosition, float Radius) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf9c21ff);

		UGameplayStatics_GrassOverlappingSphereCount_Params params;
		params.WorldContextObject = WorldContextObject;
		params.StaticMesh = StaticMesh;
		params.CenterPosition = CenterPosition;
		params.Radius = Radius;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetWorldOriginLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FIntVector              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FIntVector UGameplayStatics::STATIC_GetWorldOriginLocation(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x51cdaa9d);

		UGameplayStatics_GetWorldOriginLocation_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetWorldDeltaSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UGameplayStatics::STATIC_GetWorldDeltaSeconds(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1376d16f);

		UGameplayStatics_GetWorldDeltaSeconds_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetUnpausedTimeSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UGameplayStatics::STATIC_GetUnpausedTimeSeconds(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x58200731);

		UGameplayStatics_GetUnpausedTimeSeconds_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetTimeSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UGameplayStatics::STATIC_GetTimeSeconds(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4fc9ffe8);

		UGameplayStatics_GetTimeSeconds_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetSurfaceType
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FHitResult              Hit                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<EPhysicalSurface>  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<EPhysicalSurface> UGameplayStatics::STATIC_GetSurfaceType(const struct FHitResult& Hit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeff1c6cb);

		UGameplayStatics_GetSurfaceType_Params params;
		params.Hit = Hit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetStreamingLevel
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PackageName                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class ULevelStreaming*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class ULevelStreaming* UGameplayStatics::STATIC_GetStreamingLevel(class UObject* WorldContextObject, const struct FName& PackageName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfe48c20c);

		UGameplayStatics_GetStreamingLevel_Params params;
		params.WorldContextObject = WorldContextObject;
		params.PackageName = PackageName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetRealTimeSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UGameplayStatics::STATIC_GetRealTimeSeconds(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd4a2cd18);

		UGameplayStatics_GetRealTimeSeconds_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetPlayerPawn
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            PlayerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APawn*                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APawn* UGameplayStatics::STATIC_GetPlayerPawn(class UObject* WorldContextObject, int PlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe1f58633);

		UGameplayStatics_GetPlayerPawn_Params params;
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetPlayerControllerID
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class APlayerController*       Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameplayStatics::STATIC_GetPlayerControllerID(class APlayerController* Player) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6426505e);

		UGameplayStatics_GetPlayerControllerID_Params params;
		params.Player = Player;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetPlayerController
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            PlayerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APlayerController*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APlayerController* UGameplayStatics::STATIC_GetPlayerController(class UObject* WorldContextObject, int PlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9578efa5);

		UGameplayStatics_GetPlayerController_Params params;
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetPlayerCharacter
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            PlayerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class ACharacter*              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class ACharacter* UGameplayStatics::STATIC_GetPlayerCharacter(class UObject* WorldContextObject, int PlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37071c3e);

		UGameplayStatics_GetPlayerCharacter_Params params;
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetPlayerCameraManager
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            PlayerIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APlayerCameraManager*    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APlayerCameraManager* UGameplayStatics::STATIC_GetPlayerCameraManager(class UObject* WorldContextObject, int PlayerIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8b048df9);

		UGameplayStatics_GetPlayerCameraManager_Params params;
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetPlatformName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UGameplayStatics::STATIC_GetPlatformName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4ae67166);

		UGameplayStatics_GetPlatformName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetObjectClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 Object                         (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UClass* UGameplayStatics::STATIC_GetObjectClass(class UObject* Object) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x195ec169);

		UGameplayStatics_GetObjectClass_Params params;
		params.Object = Object;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetKeyValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 Pair                           (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Key                            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// struct FString                 Value                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UGameplayStatics::STATIC_GetKeyValue(const struct FString& Pair, struct FString* Key, struct FString* Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x724edf2);

		UGameplayStatics_GetKeyValue_Params params;
		params.Pair = Pair;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Key != nullptr)
			*Key = params.Key;
		if (Value != nullptr)
			*Value = params.Value;
	}


	// Function Engine.GameplayStatics.GetIntOption
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 Options                        (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Key                            (CPF_Parm, CPF_ZeroConstructor)
	// int                            DefaultValue                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UGameplayStatics::STATIC_GetIntOption(const struct FString& Options, const struct FString& Key, int DefaultValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd1a85932);

		UGameplayStatics_GetIntOption_Params params;
		params.Options = Options;
		params.Key = Key;
		params.DefaultValue = DefaultValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetGlobalTimeDilation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UGameplayStatics::STATIC_GetGlobalTimeDilation(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2f8a71d2);

		UGameplayStatics_GetGlobalTimeDilation_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetGameState
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AGameStateBase*          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AGameStateBase* UGameplayStatics::STATIC_GetGameState(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9b1b3cf);

		UGameplayStatics_GetGameState_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetGameMode
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AGameModeBase*           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AGameModeBase* UGameplayStatics::STATIC_GetGameMode(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd5963fa9);

		UGameplayStatics_GetGameMode_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetGameInstance
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UGameInstance*           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UGameInstance* UGameplayStatics::STATIC_GetGameInstance(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3ddf6ea1);

		UGameplayStatics_GetGameInstance_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetCurrentReverbEffect
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UReverbEffect*           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UReverbEffect* UGameplayStatics::STATIC_GetCurrentReverbEffect(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x63359d0a);

		UGameplayStatics_GetCurrentReverbEffect_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetCurrentLevelName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bRemovePrefixString            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UGameplayStatics::STATIC_GetCurrentLevelName(class UObject* WorldContextObject, bool bRemovePrefixString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xda00958);

		UGameplayStatics_GetCurrentLevelName_Params params;
		params.WorldContextObject = WorldContextObject;
		params.bRemovePrefixString = bRemovePrefixString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetAudioTimeSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UGameplayStatics::STATIC_GetAudioTimeSeconds(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa8340ef6);

		UGameplayStatics_GetAudioTimeSeconds_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetAllActorsWithTag
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   Tag                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UGameplayStatics::STATIC_GetAllActorsWithTag(class UObject* WorldContextObject, const struct FName& Tag, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe166c257);

		UGameplayStatics_GetAllActorsWithTag_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Tag = Tag;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}


	// Function Engine.GameplayStatics.GetAllActorsWithInterface
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  Interface                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UGameplayStatics::STATIC_GetAllActorsWithInterface(class UObject* WorldContextObject, class UClass* Interface, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76bf9782);

		UGameplayStatics_GetAllActorsWithInterface_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Interface = Interface;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}


	// Function Engine.GameplayStatics.GetAllActorsOfClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ActorClass                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          OutActors                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UGameplayStatics::STATIC_GetAllActorsOfClass(class UObject* WorldContextObject, class UClass* ActorClass, TArray<class AActor*>* OutActors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x49aaca76);

		UGameplayStatics_GetAllActorsOfClass_Params params;
		params.WorldContextObject = WorldContextObject;
		params.ActorClass = ActorClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}


	// Function Engine.GameplayStatics.GetActorArrayBounds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<class AActor*>          Actors                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           bOnlyCollidingComponents       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Center                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 BoxExtent                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_GetActorArrayBounds(TArray<class AActor*> Actors, bool bOnlyCollidingComponents, struct FVector* Center, struct FVector* BoxExtent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37415adb);

		UGameplayStatics_GetActorArrayBounds_Params params;
		params.Actors = Actors;
		params.bOnlyCollidingComponents = bOnlyCollidingComponents;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Center != nullptr)
			*Center = params.Center;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
	}


	// Function Engine.GameplayStatics.GetActorArrayAverageLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<class AActor*>          Actors                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UGameplayStatics::STATIC_GetActorArrayAverageLocation(TArray<class AActor*> Actors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf360b098);

		UGameplayStatics_GetActorArrayAverageLocation_Params params;
		params.Actors = Actors;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.GetAccurateRealTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Seconds                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PartialSeconds                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_GetAccurateRealTime(class UObject* WorldContextObject, int* Seconds, float* PartialSeconds) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7151d8b);

		UGameplayStatics_GetAccurateRealTime_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Seconds != nullptr)
			*Seconds = params.Seconds;
		if (PartialSeconds != nullptr)
			*PartialSeconds = params.PartialSeconds;
	}


	// Function Engine.GameplayStatics.FlushLevelStreaming
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_FlushLevelStreaming(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb3cc0846);

		UGameplayStatics_FlushLevelStreaming_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.FinishSpawningActor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  Actor                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              SpawnTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* UGameplayStatics::STATIC_FinishSpawningActor(class AActor* Actor, const struct FTransform& SpawnTransform) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1c506aaf);

		UGameplayStatics_FinishSpawningActor_Params params;
		params.Actor = Actor;
		params.SpawnTransform = SpawnTransform;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.FindCollisionUV
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FHitResult              Hit                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// int                            UVChannel                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               UV                             (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_FindCollisionUV(const struct FHitResult& Hit, int UVChannel, struct FVector2D* UV) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5cf119c);

		UGameplayStatics_FindCollisionUV_Params params;
		params.Hit = Hit;
		params.UVChannel = UVChannel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (UV != nullptr)
			*UV = params.UV;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.EnableLiveStreaming
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           Enable                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_EnableLiveStreaming(bool Enable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb62cbe5b);

		UGameplayStatics_EnableLiveStreaming_Params params;
		params.Enable = Enable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.DoesSaveGameExist
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 SlotName                       (CPF_Parm, CPF_ZeroConstructor)
	// int                            UserIndex                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_DoesSaveGameExist(const struct FString& SlotName, int UserIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xca223dc5);

		UGameplayStatics_DoesSaveGameExist_Params params;
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.DeprojectScreenToWorld
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class APlayerController*       Player                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenPosition                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 WorldPosition                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldDirection                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_DeprojectScreenToWorld(class APlayerController* Player, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4f1c446b);

		UGameplayStatics_DeprojectScreenToWorld_Params params;
		params.Player = Player;
		params.ScreenPosition = ScreenPosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (WorldPosition != nullptr)
			*WorldPosition = params.WorldPosition;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.DeleteGameInSlot
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 SlotName                       (CPF_Parm, CPF_ZeroConstructor)
	// int                            UserIndex                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_DeleteGameInSlot(const struct FString& SlotName, int UserIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb67a99c);

		UGameplayStatics_DeleteGameInSlot_Params params;
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.DeactivateReverbEffect
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   TagName                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_DeactivateReverbEffect(class UObject* WorldContextObject, const struct FName& TagName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x824d9d13);

		UGameplayStatics_DeactivateReverbEffect_Params params;
		params.WorldContextObject = WorldContextObject;
		params.TagName = TagName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.CreateSound2D
	// (FUNC_Final, FUNC_BlueprintCosmetic, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundBase*              Sound                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VolumeMultiplier               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PitchMultiplier                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          StartTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundConcurrency*       ConcurrencySettings            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPersistAcrossLevelTransition  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UAudioComponent*         ReturnValue                    (CPF_ExportObject, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData)

	class UAudioComponent* UGameplayStatics::STATIC_CreateSound2D(class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc1a4367d);

		UGameplayStatics_CreateSound2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Sound = Sound;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.ConcurrencySettings = ConcurrencySettings;
		params.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.CreateSaveGameObjectFromBlueprint
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UBlueprint*              SaveGameBlueprint              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USaveGame*               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class USaveGame* UGameplayStatics::STATIC_CreateSaveGameObjectFromBlueprint(class UBlueprint* SaveGameBlueprint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc07a183);

		UGameplayStatics_CreateSaveGameObjectFromBlueprint_Params params;
		params.SaveGameBlueprint = SaveGameBlueprint;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.CreateSaveGameObject
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UClass*                  SaveGameClass                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USaveGame*               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class USaveGame* UGameplayStatics::STATIC_CreateSaveGameObject(class UClass* SaveGameClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf043985e);

		UGameplayStatics_CreateSaveGameObject_Params params;
		params.SaveGameClass = SaveGameClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.CreatePlayer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ControllerId                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSpawnPawn                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class APlayerController*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class APlayerController* UGameplayStatics::STATIC_CreatePlayer(class UObject* WorldContextObject, int ControllerId, bool bSpawnPawn) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe06547b1);

		UGameplayStatics_CreatePlayer_Params params;
		params.WorldContextObject = WorldContextObject;
		params.ControllerId = ControllerId;
		params.bSpawnPawn = bSpawnPawn;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.ClearSoundMixModifiers
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_ClearSoundMixModifiers(class UObject* WorldContextObject) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb9e85e12);

		UGameplayStatics_ClearSoundMixModifiers_Params params;
		params.WorldContextObject = WorldContextObject;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.ClearSoundMixClassOverride
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundMix*               InSoundMixModifier             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class USoundClass*             InSoundClass                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FadeOutTime                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_ClearSoundMixClassOverride(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float FadeOutTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b249a10);

		UGameplayStatics_ClearSoundMixClassOverride_Params params;
		params.WorldContextObject = WorldContextObject;
		params.InSoundMixModifier = InSoundMixModifier;
		params.InSoundClass = InSoundClass;
		params.FadeOutTime = FadeOutTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.CancelAsyncLoading
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UGameplayStatics::STATIC_CancelAsyncLoading() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4650ed84);

		UGameplayStatics_CancelAsyncLoading_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.BreakHitResult
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FHitResult              Hit                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bBlockingHit                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bInitialOverlap                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Time                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ImpactPoint                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Normal                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ImpactNormal                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPhysicalMaterial*       PhysMat                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  HitActor                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UPrimitiveComponent*     HitComponent                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FName                   HitBoneName                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            HitItem                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            FaceIndex                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 TraceStart                     (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 TraceEnd                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_BreakHitResult(const struct FHitResult& Hit, bool* bBlockingHit, bool* bInitialOverlap, float* Time, struct FVector* Location, struct FVector* ImpactPoint, struct FVector* Normal, struct FVector* ImpactNormal, class UPhysicalMaterial** PhysMat, class AActor** HitActor, class UPrimitiveComponent** HitComponent, struct FName* HitBoneName, int* HitItem, int* FaceIndex, struct FVector* TraceStart, struct FVector* TraceEnd) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9014f561);

		UGameplayStatics_BreakHitResult_Params params;
		params.Hit = Hit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (bBlockingHit != nullptr)
			*bBlockingHit = params.bBlockingHit;
		if (bInitialOverlap != nullptr)
			*bInitialOverlap = params.bInitialOverlap;
		if (Time != nullptr)
			*Time = params.Time;
		if (Location != nullptr)
			*Location = params.Location;
		if (ImpactPoint != nullptr)
			*ImpactPoint = params.ImpactPoint;
		if (Normal != nullptr)
			*Normal = params.Normal;
		if (ImpactNormal != nullptr)
			*ImpactNormal = params.ImpactNormal;
		if (PhysMat != nullptr)
			*PhysMat = params.PhysMat;
		if (HitActor != nullptr)
			*HitActor = params.HitActor;
		if (HitComponent != nullptr)
			*HitComponent = params.HitComponent;
		if (HitBoneName != nullptr)
			*HitBoneName = params.HitBoneName;
		if (HitItem != nullptr)
			*HitItem = params.HitItem;
		if (FaceIndex != nullptr)
			*FaceIndex = params.FaceIndex;
		if (TraceStart != nullptr)
			*TraceStart = params.TraceStart;
		if (TraceEnd != nullptr)
			*TraceEnd = params.TraceEnd;
	}


	// Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 TossVelocity                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 StartLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 EndLocation                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LaunchSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OverrideGravityZ               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESuggestProjVelocityTraceOption> TraceOption                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CollisionRadius                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bFavorHighArc                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bDrawDebug                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_BlueprintSuggestProjectileVelocity(class UObject* WorldContextObject, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, TEnumAsByte<ESuggestProjVelocityTraceOption> TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug, struct FVector* TossVelocity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc3b7e44f);

		UGameplayStatics_BlueprintSuggestProjectileVelocity_Params params;
		params.WorldContextObject = WorldContextObject;
		params.StartLocation = StartLocation;
		params.EndLocation = EndLocation;
		params.LaunchSpeed = LaunchSpeed;
		params.OverrideGravityZ = OverrideGravityZ;
		params.TraceOption = TraceOption;
		params.CollisionRadius = CollisionRadius;
		params.bFavorHighArc = bFavorHighArc;
		params.bDrawDebug = bDrawDebug;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (TossVelocity != nullptr)
			*TossVelocity = params.TossVelocity;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.BeginSpawningActorFromClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ActorClass                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              SpawnTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bNoCollisionFail               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  Owner                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* UGameplayStatics::STATIC_BeginSpawningActorFromClass(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& SpawnTransform, bool bNoCollisionFail, class AActor* Owner) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd85340e3);

		UGameplayStatics_BeginSpawningActorFromClass_Params params;
		params.WorldContextObject = WorldContextObject;
		params.ActorClass = ActorClass;
		params.SpawnTransform = SpawnTransform;
		params.bNoCollisionFail = bNoCollisionFail;
		params.Owner = Owner;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UBlueprint*              Blueprint                      (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              SpawnTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bNoCollisionFail               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* UGameplayStatics::STATIC_BeginSpawningActorFromBlueprint(class UObject* WorldContextObject, class UBlueprint* Blueprint, const struct FTransform& SpawnTransform, bool bNoCollisionFail) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc4555d1e);

		UGameplayStatics_BeginSpawningActorFromBlueprint_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Blueprint = Blueprint;
		params.SpawnTransform = SpawnTransform;
		params.bNoCollisionFail = bNoCollisionFail;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ActorClass                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              SpawnTransform                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<ESpawnActorCollisionHandlingMethod> CollisionHandlingOverride      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  Owner                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* UGameplayStatics::STATIC_BeginDeferredActorSpawnFromClass(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& SpawnTransform, TEnumAsByte<ESpawnActorCollisionHandlingMethod> CollisionHandlingOverride, class AActor* Owner) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa16cfec8);

		UGameplayStatics_BeginDeferredActorSpawnFromClass_Params params;
		params.WorldContextObject = WorldContextObject;
		params.ActorClass = ActorClass;
		params.SpawnTransform = SpawnTransform;
		params.CollisionHandlingOverride = CollisionHandlingOverride;
		params.Owner = Owner;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.AreSubtitlesEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_AreSubtitlesEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5470ac8a);

		UGameplayStatics_AreSubtitlesEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.AreAnyListenersWithinRange
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaximumRange                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_AreAnyListenersWithinRange(class UObject* WorldContextObject, const struct FVector& Location, float MaximumRange) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54d29563);

		UGameplayStatics_AreAnyListenersWithinRange_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Location = Location;
		params.MaximumRange = MaximumRange;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BaseDamage                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MinimumDamage                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          DamageInnerRadius              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DamageOuterRadius              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DamageFalloff                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  DamageTypeClass                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          IgnoreActors                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class AActor*                  DamageCauser                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AController*             InstigatedByController         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> DamagePreventionChannel        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_ApplyRadialDamageWithFalloff(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, TEnumAsByte<ECollisionChannel> DamagePreventionChannel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x65f02312);

		UGameplayStatics_ApplyRadialDamageWithFalloff_Params params;
		params.WorldContextObject = WorldContextObject;
		params.BaseDamage = BaseDamage;
		params.MinimumDamage = MinimumDamage;
		params.Origin = Origin;
		params.DamageInnerRadius = DamageInnerRadius;
		params.DamageOuterRadius = DamageOuterRadius;
		params.DamageFalloff = DamageFalloff;
		params.DamageTypeClass = DamageTypeClass;
		params.IgnoreActors = IgnoreActors;
		params.DamageCauser = DamageCauser;
		params.InstigatedByController = InstigatedByController;
		params.DamagePreventionChannel = DamagePreventionChannel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.ApplyRadialDamage
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BaseDamage                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Origin                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          DamageRadius                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  DamageTypeClass                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          IgnoreActors                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class AActor*                  DamageCauser                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AController*             InstigatedByController         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bDoFullDamage                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ECollisionChannel> DamagePreventionChannel        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UGameplayStatics::STATIC_ApplyRadialDamage(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, TEnumAsByte<ECollisionChannel> DamagePreventionChannel) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xec65fc60);

		UGameplayStatics_ApplyRadialDamage_Params params;
		params.WorldContextObject = WorldContextObject;
		params.BaseDamage = BaseDamage;
		params.Origin = Origin;
		params.DamageRadius = DamageRadius;
		params.DamageTypeClass = DamageTypeClass;
		params.IgnoreActors = IgnoreActors;
		params.DamageCauser = DamageCauser;
		params.InstigatedByController = InstigatedByController;
		params.bDoFullDamage = bDoFullDamage;
		params.DamagePreventionChannel = DamagePreventionChannel;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.GameplayStatics.ApplyPointDamage
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  DamagedActor                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BaseDamage                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 HitFromDirection               (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FHitResult              HitInfo                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// class AController*             EventInstigator                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  DamageCauser                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  DamageTypeClass                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbb766603);

		UGameplayStatics_ApplyPointDamage_Params params;
		params.DamagedActor = DamagedActor;
		params.BaseDamage = BaseDamage;
		params.HitFromDirection = HitFromDirection;
		params.HitInfo = HitInfo;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTypeClass = DamageTypeClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.ApplyDamage
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class AActor*                  DamagedActor                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BaseDamage                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AController*             EventInstigator                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class AActor*                  DamageCauser                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  DamageTypeClass                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc830efa1);

		UGameplayStatics_ApplyDamage_Params params;
		params.DamagedActor = DamagedActor;
		params.BaseDamage = BaseDamage;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTypeClass = DamageTypeClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.GameplayStatics.ActivateReverbEffect
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UReverbEffect*           ReverbEffect                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   TagName                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Priority                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Volume                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FadeTime                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UGameplayStatics::STATIC_ActivateReverbEffect(class UObject* WorldContextObject, class UReverbEffect* ReverbEffect, const struct FName& TagName, float Priority, float Volume, float FadeTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbeb02a86);

		UGameplayStatics_ActivateReverbEffect_Params params;
		params.WorldContextObject = WorldContextObject;
		params.ReverbEffect = ReverbEffect;
		params.TagName = TagName;
		params.Priority = Priority;
		params.Volume = Volume;
		params.FadeTime = FadeTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.SetWorldToMetersScale
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NewScale                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_SetWorldToMetersScale(class UObject* WorldContext, float NewScale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc25c3637);

		UHeadMountedDisplayFunctionLibrary_SetWorldToMetersScale_Params params;
		params.WorldContext = WorldContext;
		params.NewScale = NewScale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.SetTrackingOrigin
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<EHMDTrackingOrigin> Origin                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_SetTrackingOrigin(TEnumAsByte<EHMDTrackingOrigin> Origin) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ac7be3b);

		UHeadMountedDisplayFunctionLibrary_SetTrackingOrigin_Params params;
		params.Origin = Origin;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.SetClippingPlanes
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Near                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Far                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_SetClippingPlanes(float Near, float Far) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9db4439d);

		UHeadMountedDisplayFunctionLibrary_SetClippingPlanes_Params params;
		params.Near = Near;
		params.Far = Far;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.ResetOrientationAndPosition
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Yaw                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EOrientPositionSelector> Options                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_ResetOrientationAndPosition(float Yaw, TEnumAsByte<EOrientPositionSelector> Options) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf9d515a7);

		UHeadMountedDisplayFunctionLibrary_ResetOrientationAndPosition_Params params;
		params.Yaw = Yaw;
		params.Options = Options;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.IsInLowPersistenceMode
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UHeadMountedDisplayFunctionLibrary::STATIC_IsInLowPersistenceMode() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8252f3c1);

		UHeadMountedDisplayFunctionLibrary_IsInLowPersistenceMode_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.IsHeadMountedDisplayEnabled
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UHeadMountedDisplayFunctionLibrary::STATIC_IsHeadMountedDisplayEnabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe0e2976d);

		UHeadMountedDisplayFunctionLibrary_IsHeadMountedDisplayEnabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.HasValidTrackingPosition
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UHeadMountedDisplayFunctionLibrary::STATIC_HasValidTrackingPosition() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ced9716);

		UHeadMountedDisplayFunctionLibrary_HasValidTrackingPosition_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetWorldToMetersScale
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 WorldContext                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UHeadMountedDisplayFunctionLibrary::STATIC_GetWorldToMetersScale(class UObject* WorldContext) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4bf829db);

		UHeadMountedDisplayFunctionLibrary_GetWorldToMetersScale_Params params;
		params.WorldContext = WorldContext;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetVRFocusState
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           bUseFocus                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bHasFocus                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_GetVRFocusState(bool* bUseFocus, bool* bHasFocus) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x91011f6d);

		UHeadMountedDisplayFunctionLibrary_GetVRFocusState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (bUseFocus != nullptr)
			*bUseFocus = params.bUseFocus;
		if (bHasFocus != nullptr)
			*bHasFocus = params.bHasFocus;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetTrackingSensorParameters
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Origin                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          LeftFOV                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          RightFOV                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          TopFOV                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BottomFOV                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Distance                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NearPlane                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FarPlane                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           IsActive                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_GetTrackingSensorParameters(int Index, struct FVector* Origin, struct FRotator* Rotation, float* LeftFOV, float* RightFOV, float* TopFOV, float* BottomFOV, float* Distance, float* NearPlane, float* FarPlane, bool* IsActive) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbdbec01b);

		UHeadMountedDisplayFunctionLibrary_GetTrackingSensorParameters_Params params;
		params.Index = Index;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Origin != nullptr)
			*Origin = params.Origin;
		if (Rotation != nullptr)
			*Rotation = params.Rotation;
		if (LeftFOV != nullptr)
			*LeftFOV = params.LeftFOV;
		if (RightFOV != nullptr)
			*RightFOV = params.RightFOV;
		if (TopFOV != nullptr)
			*TopFOV = params.TopFOV;
		if (BottomFOV != nullptr)
			*BottomFOV = params.BottomFOV;
		if (Distance != nullptr)
			*Distance = params.Distance;
		if (NearPlane != nullptr)
			*NearPlane = params.NearPlane;
		if (FarPlane != nullptr)
			*FarPlane = params.FarPlane;
		if (IsActive != nullptr)
			*IsActive = params.IsActive;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetTrackingOrigin
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TEnumAsByte<EHMDTrackingOrigin> ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	TEnumAsByte<EHMDTrackingOrigin> UHeadMountedDisplayFunctionLibrary::STATIC_GetTrackingOrigin() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ceb1af);

		UHeadMountedDisplayFunctionLibrary_GetTrackingOrigin_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetScreenPercentage
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UHeadMountedDisplayFunctionLibrary::STATIC_GetScreenPercentage() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ac9415e);

		UHeadMountedDisplayFunctionLibrary_GetScreenPercentage_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetPositionalTrackingCameraParameters
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 CameraOrigin                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                CameraRotation                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          HFOV                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          VFOV                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CameraDistance                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NearPlane                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FarPlane                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_GetPositionalTrackingCameraParameters(struct FVector* CameraOrigin, struct FRotator* CameraRotation, float* HFOV, float* VFOV, float* CameraDistance, float* NearPlane, float* FarPlane) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1dd2e462);

		UHeadMountedDisplayFunctionLibrary_GetPositionalTrackingCameraParameters_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (CameraOrigin != nullptr)
			*CameraOrigin = params.CameraOrigin;
		if (CameraRotation != nullptr)
			*CameraRotation = params.CameraRotation;
		if (HFOV != nullptr)
			*HFOV = params.HFOV;
		if (VFOV != nullptr)
			*VFOV = params.VFOV;
		if (CameraDistance != nullptr)
			*CameraDistance = params.CameraDistance;
		if (NearPlane != nullptr)
			*NearPlane = params.NearPlane;
		if (FarPlane != nullptr)
			*FarPlane = params.FarPlane;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetOrientationAndPosition
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                DeviceRotation                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 DevicePosition                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_GetOrientationAndPosition(struct FRotator* DeviceRotation, struct FVector* DevicePosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2f9b0e22);

		UHeadMountedDisplayFunctionLibrary_GetOrientationAndPosition_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (DeviceRotation != nullptr)
			*DeviceRotation = params.DeviceRotation;
		if (DevicePosition != nullptr)
			*DevicePosition = params.DevicePosition;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetNumOfTrackingSensors
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UHeadMountedDisplayFunctionLibrary::STATIC_GetNumOfTrackingSensors() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9772cdf);

		UHeadMountedDisplayFunctionLibrary_GetNumOfTrackingSensors_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.GetHMDDeviceName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName UHeadMountedDisplayFunctionLibrary::STATIC_GetHMDDeviceName() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc05c8296);

		UHeadMountedDisplayFunctionLibrary_GetHMDDeviceName_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.EnableLowPersistenceMode
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UHeadMountedDisplayFunctionLibrary::STATIC_EnableLowPersistenceMode(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfeab95e9);

		UHeadMountedDisplayFunctionLibrary_EnableLowPersistenceMode_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.HeadMountedDisplayFunctionLibrary.EnableHMD
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bEnable                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UHeadMountedDisplayFunctionLibrary::STATIC_EnableHMD(bool bEnable) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab4934de);

		UHeadMountedDisplayFunctionLibrary_EnableHMD_Params params;
		params.bEnable = bEnable;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetArrayLibrary.SetArrayPropertyByName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 Object                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   PropertyName                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<int>                    Value                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UKismetArrayLibrary::STATIC_SetArrayPropertyByName(class UObject* Object, const struct FName& PropertyName, TArray<int> Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x401ec1dc);

		UKismetArrayLibrary_SetArrayPropertyByName_Params params;
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetArrayLibrary.FilterArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<class AActor*>          TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// class UClass*                  FilterClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<class AActor*>          FilteredArray                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UKismetArrayLibrary::STATIC_FilterArray(TArray<class AActor*> TargetArray, class UClass* FilterClass, TArray<class AActor*>* FilteredArray) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc791b82f);

		UKismetArrayLibrary_FilterArray_Params params;
		params.TargetArray = TargetArray;
		params.FilterClass = FilterClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (FilteredArray != nullptr)
			*FilteredArray = params.FilteredArray;
	}


	// Function Engine.KismetArrayLibrary.Array_Shuffle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UKismetArrayLibrary::STATIC_Array_Shuffle(TArray<int> TargetArray) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f1fa463);

		UKismetArrayLibrary_Array_Shuffle_Params params;
		params.TargetArray = TargetArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetArrayLibrary.Array_Set
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Item                           (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bSizeToFit                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetArrayLibrary::STATIC_Array_Set(TArray<int> TargetArray, int Index, int Item, bool bSizeToFit) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1e64e9d8);

		UKismetArrayLibrary_Array_Set_Params params;
		params.TargetArray = TargetArray;
		params.Index = Index;
		params.Item = Item;
		params.bSizeToFit = bSizeToFit;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetArrayLibrary.Array_Resize
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            Size                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetArrayLibrary::STATIC_Array_Resize(TArray<int> TargetArray, int Size) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8f49efa0);

		UKismetArrayLibrary_Array_Resize_Params params;
		params.TargetArray = TargetArray;
		params.Size = Size;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetArrayLibrary.Array_RemoveItem
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            Item                           (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetArrayLibrary::STATIC_Array_RemoveItem(TArray<int> TargetArray, int Item) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7c718e6d);

		UKismetArrayLibrary_Array_RemoveItem_Params params;
		params.TargetArray = TargetArray;
		params.Item = Item;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetArrayLibrary.Array_Remove
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            IndexToRemove                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetArrayLibrary::STATIC_Array_Remove(TArray<int> TargetArray, int IndexToRemove) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x84131230);

		UKismetArrayLibrary_Array_Remove_Params params;
		params.TargetArray = TargetArray;
		params.IndexToRemove = IndexToRemove;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetArrayLibrary.Array_Length
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetArrayLibrary::STATIC_Array_Length(TArray<int> TargetArray) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd6b24e7c);

		UKismetArrayLibrary_Array_Length_Params params;
		params.TargetArray = TargetArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetArrayLibrary.Array_LastIndex
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetArrayLibrary::STATIC_Array_LastIndex(TArray<int> TargetArray) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbb1aab6c);

		UKismetArrayLibrary_Array_LastIndex_Params params;
		params.TargetArray = TargetArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetArrayLibrary.Array_IsValidIndex
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            IndexToTest                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetArrayLibrary::STATIC_Array_IsValidIndex(TArray<int> TargetArray, int IndexToTest) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa939a2e2);

		UKismetArrayLibrary_Array_IsValidIndex_Params params;
		params.TargetArray = TargetArray;
		params.IndexToTest = IndexToTest;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetArrayLibrary.Array_Insert
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            NewItem                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetArrayLibrary::STATIC_Array_Insert(TArray<int> TargetArray, int NewItem, int Index) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x971ef0b7);

		UKismetArrayLibrary_Array_Insert_Params params;
		params.TargetArray = TargetArray;
		params.NewItem = NewItem;
		params.Index = Index;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetArrayLibrary.Array_Get
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Item                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetArrayLibrary::STATIC_Array_Get(TArray<int> TargetArray, int Index, int* Item) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x95302dfc);

		UKismetArrayLibrary_Array_Get_Params params;
		params.TargetArray = TargetArray;
		params.Index = Index;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Item != nullptr)
			*Item = params.Item;
	}


	// Function Engine.KismetArrayLibrary.Array_Find
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            ItemToFind                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetArrayLibrary::STATIC_Array_Find(TArray<int> TargetArray, int ItemToFind) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xea9605d9);

		UKismetArrayLibrary_Array_Find_Params params;
		params.TargetArray = TargetArray;
		params.ItemToFind = ItemToFind;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetArrayLibrary.Array_Contains
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            ItemToFind                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetArrayLibrary::STATIC_Array_Contains(TArray<int> TargetArray, int ItemToFind) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6f8191b3);

		UKismetArrayLibrary_Array_Contains_Params params;
		params.TargetArray = TargetArray;
		params.ItemToFind = ItemToFind;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetArrayLibrary.Array_Clear
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UKismetArrayLibrary::STATIC_Array_Clear(TArray<int> TargetArray) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x70f118ef);

		UKismetArrayLibrary_Array_Clear_Params params;
		params.TargetArray = TargetArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetArrayLibrary.Array_Append
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TArray<int>                    SourceArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UKismetArrayLibrary::STATIC_Array_Append(TArray<int> TargetArray, TArray<int> SourceArray) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9ffd7cb0);

		UKismetArrayLibrary_Array_Append_Params params;
		params.TargetArray = TargetArray;
		params.SourceArray = SourceArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetArrayLibrary.Array_AddUnique
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            NewItem                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetArrayLibrary::STATIC_Array_AddUnique(TArray<int> TargetArray, int NewItem) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x45204748);

		UKismetArrayLibrary_Array_AddUnique_Params params;
		params.TargetArray = TargetArray;
		params.NewItem = NewItem;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetArrayLibrary.Array_Add
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// TArray<int>                    TargetArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            NewItem                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetArrayLibrary::STATIC_Array_Add(TArray<int> TargetArray, int NewItem) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x20f94ee1);

		UKismetArrayLibrary_Array_Add_Params params;
		params.TargetArray = TargetArray;
		params.NewItem = NewItem;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetGuidLibrary.Parse_StringToGuid
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 GuidString                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FGuid                   OutGuid                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           Success                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetGuidLibrary::STATIC_Parse_StringToGuid(const struct FString& GuidString, struct FGuid* OutGuid, bool* Success) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x99f2f575);

		UKismetGuidLibrary_Parse_StringToGuid_Params params;
		params.GuidString = GuidString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutGuid != nullptr)
			*OutGuid = params.OutGuid;
		if (Success != nullptr)
			*Success = params.Success;
	}


	// Function Engine.KismetGuidLibrary.NotEqual_GuidGuid
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FGuid                   A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FGuid                   B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetGuidLibrary::STATIC_NotEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xafb23c3a);

		UKismetGuidLibrary_NotEqual_GuidGuid_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetGuidLibrary.NewGuid
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FGuid                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FGuid UKismetGuidLibrary::STATIC_NewGuid() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x662440ef);

		UKismetGuidLibrary_NewGuid_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetGuidLibrary.IsValid_Guid
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FGuid                   InGuid                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetGuidLibrary::STATIC_IsValid_Guid(const struct FGuid& InGuid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x19503a20);

		UKismetGuidLibrary_IsValid_Guid_Params params;
		params.InGuid = InGuid;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetGuidLibrary.Invalidate_Guid
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FGuid                   InGuid                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetGuidLibrary::STATIC_Invalidate_Guid(struct FGuid* InGuid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb6e1f5d7);

		UKismetGuidLibrary_Invalidate_Guid_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (InGuid != nullptr)
			*InGuid = params.InGuid;
	}


	// Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FGuid                   A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FGuid                   B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetGuidLibrary::STATIC_EqualEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf583625);

		UKismetGuidLibrary_EqualEqual_GuidGuid_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetGuidLibrary.Conv_GuidToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FGuid                   InGuid                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetGuidLibrary::STATIC_Conv_GuidToString(const struct FGuid& InGuid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x780cdf64);

		UKismetGuidLibrary_Conv_GuidToString_Params params;
		params.InGuid = InGuid;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_PointerEvent_IsTouchEvent(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x354347cc);

		UKismetInputLibrary_PointerEvent_IsTouchEvent_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FKey                    MouseButton                    (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_PointerEvent_IsMouseButtonDown(const struct FPointerEvent& Input, const struct FKey& MouseButton) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6efac460);

		UKismetInputLibrary_PointerEvent_IsMouseButtonDown_Params params;
		params.Input = Input;
		params.MouseButton = MouseButton;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetInputLibrary::STATIC_PointerEvent_GetWheelDelta(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x31a4deb4);

		UKismetInputLibrary_PointerEvent_GetWheelDelta_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetInputLibrary::STATIC_PointerEvent_GetUserIndex(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf93499dc);

		UKismetInputLibrary_PointerEvent_GetUserIndex_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetInputLibrary::STATIC_PointerEvent_GetTouchpadIndex(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9be02cab);

		UKismetInputLibrary_PointerEvent_GetTouchpadIndex_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetScreenSpacePosition(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x25530190);

		UKismetInputLibrary_PointerEvent_GetScreenSpacePosition_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetInputLibrary::STATIC_PointerEvent_GetPointerIndex(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5cafeb4);

		UKismetInputLibrary_PointerEvent_GetPointerIndex_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetLastScreenSpacePosition(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb82b4020);

		UKismetInputLibrary_PointerEvent_GetLastScreenSpacePosition_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetGestureDelta(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79b00894);

		UKismetInputLibrary_PointerEvent_GetGestureDelta_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FKey                    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FKey UKismetInputLibrary::STATIC_PointerEvent_GetEffectingButton(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x77a8952e);

		UKismetInputLibrary_PointerEvent_GetEffectingButton_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FPointerEvent           Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetCursorDelta(const struct FPointerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2fb487a7);

		UKismetInputLibrary_PointerEvent_GetCursorDelta_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.Key_IsVectorAxis
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FKey                    Key                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_Key_IsVectorAxis(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef158c6f);

		UKismetInputLibrary_Key_IsVectorAxis_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.Key_IsMouseButton
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FKey                    Key                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_Key_IsMouseButton(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe5d480be);

		UKismetInputLibrary_Key_IsMouseButton_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.Key_IsModifierKey
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FKey                    Key                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_Key_IsModifierKey(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfab174bf);

		UKismetInputLibrary_Key_IsModifierKey_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.Key_IsKeyboardKey
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FKey                    Key                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_Key_IsKeyboardKey(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaa9e7307);

		UKismetInputLibrary_Key_IsKeyboardKey_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.Key_IsGamepadKey
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FKey                    Key                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_Key_IsGamepadKey(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3c8380db);

		UKismetInputLibrary_Key_IsGamepadKey_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.Key_IsFloatAxis
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FKey                    Key                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_Key_IsFloatAxis(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb79eaaba);

		UKismetInputLibrary_Key_IsFloatAxis_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.Key_GetDisplayName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FKey                    Key                            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetInputLibrary::STATIC_Key_GetDisplayName(const struct FKey& Key) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd08cda5a);

		UKismetInputLibrary_Key_GetDisplayName_Params params;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsShiftDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsShiftDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x81b2e2e8);

		UKismetInputLibrary_InputEvent_IsShiftDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsRightShiftDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x45b5dc3e);

		UKismetInputLibrary_InputEvent_IsRightShiftDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsRightControlDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb2c9f001);

		UKismetInputLibrary_InputEvent_IsRightControlDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsRightCommandDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8b2831d5);

		UKismetInputLibrary_InputEvent_IsRightCommandDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsRightAltDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfd521cfb);

		UKismetInputLibrary_InputEvent_IsRightAltDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsRepeat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsRepeat(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf157145);

		UKismetInputLibrary_InputEvent_IsRepeat_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsLeftShiftDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe47b638d);

		UKismetInputLibrary_InputEvent_IsLeftShiftDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsLeftControlDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x33899e8e);

		UKismetInputLibrary_InputEvent_IsLeftControlDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsLeftCommandDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xafde70ca);

		UKismetInputLibrary_InputEvent_IsLeftCommandDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsLeftAltDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2ad0fac);

		UKismetInputLibrary_InputEvent_IsLeftAltDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsControlDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsControlDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96f2cb67);

		UKismetInputLibrary_InputEvent_IsControlDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsCommandDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsCommandDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x959291f3);

		UKismetInputLibrary_InputEvent_IsCommandDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.InputEvent_IsAltDown
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputEvent             Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_InputEvent_IsAltDown(const struct FInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x557578bd);

		UKismetInputLibrary_InputEvent_IsAltDown_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.GetUserIndex
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FKeyEvent               Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetInputLibrary::STATIC_GetUserIndex(const struct FKeyEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe884af96);

		UKismetInputLibrary_GetUserIndex_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.GetKey
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FKeyEvent               Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FKey                    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FKey UKismetInputLibrary::STATIC_GetKey(const struct FKeyEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26c96f98);

		UKismetInputLibrary_GetKey_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.GetAnalogValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FAnalogInputEvent       Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetInputLibrary::STATIC_GetAnalogValue(const struct FAnalogInputEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x865a1536);

		UKismetInputLibrary_GetAnalogValue_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.EqualEqual_KeyKey
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FKey                    A                              (CPF_Parm)
	// struct FKey                    B                              (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_EqualEqual_KeyKey(const struct FKey& A, const struct FKey& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf46a0cea);

		UKismetInputLibrary_EqualEqual_KeyKey_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.EqualEqual_InputChordInputChord
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FInputChord             A                              (CPF_Parm)
	// struct FInputChord             B                              (CPF_Parm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetInputLibrary::STATIC_EqualEqual_InputChordInputChord(const struct FInputChord& A, const struct FInputChord& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xffc1f3a4);

		UKismetInputLibrary_EqualEqual_InputChordInputChord_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.ControllerEvent_GetUserIndex
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FControllerEvent        Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetInputLibrary::STATIC_ControllerEvent_GetUserIndex(const struct FControllerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9104c1a5);

		UKismetInputLibrary_ControllerEvent_GetUserIndex_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.ControllerEvent_GetEffectingButton
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FControllerEvent        Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FKey                    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FKey UKismetInputLibrary::STATIC_ControllerEvent_GetEffectingButton(const struct FControllerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6c5757c3);

		UKismetInputLibrary_ControllerEvent_GetEffectingButton_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.ControllerEvent_GetAnalogValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FControllerEvent        Input                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetInputLibrary::STATIC_ControllerEvent_GetAnalogValue(const struct FControllerEvent& Input) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1730e919);

		UKismetInputLibrary_ControllerEvent_GetAnalogValue_Params params;
		params.Input = Input;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetInputLibrary.CalibrateTilt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UKismetInputLibrary::STATIC_CalibrateTilt() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x50317cb1);

		UKismetInputLibrary_CalibrateTilt_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetMaterialLibrary.SetVectorParameterValue
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialParameterCollection* Collection                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ParameterValue                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)

	void UKismetMaterialLibrary::STATIC_SetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const struct FName& ParameterName, const struct FLinearColor& ParameterValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa07f732f);

		UKismetMaterialLibrary_SetVectorParameterValue_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		params.ParameterName = ParameterName;
		params.ParameterValue = ParameterValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetMaterialLibrary.SetScalarParameterValue
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialParameterCollection* Collection                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ParameterValue                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMaterialLibrary::STATIC_SetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const struct FName& ParameterName, float ParameterValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd16b1f5e);

		UKismetMaterialLibrary_SetScalarParameterValue_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		params.ParameterName = ParameterName;
		params.ParameterValue = ParameterValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetMaterialLibrary.GetVectorParameterValue
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialParameterCollection* Collection                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMaterialLibrary::STATIC_GetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const struct FName& ParameterName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe63283f3);

		UKismetMaterialLibrary_GetVectorParameterValue_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		params.ParameterName = ParameterName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMaterialLibrary.GetScalarParameterValue
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialParameterCollection* Collection                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMaterialLibrary::STATIC_GetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const struct FName& ParameterName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe70f923a);

		UKismetMaterialLibrary_GetScalarParameterValue_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		params.ParameterName = ParameterName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      Parent                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInstanceDynamic* ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UMaterialInstanceDynamic* UKismetMaterialLibrary::STATIC_CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UMaterialInterface* Parent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x597e33bf);

		UKismetMaterialLibrary_CreateDynamicMaterialInstance_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Parent = Parent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Xor_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Xor_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6a046e53);

		UKismetMathLibrary_Xor_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VSizeSquared
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_VSizeSquared(const struct FVector& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa00034d7);

		UKismetMathLibrary_VSizeSquared_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VSize2DSquared
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_VSize2DSquared(const struct FVector2D& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x610f42c5);

		UKismetMathLibrary_VSize2DSquared_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VSize2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_VSize2D(const struct FVector2D& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd923ff5e);

		UKismetMathLibrary_VSize2D_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VSize
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_VSize(const struct FVector& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x683cd094);

		UKismetMathLibrary_VSize_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VLerp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_VLerp(const struct FVector& A, const struct FVector& B, float Alpha) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54441078);

		UKismetMathLibrary_VLerp_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VInterpTo_Constant
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_VInterpTo_Constant(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb4ecc0ed);

		UKismetMathLibrary_VInterpTo_Constant_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VInterpTo
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_VInterpTo(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa5e5be02);

		UKismetMathLibrary_VInterpTo_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VectorSpringInterp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVectorSpringState      SpringState                    (CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          Stiffness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CriticalDampingFactor          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Mass                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_VectorSpringInterp(const struct FVector& Current, const struct FVector& Target, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, struct FVectorSpringState* SpringState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb06de36b);

		UKismetMathLibrary_VectorSpringInterp_Params params;
		params.Current = Current;
		params.Target = Target;
		params.Stiffness = Stiffness;
		params.CriticalDampingFactor = CriticalDampingFactor;
		params.DeltaTime = DeltaTime;
		params.Mass = Mass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SpringState != nullptr)
			*SpringState = params.SpringState;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Vector2DInterpTo_Constant(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa5e44780);

		UKismetMathLibrary_Vector2DInterpTo_Constant_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Vector2DInterpTo
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Vector2DInterpTo(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x81f0c5f9);

		UKismetMathLibrary_Vector2DInterpTo_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.VEase
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EEasingFunc>       EasingFunc                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendExp                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Steps                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_VEase(const struct FVector& A, const struct FVector& B, float Alpha, TEnumAsByte<EEasingFunc> EasingFunc, float BlendExp, int Steps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbe4faa0d);

		UKismetMathLibrary_VEase_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.UtcNow
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_UtcNow() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd12ad8b9);

		UKismetMathLibrary_UtcNow_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TransformLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              T                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_TransformLocation(const struct FTransform& T, const struct FVector& Location) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd00d8a80);

		UKismetMathLibrary_TransformLocation_Params params;
		params.T = T;
		params.Location = Location;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TransformDirection
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              T                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Direction                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_TransformDirection(const struct FTransform& T, const struct FVector& Direction) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x32ebef80);

		UKismetMathLibrary_TransformDirection_Params params;
		params.T = T;
		params.Direction = Direction;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Today
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_Today() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1af23fce);

		UKismetMathLibrary_Today_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TLerp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ELerpInterpolationMode> InterpMode                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_TLerp(const struct FTransform& A, const struct FTransform& B, float Alpha, TEnumAsByte<ELerpInterpolationMode> InterpMode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54049742);

		UKismetMathLibrary_TLerp_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.InterpMode = InterpMode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TInterpTo
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              Current                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              Target                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_TInterpTo(const struct FTransform& Current, const struct FTransform& Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbd3fca7c);

		UKismetMathLibrary_TInterpTo_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TimespanZeroValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_TimespanZeroValue() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x12ed24f9);

		UKismetMathLibrary_TimespanZeroValue_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TimespanRatio
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_TimespanRatio(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x139725a1);

		UKismetMathLibrary_TimespanRatio_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TimespanMinValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_TimespanMinValue() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbddc97f7);

		UKismetMathLibrary_TimespanMinValue_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TimespanMaxValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_TimespanMaxValue() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xef835a55);

		UKismetMathLibrary_TimespanMaxValue_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TimespanFromString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 TimespanString                 (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               Result                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_TimespanFromString(const struct FString& TimespanString, struct FTimespan* Result) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9dc3ede3);

		UKismetMathLibrary_TimespanFromString_Params params;
		params.TimespanString = TimespanString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Result != nullptr)
			*Result = params.Result;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.TEase
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EEasingFunc>       EasingFunc                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendExp                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Steps                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_TEase(const struct FTransform& A, const struct FTransform& B, float Alpha, TEnumAsByte<EEasingFunc> EasingFunc, float BlendExp, int Steps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ab9dd87);

		UKismetMathLibrary_TEase_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Tan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Tan(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x39858df4);

		UKismetMathLibrary_Tan_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_VectorVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Subtract_VectorVector(const struct FVector& A, const struct FVector& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8f9165a6);

		UKismetMathLibrary_Subtract_VectorVector_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_VectorInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Subtract_VectorInt(const struct FVector& A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x12785d7a);

		UKismetMathLibrary_Subtract_VectorInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_VectorFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Subtract_VectorFloat(const struct FVector& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x57c5f3df);

		UKismetMathLibrary_Subtract_VectorFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Subtract_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x27bdda82);

		UKismetMathLibrary_Subtract_Vector2DVector2D_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_Vector2DFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Subtract_Vector2DFloat(const struct FVector2D& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd7edbae5);

		UKismetMathLibrary_Subtract_Vector2DFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_TimespanTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_Subtract_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf67afdbe);

		UKismetMathLibrary_Subtract_TimespanTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Subtract_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x97bb170);

		UKismetMathLibrary_Subtract_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Subtract_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x914842c2);

		UKismetMathLibrary_Subtract_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_Subtract_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x699e4416);

		UKismetMathLibrary_Subtract_DateTimeTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               B                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_Subtract_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbfa5103a);

		UKismetMathLibrary_Subtract_DateTimeDateTime_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Subtract_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_Subtract_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa29ea16a);

		UKismetMathLibrary_Subtract_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Square
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Square(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd7e6ea06);

		UKismetMathLibrary_Square_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Sqrt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Sqrt(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa65915b9);

		UKismetMathLibrary_Sqrt_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Sin
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Sin(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xde69864b);

		UKismetMathLibrary_Sin_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SignOfInteger
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_SignOfInteger(int A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x84b29f63);

		UKismetMathLibrary_SignOfInteger_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SignOfFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_SignOfFloat(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54e4ea9b);

		UKismetMathLibrary_SignOfFloat_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SetRandomStreamSeed
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRandomStream           Stream                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            NewSeed                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_SetRandomStreamSeed(int NewSeed, struct FRandomStream* Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb14b63a7);

		UKismetMathLibrary_SetRandomStreamSeed_Params params;
		params.NewSeed = NewSeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Stream != nullptr)
			*Stream = params.Stream;
	}


	// Function Engine.KismetMathLibrary.SelectVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPickA                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_SelectVector(const struct FVector& A, const struct FVector& B, bool bPickA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7d107762);

		UKismetMathLibrary_SelectVector_Params params;
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SelectTransform
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bPickA                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_SelectTransform(const struct FTransform& A, const struct FTransform& B, bool bPickA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb9d867d);

		UKismetMathLibrary_SelectTransform_Params params;
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SelectString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           bPickA                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetMathLibrary::STATIC_SelectString(const struct FString& A, const struct FString& B, bool bPickA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xff96a12c);

		UKismetMathLibrary_SelectString_Params params;
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SelectRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPickA                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_SelectRotator(const struct FRotator& A, const struct FRotator& B, bool bPickA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb2815fe2);

		UKismetMathLibrary_SelectRotator_Params params;
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SelectObject
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UObject*                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSelectA                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UObject*                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UObject* UKismetMathLibrary::STATIC_SelectObject(class UObject* A, class UObject* B, bool bSelectA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x77b19632);

		UKismetMathLibrary_SelectObject_Params params;
		params.A = A;
		params.B = B;
		params.bSelectA = bSelectA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SelectInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPickA                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_SelectInt(int A, int B, bool bPickA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x609b9ee);

		UKismetMathLibrary_SelectInt_Params params;
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SelectFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPickA                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_SelectFloat(float A, float B, bool bPickA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc1043703);

		UKismetMathLibrary_SelectFloat_Params params;
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SelectColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bPickA                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_SelectColor(const struct FLinearColor& A, const struct FLinearColor& B, bool bPickA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaf6a3be4);

		UKismetMathLibrary_SelectColor_Params params;
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SelectClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UClass*                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSelectA                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UClass* UKismetMathLibrary::STATIC_SelectClass(class UClass* A, class UClass* B, bool bSelectA) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3a873e9);

		UKismetMathLibrary_SelectClass_Params params;
		params.A = A;
		params.B = B;
		params.bSelectA = bSelectA;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.SeedRandomStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRandomStream           Stream                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UKismetMathLibrary::STATIC_SeedRandomStream(struct FRandomStream* Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2590785);

		UKismetMathLibrary_SeedRandomStream_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Stream != nullptr)
			*Stream = params.Stream;
	}


	// Function Engine.KismetMathLibrary.Round
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Round(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x28952a0d);

		UKismetMathLibrary_Round_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Axis                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Angle                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_RotatorFromAxisAndAngle(const struct FVector& Axis, float Angle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18de6921);

		UKismetMathLibrary_RotatorFromAxisAndAngle_Params params;
		params.Axis = Axis;
		params.Angle = Angle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RotateAngleAxis
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVect                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          AngleDeg                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Axis                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_RotateAngleAxis(const struct FVector& InVect, float AngleDeg, const struct FVector& Axis) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x59c6d1d4);

		UKismetMathLibrary_RotateAngleAxis_Params params;
		params.InVect = InVect;
		params.AngleDeg = AngleDeg;
		params.Axis = Axis;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RLerp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShortestPath                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_RLerp(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4ba20a54);

		UKismetMathLibrary_RLerp_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.bShortestPath = bShortestPath;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RInterpTo_Constant
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_RInterpTo_Constant(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ec266b9);

		UKismetMathLibrary_RInterpTo_Constant_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RInterpTo
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_RInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xee3363c6);

		UKismetMathLibrary_RInterpTo_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RGBToHSV_Vector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            RGB                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            HSV                            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_RGBToHSV_Vector(const struct FLinearColor& RGB, struct FLinearColor* HSV) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26fc5e74);

		UKismetMathLibrary_RGBToHSV_Vector_Params params;
		params.RGB = RGB;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (HSV != nullptr)
			*HSV = params.HSV;
	}


	// Function Engine.KismetMathLibrary.RGBToHSV
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            InColor                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          H                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          S                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          V                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          A                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_RGBToHSV(const struct FLinearColor& InColor, float* H, float* S, float* V, float* A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfd8c0fae);

		UKismetMathLibrary_RGBToHSV_Params params;
		params.InColor = InColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (H != nullptr)
			*H = params.H;
		if (S != nullptr)
			*S = params.S;
		if (V != nullptr)
			*V = params.V;
		if (A != nullptr)
			*A = params.A;
	}


	// Function Engine.KismetMathLibrary.ResetVectorSpringState
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVectorSpringState      SpringState                    (CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetMathLibrary::STATIC_ResetVectorSpringState(struct FVectorSpringState* SpringState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x789589e5);

		UKismetMathLibrary_ResetVectorSpringState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SpringState != nullptr)
			*SpringState = params.SpringState;
	}


	// Function Engine.KismetMathLibrary.ResetRandomStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FRandomStream           Stream                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)

	void UKismetMathLibrary::STATIC_ResetRandomStream(const struct FRandomStream& Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5e01ac21);

		UKismetMathLibrary_ResetRandomStream_Params params;
		params.Stream = Stream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetMathLibrary.ResetFloatSpringState
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FFloatSpringState       SpringState                    (CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetMathLibrary::STATIC_ResetFloatSpringState(struct FFloatSpringState* SpringState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8091b284);

		UKismetMathLibrary_ResetFloatSpringState_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SpringState != nullptr)
			*SpringState = params.SpringState;
	}


	// Function Engine.KismetMathLibrary.REase
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShortestPath                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EEasingFunc>       EasingFunc                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendExp                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Steps                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_REase(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath, TEnumAsByte<EEasingFunc> EasingFunc, float BlendExp, int Steps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa0abee19);

		UKismetMathLibrary_REase_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.bShortestPath = bShortestPath;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomUnitVectorInConeWithYawAndPitch
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 ConeDir                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxYawInDegrees                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxPitchInDegrees              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_RandomUnitVectorInConeWithYawAndPitch(const struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x15b96c55);

		UKismetMathLibrary_RandomUnitVectorInConeWithYawAndPitch_Params params;
		params.ConeDir = ConeDir;
		params.MaxYawInDegrees = MaxYawInDegrees;
		params.MaxPitchInDegrees = MaxPitchInDegrees;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomUnitVectorInCone
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 ConeDir                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ConeHalfAngle                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_RandomUnitVectorInCone(const struct FVector& ConeDir, float ConeHalfAngle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x93a56345);

		UKismetMathLibrary_RandomUnitVectorInCone_Params params;
		params.ConeDir = ConeDir;
		params.ConeHalfAngle = ConeHalfAngle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomUnitVectorFromStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRandomStream           Stream                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_RandomUnitVectorFromStream(const struct FRandomStream& Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc12cb999);

		UKismetMathLibrary_RandomUnitVectorFromStream_Params params;
		params.Stream = Stream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomUnitVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_RandomUnitVector() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdda4a3b5);

		UKismetMathLibrary_RandomUnitVector_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomRotatorFromStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           bRoll                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRandomStream           Stream                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_RandomRotatorFromStream(bool bRoll, const struct FRandomStream& Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9382f549);

		UKismetMathLibrary_RandomRotatorFromStream_Params params;
		params.bRoll = bRoll;
		params.Stream = Stream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           bRoll                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_RandomRotator(bool bRoll) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf38e8a5);

		UKismetMathLibrary_RandomRotator_Params params;
		params.bRoll = bRoll;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomPointInBoundingBox
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Origin                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 BoxExtent                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_RandomPointInBoundingBox(const struct FVector& Origin, const struct FVector& BoxExtent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa15d0c7c);

		UKismetMathLibrary_RandomPointInBoundingBox_Params params;
		params.Origin = Origin;
		params.BoxExtent = BoxExtent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Min                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRandomStream           Stream                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_RandomIntegerInRangeFromStream(int Min, int Max, const struct FRandomStream& Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x197f44d4);

		UKismetMathLibrary_RandomIntegerInRangeFromStream_Params params;
		params.Min = Min;
		params.Max = Max;
		params.Stream = Stream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomIntegerInRange
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Min                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_RandomIntegerInRange(int Min, int Max) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1a71c014);

		UKismetMathLibrary_RandomIntegerInRange_Params params;
		params.Min = Min;
		params.Max = Max;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomIntegerFromStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRandomStream           Stream                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_RandomIntegerFromStream(int Max, const struct FRandomStream& Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3bda77b8);

		UKismetMathLibrary_RandomIntegerFromStream_Params params;
		params.Max = Max;
		params.Stream = Stream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomInteger
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_RandomInteger(int Max) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb319fb38);

		UKismetMathLibrary_RandomInteger_Params params;
		params.Max = Max;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Min                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRandomStream           Stream                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_RandomFloatInRangeFromStream(float Min, float Max, const struct FRandomStream& Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6691c900);

		UKismetMathLibrary_RandomFloatInRangeFromStream_Params params;
		params.Min = Min;
		params.Max = Max;
		params.Stream = Stream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomFloatInRange
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Min                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_RandomFloatInRange(float Min, float Max) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb2e7aad0);

		UKismetMathLibrary_RandomFloatInRange_Params params;
		params.Min = Min;
		params.Max = Max;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomFloatFromStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRandomStream           Stream                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_RandomFloatFromStream(const struct FRandomStream& Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc0d2277c);

		UKismetMathLibrary_RandomFloatFromStream_Params params;
		params.Stream = Stream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_RandomFloat() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa0e5a8cc);

		UKismetMathLibrary_RandomFloat_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomBoolWithWeightFromStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Weight                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRandomStream           RandomStream                   (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_RandomBoolWithWeightFromStream(float Weight, const struct FRandomStream& RandomStream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf7f5ffde);

		UKismetMathLibrary_RandomBoolWithWeightFromStream_Params params;
		params.Weight = Weight;
		params.RandomStream = RandomStream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomBoolWithWeight
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Weight                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_RandomBoolWithWeight(float Weight) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe7911742);

		UKismetMathLibrary_RandomBoolWithWeight_Params params;
		params.Weight = Weight;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomBoolFromStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRandomStream           Stream                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_RandomBoolFromStream(const struct FRandomStream& Stream) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf6f32582);

		UKismetMathLibrary_RandomBoolFromStream_Params params;
		params.Stream = Stream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RandomBool
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_RandomBool() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30ec1706);

		UKismetMathLibrary_RandomBool_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.RadiansToDegrees
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_RadiansToDegrees(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x51b5f777);

		UKismetMathLibrary_RadiansToDegrees_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ProjectVectorOnToVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 V                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_ProjectVectorOnToVector(const struct FVector& V, const struct FVector& Target) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x31431b16);

		UKismetMathLibrary_ProjectVectorOnToVector_Params params;
		params.V = V;
		params.Target = Target;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ProjectVectorOnToPlane
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 V                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PlaneNormal                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_ProjectVectorOnToPlane(const struct FVector& V, const struct FVector& PlaneNormal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75bf8e9f);

		UKismetMathLibrary_ProjectVectorOnToPlane_Params params;
		params.V = V;
		params.PlaneNormal = PlaneNormal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ProjectPointOnToPlane
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Point                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PlaneBase                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PlaneNormal                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_ProjectPointOnToPlane(const struct FVector& Point, const struct FVector& PlaneBase, const struct FVector& PlaneNormal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb3e470b2);

		UKismetMathLibrary_ProjectPointOnToPlane_Params params;
		params.Point = Point;
		params.PlaneBase = PlaneBase;
		params.PlaneNormal = PlaneNormal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.PointsAreCoplanar
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<struct FVector>         Points                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// float                          Tolerance                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_PointsAreCoplanar(TArray<struct FVector> Points, float Tolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26e3fdee);

		UKismetMathLibrary_PointsAreCoplanar_Params params;
		params.Points = Points;
		params.Tolerance = Tolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Percent_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Percent_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb3a7de7f);

		UKismetMathLibrary_Percent_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Percent_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Percent_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x38bdf69);

		UKismetMathLibrary_Percent_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Percent_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_Percent_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c7fdc91);

		UKismetMathLibrary_Percent_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Or_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Or_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xde9390bd);

		UKismetMathLibrary_Or_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Now
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_Now() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6f2b15b9);

		UKismetMathLibrary_Now_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_VectorVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ErrorTolerance                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x562923f1);

		UKismetMathLibrary_NotEqual_VectorVector_Params params;
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_Vector2DVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ErrorTolerance                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4bc19835);

		UKismetMathLibrary_NotEqual_Vector2DVector2D_Params params;
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x36dabb61);

		UKismetMathLibrary_NotEqual_TimespanTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_RotatorRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ErrorTolerance                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xccda47ef);

		UKismetMathLibrary_NotEqual_RotatorRotator_Params params;
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_ObjectObject
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UObject*                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_ObjectObject(class UObject* A, class UObject* B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8e58151);

		UKismetMathLibrary_NotEqual_ObjectObject_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_NameName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FName                   A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_NameName(const struct FName& A, const struct FName& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3e0ae2b5);

		UKismetMathLibrary_NotEqual_NameName_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x876c9c73);

		UKismetMathLibrary_NotEqual_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x112f854d);

		UKismetMathLibrary_NotEqual_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf29e7dd);

		UKismetMathLibrary_NotEqual_DateTimeDateTime_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_ClassClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UClass*                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_ClassClass(class UClass* A, class UClass* B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1d991ab1);

		UKismetMathLibrary_NotEqual_ClassClass_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4fccb285);

		UKismetMathLibrary_NotEqual_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NotEqual_BoolBool
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NotEqual_BoolBool(bool A, bool B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc71b90d);

		UKismetMathLibrary_NotEqual_BoolBool_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Not_PreBool
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Not_PreBool(bool A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe9c827f4);

		UKismetMathLibrary_Not_PreBool_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Not_Int
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Not_Int(int A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc78e732c);

		UKismetMathLibrary_Not_Int_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NormalizeToRange
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          RangeMin                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          RangeMax                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_NormalizeToRange(float Value, float RangeMin, float RangeMax) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab29df4a);

		UKismetMathLibrary_NormalizeToRange_Params params;
		params.Value = Value;
		params.RangeMin = RangeMin;
		params.RangeMax = RangeMax;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NormalizedDeltaRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_NormalizedDeltaRotator(const struct FRotator& A, const struct FRotator& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9e320af9);

		UKismetMathLibrary_NormalizedDeltaRotator_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NormalizeAxis
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Angle                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_NormalizeAxis(float Angle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x22ed31eb);

		UKismetMathLibrary_NormalizeAxis_Params params;
		params.Angle = Angle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Normal2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Normal2D(const struct FVector2D& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7dc64f00);

		UKismetMathLibrary_Normal2D_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Normal
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Normal(const struct FVector& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9af3e13a);

		UKismetMathLibrary_Normal_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NegateVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_NegateVector(const struct FVector& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x94e93924);

		UKismetMathLibrary_NegateVector_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NegateRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_NegateRotator(const struct FRotator& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x70d63068);

		UKismetMathLibrary_NegateRotator_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          LocationTolerance              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          RotationTolerance              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Scale3DTolerance               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NearlyEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2c6d123);

		UKismetMathLibrary_NearlyEqual_TransformTransform_Params params;
		params.A = A;
		params.B = B;
		params.LocationTolerance = LocationTolerance;
		params.RotationTolerance = RotationTolerance;
		params.Scale3DTolerance = Scale3DTolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ErrorTolerance                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x99f041eb);

		UKismetMathLibrary_NearlyEqual_FloatFloat_Params params;
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Base                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Exp                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_MultiplyMultiply_FloatFloat(float Base, float Exp) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ff94226);

		UKismetMathLibrary_MultiplyMultiply_FloatFloat_Params params;
		params.Base = Base;
		params.Exp = Exp;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MultiplyByPi
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_MultiplyByPi(float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5af7ed09);

		UKismetMathLibrary_MultiplyByPi_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_VectorVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Multiply_VectorVector(const struct FVector& A, const struct FVector& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd8c9afd2);

		UKismetMathLibrary_Multiply_VectorVector_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_VectorInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Multiply_VectorInt(const struct FVector& A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1b628be);

		UKismetMathLibrary_Multiply_VectorInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_VectorFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Multiply_VectorFloat(const struct FVector& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xec4fb4d3);

		UKismetMathLibrary_Multiply_VectorFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_Vector2DVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Multiply_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaa0a7e2e);

		UKismetMathLibrary_Multiply_Vector2DVector2D_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_Vector2DFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Multiply_Vector2DFloat(const struct FVector2D& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf78364e1);

		UKismetMathLibrary_Multiply_Vector2DFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_TimespanFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// float                          Scalar                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_Multiply_TimespanFloat(const struct FTimespan& A, float Scalar) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7c558969);

		UKismetMathLibrary_Multiply_TimespanFloat_Params params;
		params.A = A;
		params.Scalar = Scalar;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_RotatorInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_Multiply_RotatorInt(const struct FRotator& A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab0d884);

		UKismetMathLibrary_Multiply_RotatorInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_RotatorFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_Multiply_RotatorFloat(const struct FRotator& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf89487e5);

		UKismetMathLibrary_Multiply_RotatorFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_Multiply_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x925f61d6);

		UKismetMathLibrary_Multiply_LinearColorLinearColor_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_LinearColorFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_Multiply_LinearColorFloat(const struct FLinearColor& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe5694810);

		UKismetMathLibrary_Multiply_LinearColorFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Multiply_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ac0072c);

		UKismetMathLibrary_Multiply_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_IntFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Multiply_IntFloat(int A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3e732a0d);

		UKismetMathLibrary_Multiply_IntFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Multiply_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x82e19e3e);

		UKismetMathLibrary_Multiply_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Multiply_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_Multiply_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf0a87646);

		UKismetMathLibrary_Multiply_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MirrorVectorByNormal
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVect                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 InNormal                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_MirrorVectorByNormal(const struct FVector& InVect, const struct FVector& InNormal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8a4e3305);

		UKismetMathLibrary_MirrorVectorByNormal_Params params;
		params.InVect = InVect;
		params.InNormal = InNormal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MinOfIntArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<int>                    IntArray                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            IndexOfMinValue                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinValue                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_MinOfIntArray(TArray<int> IntArray, int* IndexOfMinValue, int* MinValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe9c559c4);

		UKismetMathLibrary_MinOfIntArray_Params params;
		params.IntArray = IntArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (IndexOfMinValue != nullptr)
			*IndexOfMinValue = params.IndexOfMinValue;
		if (MinValue != nullptr)
			*MinValue = params.MinValue;
	}


	// Function Engine.KismetMathLibrary.MinOfFloatArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<float>                  FloatArray                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            IndexOfMinValue                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MinValue                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_MinOfFloatArray(TArray<float> FloatArray, int* IndexOfMinValue, float* MinValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9dc6626b);

		UKismetMathLibrary_MinOfFloatArray_Params params;
		params.FloatArray = FloatArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (IndexOfMinValue != nullptr)
			*IndexOfMinValue = params.IndexOfMinValue;
		if (MinValue != nullptr)
			*MinValue = params.MinValue;
	}


	// Function Engine.KismetMathLibrary.MinOfByteArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<unsigned char>          ByteArray                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            IndexOfMinValue                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  MinValue                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_MinOfByteArray(TArray<unsigned char> ByteArray, int* IndexOfMinValue, unsigned char* MinValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb519736b);

		UKismetMathLibrary_MinOfByteArray_Params params;
		params.ByteArray = ByteArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (IndexOfMinValue != nullptr)
			*IndexOfMinValue = params.IndexOfMinValue;
		if (MinValue != nullptr)
			*MinValue = params.MinValue;
	}


	// Function Engine.KismetMathLibrary.MinimumAreaRectangle
	// (FUNC_Final, FUNC_BlueprintAuthorityOnly, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FVector>         InVerts                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FVector                 SampleSurfaceNormal            (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 OutRectCenter                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                OutRectRotation                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutSideLengthX                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutSideLengthY                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bDebugDraw                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_MinimumAreaRectangle(class UObject* WorldContextObject, TArray<struct FVector> InVerts, const struct FVector& SampleSurfaceNormal, bool bDebugDraw, struct FVector* OutRectCenter, struct FRotator* OutRectRotation, float* OutSideLengthX, float* OutSideLengthY) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7917f195);

		UKismetMathLibrary_MinimumAreaRectangle_Params params;
		params.WorldContextObject = WorldContextObject;
		params.InVerts = InVerts;
		params.SampleSurfaceNormal = SampleSurfaceNormal;
		params.bDebugDraw = bDebugDraw;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutRectCenter != nullptr)
			*OutRectCenter = params.OutRectCenter;
		if (OutRectRotation != nullptr)
			*OutRectRotation = params.OutRectRotation;
		if (OutSideLengthX != nullptr)
			*OutSideLengthX = params.OutSideLengthX;
		if (OutSideLengthY != nullptr)
			*OutSideLengthY = params.OutSideLengthY;
	}


	// Function Engine.KismetMathLibrary.Min
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Min(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x84b27db1);

		UKismetMathLibrary_Min_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MaxOfIntArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<int>                    IntArray                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            IndexOfMaxValue                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaxValue                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_MaxOfIntArray(TArray<int> IntArray, int* IndexOfMaxValue, int* MaxValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6da78ca6);

		UKismetMathLibrary_MaxOfIntArray_Params params;
		params.IntArray = IntArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (IndexOfMaxValue != nullptr)
			*IndexOfMaxValue = params.IndexOfMaxValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}


	// Function Engine.KismetMathLibrary.MaxOfFloatArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<float>                  FloatArray                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            IndexOfMaxValue                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxValue                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_MaxOfFloatArray(TArray<float> FloatArray, int* IndexOfMaxValue, float* MaxValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd3d19359);

		UKismetMathLibrary_MaxOfFloatArray_Params params;
		params.FloatArray = FloatArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (IndexOfMaxValue != nullptr)
			*IndexOfMaxValue = params.IndexOfMaxValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}


	// Function Engine.KismetMathLibrary.MaxOfByteArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<unsigned char>          ByteArray                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            IndexOfMaxValue                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  MaxValue                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_MaxOfByteArray(TArray<unsigned char> ByteArray, int* IndexOfMaxValue, unsigned char* MaxValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x47285579);

		UKismetMathLibrary_MaxOfByteArray_Params params;
		params.ByteArray = ByteArray;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (IndexOfMaxValue != nullptr)
			*IndexOfMaxValue = params.IndexOfMaxValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}


	// Function Engine.KismetMathLibrary.Max
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Max(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf22a5c0f);

		UKismetMathLibrary_Max_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MapRangeUnclamped
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InRangeA                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InRangeB                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutRangeA                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutRangeB                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_MapRangeUnclamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7833f68b);

		UKismetMathLibrary_MapRangeUnclamped_Params params;
		params.Value = Value;
		params.InRangeA = InRangeA;
		params.InRangeB = InRangeB;
		params.OutRangeA = OutRangeA;
		params.OutRangeB = OutRangeB;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MapRangeClamped
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InRangeA                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InRangeB                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutRangeA                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          OutRangeB                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x39f0a880);

		UKismetMathLibrary_MapRangeClamped_Params params;
		params.Value = Value;
		params.InRangeA = InRangeA;
		params.InRangeB = InRangeB;
		params.OutRangeA = OutRangeA;
		params.OutRangeB = OutRangeB;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          X                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Y                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_MakeVector2D(float X, float Y) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb0c091ca);

		UKismetMathLibrary_MakeVector2D_Params params;
		params.X = X;
		params.Y = Y;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          X                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Y                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Z                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_MakeVector(float X, float Y, float Z) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaeb3aee8);

		UKismetMathLibrary_MakeVector_Params params;
		params.X = X;
		params.Y = Y;
		params.Z = Z;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeTransform
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_MakeTransform(const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf99b0ca7);

		UKismetMathLibrary_MakeTransform_Params params;
		params.Location = Location;
		params.Rotation = Rotation;
		params.Scale = Scale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Days                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Hours                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Minutes                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Seconds                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Milliseconds                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_MakeTimespan(int Days, int Hours, int Minutes, int Seconds, int Milliseconds) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe3acd206);

		UKismetMathLibrary_MakeTimespan_Params params;
		params.Days = Days;
		params.Hours = Hours;
		params.Minutes = Minutes;
		params.Seconds = Seconds;
		params.Milliseconds = Milliseconds;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromZY
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Z                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Y                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZY(const struct FVector& Z, const struct FVector& Y) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8a7a9b07);

		UKismetMathLibrary_MakeRotFromZY_Params params;
		params.Z = Z;
		params.Y = Y;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromZX
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Z                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 X                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZX(const struct FVector& Z, const struct FVector& X) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6478209e);

		UKismetMathLibrary_MakeRotFromZX_Params params;
		params.Z = Z;
		params.X = X;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromZ
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Z                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZ(const struct FVector& Z) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1bad5f82);

		UKismetMathLibrary_MakeRotFromZ_Params params;
		params.Z = Z;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromYZ
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Y                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Z                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromYZ(const struct FVector& Y, const struct FVector& Z) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x99dbc5a1);

		UKismetMathLibrary_MakeRotFromYZ_Params params;
		params.Y = Y;
		params.Z = Z;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromYX
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Y                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 X                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromYX(const struct FVector& Y, const struct FVector& X) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe5e0ba73);

		UKismetMathLibrary_MakeRotFromYX_Params params;
		params.Y = Y;
		params.X = X;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromY
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Y                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromY(const struct FVector& Y) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf5aae519);

		UKismetMathLibrary_MakeRotFromY_Params params;
		params.Y = Y;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromXZ
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 X                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Z                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromXZ(const struct FVector& X, const struct FVector& Z) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x32afaeda);

		UKismetMathLibrary_MakeRotFromXZ_Params params;
		params.X = X;
		params.Z = Z;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromXY
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 X                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Y                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromXY(const struct FVector& X, const struct FVector& Y) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcad3471);

		UKismetMathLibrary_MakeRotFromXY_Params params;
		params.X = X;
		params.Y = Y;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotFromX
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 X                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromX(const struct FVector& X) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcfa86ab0);

		UKismetMathLibrary_MakeRotFromX_Params params;
		params.X = X;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Roll                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Pitch                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Yaw                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotator(float Roll, float Pitch, float Yaw) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x636816e4);

		UKismetMathLibrary_MakeRotator_Params params;
		params.Roll = Roll;
		params.Pitch = Pitch;
		params.Yaw = Yaw;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRotationFromAxes
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Forward                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Right                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Up                             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_MakeRotationFromAxes(const struct FVector& Forward, const struct FVector& Right, const struct FVector& Up) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdbd2a7d8);

		UKismetMathLibrary_MakeRotationFromAxes_Params params;
		params.Forward = Forward;
		params.Right = Right;
		params.Up = Up;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeRandomStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            InitialSeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRandomStream           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FRandomStream UKismetMathLibrary::STATIC_MakeRandomStream(int InitialSeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x54d6b6c);

		UKismetMathLibrary_MakeRandomStream_Params params;
		params.InitialSeed = InitialSeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakePulsatingValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          InCurrentTime                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPulsesPerSecond              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InPhase                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4c922827);

		UKismetMathLibrary_MakePulsatingValue_Params params;
		params.InCurrentTime = InCurrentTime;
		params.InPulsesPerSecond = InPulsesPerSecond;
		params.InPhase = InPhase;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakePlaneFromPointAndNormal
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Point                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Normal                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FPlane                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FPlane UKismetMathLibrary::STATIC_MakePlaneFromPointAndNormal(const struct FVector& Point, const struct FVector& Normal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9531f749);

		UKismetMathLibrary_MakePlaneFromPointAndNormal_Params params;
		params.Point = Point;
		params.Normal = Normal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Year                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Month                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Day                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Hour                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Minute                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Second                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Millisecond                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_MakeDateTime(int Year, int Month, int Day, int Hour, int Minute, int Second, int Millisecond) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc684234a);

		UKismetMathLibrary_MakeDateTime_Params params;
		params.Year = Year;
		params.Month = Month;
		params.Day = Day;
		params.Hour = Hour;
		params.Minute = Minute;
		params.Second = Second;
		params.Millisecond = Millisecond;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.MakeColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          R                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          G                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_MakeColor(float R, float G, float B, float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3fc8ce9e);

		UKismetMathLibrary_MakeColor_Params params;
		params.R = R;
		params.G = G;
		params.B = B;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Loge
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Loge(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc5737e8);

		UKismetMathLibrary_Loge_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 LineStart                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 LineEnd                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 PlaneOrigin                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 PlaneNormal                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          T                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Intersection                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_LinePlaneIntersection_OriginNormal(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal, float* T, struct FVector* Intersection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d6b80de);

		UKismetMathLibrary_LinePlaneIntersection_OriginNormal_Params params;
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.PlaneOrigin = PlaneOrigin;
		params.PlaneNormal = PlaneNormal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (T != nullptr)
			*T = params.T;
		if (Intersection != nullptr)
			*Intersection = params.Intersection;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LinePlaneIntersection
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 LineStart                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 LineEnd                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FPlane                  APlane                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// float                          T                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Intersection                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_LinePlaneIntersection(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FPlane& APlane, float* T, struct FVector* Intersection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7251b3da);

		UKismetMathLibrary_LinePlaneIntersection_Params params;
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.APlane = APlane;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (T != nullptr)
			*T = params.T;
		if (Intersection != nullptr)
			*Intersection = params.Intersection;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_LinearColorLerpUsingHSV(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x359057fd);

		UKismetMathLibrary_LinearColorLerpUsingHSV_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LinearColorLerp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_LinearColorLerp(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf8bae56);

		UKismetMathLibrary_LinearColorLerp_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LessLess_VectorRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_LessLess_VectorRotator(const struct FVector& A, const struct FRotator& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfe5a6aa6);

		UKismetMathLibrary_LessLess_VectorRotator_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_LessEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfd312bd7);

		UKismetMathLibrary_LessEqual_TimespanTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LessEqual_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_LessEqual_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3d24039);

		UKismetMathLibrary_LessEqual_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LessEqual_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_LessEqual_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x245e308b);

		UKismetMathLibrary_LessEqual_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_LessEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfd56033b);

		UKismetMathLibrary_LessEqual_DateTimeDateTime_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.LessEqual_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_LessEqual_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9de2e8a3);

		UKismetMathLibrary_LessEqual_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Less_TimespanTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Less_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75a006ef);

		UKismetMathLibrary_Less_TimespanTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Less_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Less_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x32a450f1);

		UKismetMathLibrary_Less_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Less_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Less_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5e2c4223);

		UKismetMathLibrary_Less_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Less_DateTimeDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Less_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f4b4233);

		UKismetMathLibrary_Less_DateTimeDateTime_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Less_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Less_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x185d415b);

		UKismetMathLibrary_Less_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Lerp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Lerp(float A, float B, float Alpha) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6fc50ecc);

		UKismetMathLibrary_Lerp_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.IsMorning
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_IsMorning(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30e8e0f1);

		UKismetMathLibrary_IsMorning_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.IsLeapYear
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Year                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_IsLeapYear(int Year) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x732cd9de);

		UKismetMathLibrary_IsLeapYear_Params params;
		params.Year = Year;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.IsAfternoon
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_IsAfternoon(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xffe24269);

		UKismetMathLibrary_IsAfternoon_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.InvertTransform
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              T                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_InvertTransform(const struct FTransform& T) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe2e1ef89);

		UKismetMathLibrary_InvertTransform_Params params;
		params.T = T;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.InverseTransformLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              T                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_InverseTransformLocation(const struct FTransform& T, const struct FVector& Location) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbce3db56);

		UKismetMathLibrary_InverseTransformLocation_Params params;
		params.T = T;
		params.Location = Location;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.InverseTransformDirection
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              T                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Direction                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_InverseTransformDirection(const struct FTransform& T, const struct FVector& Direction) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa141a00a);

		UKismetMathLibrary_InverseTransformDirection_Params params;
		params.T = T;
		params.Direction = Direction;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.InverseLerp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_InverseLerp(float A, float B, float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf7fb222a);

		UKismetMathLibrary_InverseLerp_Params params;
		params.A = A;
		params.B = B;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.InRange_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Min                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           InclusiveMin                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           InclusiveMax                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_InRange_FloatFloat(float Value, float Min, float Max, bool InclusiveMin, bool InclusiveMax) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd714f678);

		UKismetMathLibrary_InRange_FloatFloat_Params params;
		params.Value = Value;
		params.Min = Min;
		params.Max = Max;
		params.InclusiveMin = InclusiveMin;
		params.InclusiveMax = InclusiveMax;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Hypotenuse
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Width                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Height                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Hypotenuse(float Width, float Height) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb8439e6b);

		UKismetMathLibrary_Hypotenuse_Params params;
		params.Width = Width;
		params.Height = Height;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.HSVToRGB_Vector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            HSV                            (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            RGB                            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_HSVToRGB_Vector(const struct FLinearColor& HSV, struct FLinearColor* RGB) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x71f57af8);

		UKismetMathLibrary_HSVToRGB_Vector_Params params;
		params.HSV = HSV;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (RGB != nullptr)
			*RGB = params.RGB;
	}


	// Function Engine.KismetMathLibrary.HSVToRGB
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          H                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          S                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          V                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_HSVToRGB(float H, float S, float V, float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf7c2b192);

		UKismetMathLibrary_HSVToRGB_Params params;
		params.H = H;
		params.S = S;
		params.V = V;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GridSnap_Float
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          GridSize                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GridSnap_Float(float Location, float GridSize) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37dc6c1c);

		UKismetMathLibrary_GridSnap_Float_Params params;
		params.Location = Location;
		params.GridSize = GridSize;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_GreaterGreater_VectorRotator(const struct FVector& A, const struct FRotator& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x992a4b9a);

		UKismetMathLibrary_GreaterGreater_VectorRotator_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_GreaterEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe42cc064);

		UKismetMathLibrary_GreaterEqual_TimespanTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GreaterEqual_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_GreaterEqual_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa30e769e);

		UKismetMathLibrary_GreaterEqual_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_GreaterEqual_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcb807a00);

		UKismetMathLibrary_GreaterEqual_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_GreaterEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30f92488);

		UKismetMathLibrary_GreaterEqual_DateTimeDateTime_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GreaterEqual_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_GreaterEqual_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x771c1b98);

		UKismetMathLibrary_GreaterEqual_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Greater_TimespanTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Greater_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x17bfb1f6);

		UKismetMathLibrary_Greater_TimespanTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Greater_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Greater_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb50100c8);

		UKismetMathLibrary_Greater_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Greater_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Greater_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7a44129a);

		UKismetMathLibrary_Greater_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Greater_DateTimeDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Greater_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c7c2bf2);

		UKismetMathLibrary_Greater_DateTimeDateTime_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Greater_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Greater_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3a64ed42);

		UKismetMathLibrary_Greater_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetYear
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetYear(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ac2e132);

		UKismetMathLibrary_GetYear_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetYawPitchFromVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Yaw                            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Pitch                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_GetYawPitchFromVector(const struct FVector& InVec, float* Yaw, float* Pitch) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd3b15299);

		UKismetMathLibrary_GetYawPitchFromVector_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Yaw != nullptr)
			*Yaw = params.Yaw;
		if (Pitch != nullptr)
			*Pitch = params.Pitch;
	}


	// Function Engine.KismetMathLibrary.GetVectorArrayAverage
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<struct FVector>         Vectors                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_GetVectorArrayAverage(TArray<struct FVector> Vectors) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4d4c4b0);

		UKismetMathLibrary_GetVectorArrayAverage_Params params;
		params.Vectors = Vectors;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetUpVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                InRot                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_GetUpVector(const struct FRotator& InRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1ce55387);

		UKismetMathLibrary_GetUpVector_Params params;
		params.InRot = InRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetTotalSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetTotalSeconds(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1fefd9d8);

		UKismetMathLibrary_GetTotalSeconds_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetTotalMinutes
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetTotalMinutes(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x43634108);

		UKismetMathLibrary_GetTotalMinutes_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetTotalMilliseconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetTotalMilliseconds(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x78236ef7);

		UKismetMathLibrary_GetTotalMilliseconds_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetTotalHours
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetTotalHours(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf016df3e);

		UKismetMathLibrary_GetTotalHours_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetTotalDays
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetTotalDays(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f999fbc);

		UKismetMathLibrary_GetTotalDays_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetTimeOfDay
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_GetTimeOfDay(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa43eb9f5);

		UKismetMathLibrary_GetTimeOfDay_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetTAU
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetTAU() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c812471);

		UKismetMathLibrary_GetTAU_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetSeconds(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x111b5d78);

		UKismetMathLibrary_GetSeconds_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetSecond
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetSecond(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x80859591);

		UKismetMathLibrary_GetSecond_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetRightVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                InRot                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_GetRightVector(const struct FRotator& InRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30de84dc);

		UKismetMathLibrary_GetRightVector_Params params;
		params.InRot = InRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetPointDistanceToSegment
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Point                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SegmentStart                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SegmentEnd                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetPointDistanceToSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf305693a);

		UKismetMathLibrary_GetPointDistanceToSegment_Params params;
		params.Point = Point;
		params.SegmentStart = SegmentStart;
		params.SegmentEnd = SegmentEnd;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetPointDistanceToLine
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Point                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LineOrigin                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LineDirection                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetPointDistanceToLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2867558d);

		UKismetMathLibrary_GetPointDistanceToLine_Params params;
		params.Point = Point;
		params.LineOrigin = LineOrigin;
		params.LineDirection = LineDirection;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetPI
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetPI() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8fcef8a0);

		UKismetMathLibrary_GetPI_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetMonth
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetMonth(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x59e511c5);

		UKismetMathLibrary_GetMonth_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetMinutes
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetMinutes(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x348ec4a8);

		UKismetMathLibrary_GetMinutes_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetMinute
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetMinute(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x100d3881);

		UKismetMathLibrary_GetMinute_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetMinElement
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetMinElement(const struct FVector& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16417a25);

		UKismetMathLibrary_GetMinElement_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetMilliseconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetMilliseconds(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf6b78817);

		UKismetMathLibrary_GetMilliseconds_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetMillisecond
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetMillisecond(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f48cce4);

		UKismetMathLibrary_GetMillisecond_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetMaxElement
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_GetMaxElement(const struct FVector& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8baa9567);

		UKismetMathLibrary_GetMaxElement_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetHours
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetHours(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe492cde);

		UKismetMathLibrary_GetHours_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetHour12
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetHour12(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x38cf626);

		UKismetMathLibrary_GetHour12_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetHour
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetHour(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x92816c67);

		UKismetMathLibrary_GetHour_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetForwardVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                InRot                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_GetForwardVector(const struct FRotator& InRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x377f2e45);

		UKismetMathLibrary_GetForwardVector_Params params;
		params.InRot = InRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetDuration
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_GetDuration(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x82049215);

		UKismetMathLibrary_GetDuration_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetDirectionUnitVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 From                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 To                             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_GetDirectionUnitVector(const struct FVector& From, const struct FVector& To) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x987d0ffb);

		UKismetMathLibrary_GetDirectionUnitVector_Params params;
		params.From = From;
		params.To = To;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetDays
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetDays(const struct FTimespan& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6b796fdc);

		UKismetMathLibrary_GetDays_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetDayOfYear
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetDayOfYear(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd106157d);

		UKismetMathLibrary_GetDayOfYear_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetDay
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_GetDay(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9d4c7e9d);

		UKismetMathLibrary_GetDay_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetDate
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_GetDate(const struct FDateTime& A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf6dc81f5);

		UKismetMathLibrary_GetDate_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.GetAxes
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 X                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Y                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Z                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_GetAxes(const struct FRotator& A, struct FVector* X, struct FVector* Y, struct FVector* Z) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ea9556e);

		UKismetMathLibrary_GetAxes_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (X != nullptr)
			*X = params.X;
		if (Y != nullptr)
			*Y = params.Y;
		if (Z != nullptr)
			*Z = params.Z;
	}


	// Function Engine.KismetMathLibrary.FTrunc
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_FTrunc(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xaccd220f);

		UKismetMathLibrary_FTrunc_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FromSeconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Seconds                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_FromSeconds(float Seconds) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3d95ac92);

		UKismetMathLibrary_FromSeconds_Params params;
		params.Seconds = Seconds;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FromMinutes
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Minutes                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_FromMinutes(float Minutes) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc46fe5a6);

		UKismetMathLibrary_FromMinutes_Params params;
		params.Minutes = Minutes;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FromMilliseconds
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Milliseconds                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_FromMilliseconds(float Milliseconds) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa36ce865);

		UKismetMathLibrary_FromMilliseconds_Params params;
		params.Milliseconds = Milliseconds;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FromHours
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Hours                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_FromHours(float Hours) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9036a160);

		UKismetMathLibrary_FromHours_Params params;
		params.Hours = Hours;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FromDays
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Days                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_FromDays(float Days) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf89af3e2);

		UKismetMathLibrary_FromDays_Params params;
		params.Days = Days;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Fraction
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Fraction(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x96a7004d);

		UKismetMathLibrary_Fraction_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FMod
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Dividend                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Divisor                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Remainder                      (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_FMod(float Dividend, float Divisor, float* Remainder) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x67173de9);

		UKismetMathLibrary_FMod_Params params;
		params.Dividend = Dividend;
		params.Divisor = Divisor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Remainder != nullptr)
			*Remainder = params.Remainder;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FMin
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_FMin(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1d1bbe5);

		UKismetMathLibrary_FMin_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FMax
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_FMax(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ede302b);

		UKismetMathLibrary_FMax_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FloatSpringInterp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// float                          Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FFloatSpringState       SpringState                    (CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// float                          Stiffness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          CriticalDampingFactor          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Mass                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_FloatSpringInterp(float Current, float Target, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, struct FFloatSpringState* SpringState) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x113d55da);

		UKismetMathLibrary_FloatSpringInterp_Params params;
		params.Current = Current;
		params.Target = Target;
		params.Stiffness = Stiffness;
		params.CriticalDampingFactor = CriticalDampingFactor;
		params.DeltaTime = DeltaTime;
		params.Mass = Mass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SpringState != nullptr)
			*SpringState = params.SpringState;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FixedTurn
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          InCurrent                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InDesired                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InDeltaRate                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_FixedTurn(float InCurrent, float InDesired, float InDeltaRate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6e3447fe);

		UKismetMathLibrary_FixedTurn_Params params;
		params.InCurrent = InCurrent;
		params.InDesired = InDesired;
		params.InDeltaRate = InDeltaRate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FInterpTo_Constant
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_FInterpTo_Constant(float Current, float Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcbb3a9d);

		UKismetMathLibrary_FInterpTo_Constant_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FInterpTo
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_FInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb61ec12);

		UKismetMathLibrary_FInterpTo_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FInterpEaseInOut
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Exponent                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_FInterpEaseInOut(float A, float B, float Alpha, float Exponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x622ea5aa);

		UKismetMathLibrary_FInterpEaseInOut_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.Exponent = Exponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FindNearestPointsOnLineSegments
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Segment1Start                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Segment1End                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Segment2Start                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Segment2End                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Segment1Point                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Segment2Point                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_FindNearestPointsOnLineSegments(const struct FVector& Segment1Start, const struct FVector& Segment1End, const struct FVector& Segment2Start, const struct FVector& Segment2End, struct FVector* Segment1Point, struct FVector* Segment2Point) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xacfd24e2);

		UKismetMathLibrary_FindNearestPointsOnLineSegments_Params params;
		params.Segment1Start = Segment1Start;
		params.Segment1End = Segment1End;
		params.Segment2Start = Segment2Start;
		params.Segment2End = Segment2End;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Segment1Point != nullptr)
			*Segment1Point = params.Segment1Point;
		if (Segment2Point != nullptr)
			*Segment2Point = params.Segment2Point;
	}


	// Function Engine.KismetMathLibrary.FindLookAtRotation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Start                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Target                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_FindLookAtRotation(const struct FVector& Start, const struct FVector& Target) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x430d14ba);

		UKismetMathLibrary_FindLookAtRotation_Params params;
		params.Start = Start;
		params.Target = Target;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FindClosestPointOnSegment
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Point                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SegmentStart                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 SegmentEnd                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_FindClosestPointOnSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x94913917);

		UKismetMathLibrary_FindClosestPointOnSegment_Params params;
		params.Point = Point;
		params.SegmentStart = SegmentStart;
		params.SegmentEnd = SegmentEnd;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FindClosestPointOnLine
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 Point                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LineOrigin                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 LineDirection                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_FindClosestPointOnLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfda7b472);

		UKismetMathLibrary_FindClosestPointOnLine_Params params;
		params.Point = Point;
		params.LineOrigin = LineOrigin;
		params.LineDirection = LineDirection;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FFloor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_FFloor(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4cd54eb7);

		UKismetMathLibrary_FFloor_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FClamp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Min                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_FClamp(float Value, float Min, float Max) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc1b63dc4);

		UKismetMathLibrary_FClamp_Params params;
		params.Value = Value;
		params.Min = Min;
		params.Max = Max;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.FCeil
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_FCeil(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd6b24868);

		UKismetMathLibrary_FCeil_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Exp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Exp(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb562ecfc);

		UKismetMathLibrary_Exp_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_VectorVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ErrorTolerance                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5b67fdfa);

		UKismetMathLibrary_EqualEqual_VectorVector_Params params;
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_Vector2DVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ErrorTolerance                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa653456);

		UKismetMathLibrary_EqualEqual_Vector2DVector2D_Params params;
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_TransformTransform
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7cc9c68e);

		UKismetMathLibrary_EqualEqual_TransformTransform_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37f8be82);

		UKismetMathLibrary_EqualEqual_TimespanTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ErrorTolerance                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc0d584e4);

		UKismetMathLibrary_EqualEqual_RotatorRotator_Params params;
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_ObjectObject
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UObject*                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_ObjectObject(class UObject* A, class UObject* B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3c9aa7a);

		UKismetMathLibrary_EqualEqual_ObjectObject_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_NameName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FName                   A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_NameName(const struct FName& A, const struct FName& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xadbea2de);

		UKismetMathLibrary_EqualEqual_NameName_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x83f3ef34);

		UKismetMathLibrary_EqualEqual_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeb4b7fc6);

		UKismetMathLibrary_EqualEqual_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x16e0d8e);

		UKismetMathLibrary_EqualEqual_DateTimeDateTime_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_ClassClass
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UClass*                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_ClassClass(class UClass* A, class UClass* B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x77746c5e);

		UKismetMathLibrary_EqualEqual_ClassClass_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7a5fb8ce);

		UKismetMathLibrary_EqualEqual_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.EqualEqual_BoolBool
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_EqualEqual_BoolBool(bool A, bool B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb90314fe);

		UKismetMathLibrary_EqualEqual_BoolBool_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Ease
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EEasingFunc>       EasingFunc                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          BlendExp                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Steps                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Ease(float A, float B, float Alpha, TEnumAsByte<EEasingFunc> EasingFunc, float BlendExp, int Steps) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x25af35e1);

		UKismetMathLibrary_Ease_Params params;
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DotProduct2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DotProduct2D(const struct FVector2D& A, const struct FVector2D& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x770f62f);

		UKismetMathLibrary_DotProduct2D_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Dot_VectorVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Dot_VectorVector(const struct FVector& A, const struct FVector& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1a1830b7);

		UKismetMathLibrary_Dot_VectorVector_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Divide_VectorVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Divide_VectorVector(const struct FVector& A, const struct FVector& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc9dc5827);

		UKismetMathLibrary_Divide_VectorVector_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Divide_VectorInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Divide_VectorInt(const struct FVector& A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3f940515);

		UKismetMathLibrary_Divide_VectorInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Divide_VectorFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Divide_VectorFloat(const struct FVector& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa6bb3774);

		UKismetMathLibrary_Divide_VectorFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Divide_Vector2DFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Divide_Vector2DFloat(const struct FVector2D& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x78a7f706);

		UKismetMathLibrary_Divide_Vector2DFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Divide_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Divide_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xddc84379);

		UKismetMathLibrary_Divide_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Divide_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Divide_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf95045cb);

		UKismetMathLibrary_Divide_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Divide_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_Divide_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x59384fe3);

		UKismetMathLibrary_Divide_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DegTan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DegTan(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e6f806a);

		UKismetMathLibrary_DegTan_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DegSin
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DegSin(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6a9e4855);

		UKismetMathLibrary_DegSin_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DegreesToRadians
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DegreesToRadians(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x15e10931);

		UKismetMathLibrary_DegreesToRadians_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DegCos
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DegCos(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7d822086);

		UKismetMathLibrary_DegCos_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DegAtan2
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DegAtan2(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x137c09b3);

		UKismetMathLibrary_DegAtan2_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DegAtan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DegAtan(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x84c11cab);

		UKismetMathLibrary_DegAtan_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DegAsin
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DegAsin(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf8d46844);

		UKismetMathLibrary_DegAsin_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DegAcos
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_DegAcos(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbf8c9233);

		UKismetMathLibrary_DegAcos_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DaysInYear
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Year                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_DaysInYear(int Year) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x17f45c0);

		UKismetMathLibrary_DaysInYear_Params params;
		params.Year = Year;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DaysInMonth
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Year                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Month                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_DaysInMonth(int Year, int Month) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2e39113b);

		UKismetMathLibrary_DaysInMonth_Params params;
		params.Year = Year;
		params.Month = Month;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DateTimeMinValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_DateTimeMinValue() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2b76503);

		UKismetMathLibrary_DateTimeMinValue_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DateTimeMaxValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_DateTimeMaxValue() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb9b8f569);

		UKismetMathLibrary_DateTimeMaxValue_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DateTimeFromString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 DateTimeString                 (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               Result                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_DateTimeFromString(const struct FString& DateTimeString, struct FDateTime* Result) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5ceb342f);

		UKismetMathLibrary_DateTimeFromString_Params params;
		params.DateTimeString = DateTimeString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Result != nullptr)
			*Result = params.Result;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.DateTimeFromIsoString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 IsoString                      (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               Result                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_DateTimeFromIsoString(const struct FString& IsoString, struct FDateTime* Result) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89688b0c);

		UKismetMathLibrary_DateTimeFromIsoString_Params params;
		params.IsoString = IsoString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Result != nullptr)
			*Result = params.Result;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.CrossProduct2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_CrossProduct2D(const struct FVector2D& A, const struct FVector2D& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x666133d8);

		UKismetMathLibrary_CrossProduct2D_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Cross_VectorVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Cross_VectorVector(const struct FVector& A, const struct FVector& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x362b7aec);

		UKismetMathLibrary_Cross_VectorVector_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.CreateVectorFromYawPitch
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Yaw                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Pitch                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Length                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_CreateVectorFromYawPitch(float Yaw, float Pitch, float Length) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2ef275eb);

		UKismetMathLibrary_CreateVectorFromYawPitch_Params params;
		params.Yaw = Yaw;
		params.Pitch = Pitch;
		params.Length = Length;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Cos
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Cos(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd8a0bd68);

		UKismetMathLibrary_Cos_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ConvertTransformToRelative
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              Transform                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              ParentTransform                (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_ConvertTransformToRelative(const struct FTransform& Transform, const struct FTransform& ParentTransform) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6995c7bb);

		UKismetMathLibrary_ConvertTransformToRelative_Params params;
		params.Transform = Transform;
		params.ParentTransform = ParentTransform;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_VectorToVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVector                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Conv_VectorToVector2D(const struct FVector& InVector) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x898c58e1);

		UKismetMathLibrary_Conv_VectorToVector2D_Params params;
		params.InVector = InVector;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_VectorToTransform
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InLocation                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_Conv_VectorToTransform(const struct FVector& InLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4ba545ea);

		UKismetMathLibrary_Conv_VectorToTransform_Params params;
		params.InLocation = InLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_VectorToRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_Conv_VectorToRotator(const struct FVector& InVec) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcf693b4d);

		UKismetMathLibrary_Conv_VectorToRotator_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_VectorToLinearColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_Conv_VectorToLinearColor(const struct FVector& InVec) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7f8e7e7a);

		UKismetMathLibrary_Conv_VectorToLinearColor_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_Vector2DToVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               InVector2D                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Z                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Conv_Vector2DToVector(const struct FVector2D& InVector2D, float Z) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4b1d5f41);

		UKismetMathLibrary_Conv_Vector2DToVector_Params params;
		params.InVector2D = InVector2D;
		params.Z = Z;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_RotatorToVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                InRot                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Conv_RotatorToVector(const struct FRotator& InRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3647247d);

		UKismetMathLibrary_Conv_RotatorToVector_Params params;
		params.InRot = InRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_LinearColorToVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            InLinearColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Conv_LinearColorToVector(const struct FLinearColor& InLinearColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xabafddf2);

		UKismetMathLibrary_Conv_LinearColorToVector_Params params;
		params.InLinearColor = InLinearColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_LinearColorToColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            InLinearColor                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FColor                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FColor UKismetMathLibrary::STATIC_Conv_LinearColorToColor(const struct FLinearColor& InLinearColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x18317e14);

		UKismetMathLibrary_Conv_LinearColorToColor_Params params;
		params.InLinearColor = InLinearColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_IntToFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            inInt                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Conv_IntToFloat(int inInt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc3f5232);

		UKismetMathLibrary_Conv_IntToFloat_Params params;
		params.inInt = inInt;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_IntToByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            inInt                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_Conv_IntToByte(int inInt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x165c65a);

		UKismetMathLibrary_Conv_IntToByte_Params params;
		params.inInt = inInt;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_IntToBool
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            inInt                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_Conv_IntToBool(int inInt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6c386cc4);

		UKismetMathLibrary_Conv_IntToBool_Params params;
		params.inInt = inInt;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_FloatToVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          inFloat                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Conv_FloatToVector(float inFloat) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3f38cbd0);

		UKismetMathLibrary_Conv_FloatToVector_Params params;
		params.inFloat = inFloat;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_FloatToLinearColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          inFloat                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_Conv_FloatToLinearColor(float inFloat) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa2ef4ca3);

		UKismetMathLibrary_Conv_FloatToLinearColor_Params params;
		params.inFloat = inFloat;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_ColorToLinearColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FColor                  InColor                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_Conv_ColorToLinearColor(const struct FColor& InColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd86fc202);

		UKismetMathLibrary_Conv_ColorToLinearColor_Params params;
		params.InColor = InColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_ByteToInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  InByte                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Conv_ByteToInt(unsigned char InByte) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xeb04e8dc);

		UKismetMathLibrary_Conv_ByteToInt_Params params;
		params.InByte = InByte;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_ByteToFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  InByte                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Conv_ByteToFloat(unsigned char InByte) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x45c0dbbd);

		UKismetMathLibrary_Conv_ByteToFloat_Params params;
		params.InByte = InByte;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_BoolToInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           InBool                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Conv_BoolToInt(bool InBool) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf8ed2d2);

		UKismetMathLibrary_Conv_BoolToInt_Params params;
		params.InBool = InBool;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_BoolToFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           InBool                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Conv_BoolToFloat(bool InBool) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x99a57557);

		UKismetMathLibrary_Conv_BoolToFloat_Params params;
		params.InBool = InBool;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Conv_BoolToByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           InBool                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_Conv_BoolToByte(bool InBool) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf9c124c5);

		UKismetMathLibrary_Conv_BoolToByte_Params params;
		params.InBool = InBool;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ComposeTransforms
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FTransform              ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FTransform UKismetMathLibrary::STATIC_ComposeTransforms(const struct FTransform& A, const struct FTransform& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x98efbbaa);

		UKismetMathLibrary_ComposeTransforms_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ComposeRotators
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FRotator UKismetMathLibrary::STATIC_ComposeRotators(const struct FRotator& A, const struct FRotator& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbef6ef8b);

		UKismetMathLibrary_ComposeRotators_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ClassIsChildOf
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UClass*                  TestClass                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  ParentClass                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_ClassIsChildOf(class UClass* TestClass, class UClass* ParentClass) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfbc670d6);

		UKismetMathLibrary_ClassIsChildOf_Params params;
		params.TestClass = TestClass;
		params.ParentClass = ParentClass;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ClampVectorSize
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Min                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_ClampVectorSize(const struct FVector& A, float Min, float Max) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x184681f2);

		UKismetMathLibrary_ClampVectorSize_Params params;
		params.A = A;
		params.Min = Min;
		params.Max = Max;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ClampAxis
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Angle                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_ClampAxis(float Angle) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x438d38d3);

		UKismetMathLibrary_ClampAxis_Params params;
		params.Angle = Angle;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.ClampAngle
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          AngleDegrees                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MinAngleDegrees                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          MaxAngleDegrees                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26655b09);

		UKismetMathLibrary_ClampAngle_Params params;
		params.AngleDegrees = AngleDegrees;
		params.MinAngleDegrees = MinAngleDegrees;
		params.MaxAngleDegrees = MaxAngleDegrees;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Clamp
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Min                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Max                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Clamp(int Value, int Min, int Max) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2262de20);

		UKismetMathLibrary_Clamp_Params params;
		params.Value = Value;
		params.Min = Min;
		params.Max = Max;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.CInterpTo
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            Current                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            Target                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          InterpSpeed                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UKismetMathLibrary::STATIC_CInterpTo(const struct FLinearColor& Current, const struct FLinearColor& Target, float DeltaTime, float InterpSpeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x11425587);

		UKismetMathLibrary_CInterpTo_Params params;
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.BreakVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          X                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Y                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakVector2D(const struct FVector2D& InVec, float* X, float* Y) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf9a3f3cf);

		UKismetMathLibrary_BreakVector2D_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (X != nullptr)
			*X = params.X;
		if (Y != nullptr)
			*Y = params.Y;
	}


	// Function Engine.KismetMathLibrary.BreakVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          X                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Y                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Z                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakVector(const struct FVector& InVec, float* X, float* Y, float* Z) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa630ef29);

		UKismetMathLibrary_BreakVector_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (X != nullptr)
			*X = params.X;
		if (Y != nullptr)
			*Y = params.Y;
		if (Z != nullptr)
			*Z = params.Z;
	}


	// Function Engine.KismetMathLibrary.BreakTransform
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              InTransform                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Scale                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakTransform(const struct FTransform& InTransform, struct FVector* Location, struct FRotator* Rotation, struct FVector* Scale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8de35820);

		UKismetMathLibrary_BreakTransform_Params params;
		params.InTransform = InTransform;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Location != nullptr)
			*Location = params.Location;
		if (Rotation != nullptr)
			*Rotation = params.Rotation;
		if (Scale != nullptr)
			*Scale = params.Scale;
	}


	// Function Engine.KismetMathLibrary.BreakTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               InTimespan                     (CPF_Parm, CPF_ZeroConstructor)
	// int                            Days                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Hours                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Minutes                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Seconds                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Milliseconds                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakTimespan(const struct FTimespan& InTimespan, int* Days, int* Hours, int* Minutes, int* Seconds, int* Milliseconds) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7c72ebe3);

		UKismetMathLibrary_BreakTimespan_Params params;
		params.InTimespan = InTimespan;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Days != nullptr)
			*Days = params.Days;
		if (Hours != nullptr)
			*Hours = params.Hours;
		if (Minutes != nullptr)
			*Minutes = params.Minutes;
		if (Seconds != nullptr)
			*Seconds = params.Seconds;
		if (Milliseconds != nullptr)
			*Milliseconds = params.Milliseconds;
	}


	// Function Engine.KismetMathLibrary.BreakRotIntoAxes
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                InRot                          (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FVector                 X                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Y                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Z                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakRotIntoAxes(const struct FRotator& InRot, struct FVector* X, struct FVector* Y, struct FVector* Z) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfedd55ea);

		UKismetMathLibrary_BreakRotIntoAxes_Params params;
		params.InRot = InRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (X != nullptr)
			*X = params.X;
		if (Y != nullptr)
			*Y = params.Y;
		if (Z != nullptr)
			*Z = params.Z;
	}


	// Function Engine.KismetMathLibrary.BreakRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                InRot                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Roll                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Pitch                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Yaw                            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakRotator(const struct FRotator& InRot, float* Roll, float* Pitch, float* Yaw) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1333825b);

		UKismetMathLibrary_BreakRotator_Params params;
		params.InRot = InRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Roll != nullptr)
			*Roll = params.Roll;
		if (Pitch != nullptr)
			*Pitch = params.Pitch;
		if (Yaw != nullptr)
			*Yaw = params.Yaw;
	}


	// Function Engine.KismetMathLibrary.BreakRandomStream
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRandomStream           InRandomStream                 (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// int                            InitialSeed                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakRandomStream(const struct FRandomStream& InRandomStream, int* InitialSeed) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbcab3a09);

		UKismetMathLibrary_BreakRandomStream_Params params;
		params.InRandomStream = InRandomStream;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (InitialSeed != nullptr)
			*InitialSeed = params.InitialSeed;
	}


	// Function Engine.KismetMathLibrary.BreakDateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               InDateTime                     (CPF_Parm, CPF_ZeroConstructor)
	// int                            Year                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Month                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Day                            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Hour                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Minute                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Second                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Millisecond                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakDateTime(const struct FDateTime& InDateTime, int* Year, int* Month, int* Day, int* Hour, int* Minute, int* Second, int* Millisecond) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8fecb78b);

		UKismetMathLibrary_BreakDateTime_Params params;
		params.InDateTime = InDateTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Year != nullptr)
			*Year = params.Year;
		if (Month != nullptr)
			*Month = params.Month;
		if (Day != nullptr)
			*Day = params.Day;
		if (Hour != nullptr)
			*Hour = params.Hour;
		if (Minute != nullptr)
			*Minute = params.Minute;
		if (Second != nullptr)
			*Second = params.Second;
		if (Millisecond != nullptr)
			*Millisecond = params.Millisecond;
	}


	// Function Engine.KismetMathLibrary.BreakColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            InColor                        (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          R                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          G                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          A                              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetMathLibrary::STATIC_BreakColor(const struct FLinearColor& InColor, float* R, float* G, float* B, float* A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x55f5dbe1);

		UKismetMathLibrary_BreakColor_Params params;
		params.InColor = InColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (R != nullptr)
			*R = params.R;
		if (G != nullptr)
			*G = params.G;
		if (B != nullptr)
			*B = params.B;
		if (A != nullptr)
			*A = params.A;
	}


	// Function Engine.KismetMathLibrary.BooleanXOR
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_BooleanXOR(bool A, bool B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd5f5ece0);

		UKismetMathLibrary_BooleanXOR_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.BooleanOR
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_BooleanOR(bool A, bool B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd6c3f7ee);

		UKismetMathLibrary_BooleanOR_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.BooleanNOR
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_BooleanNOR(bool A, bool B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa56a5692);

		UKismetMathLibrary_BooleanNOR_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.BooleanNAND
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_BooleanNAND(bool A, bool B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3a9c05b8);

		UKismetMathLibrary_BooleanNAND_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.BooleanAND
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetMathLibrary::STATIC_BooleanAND(bool A, bool B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x215ae094);

		UKismetMathLibrary_BooleanAND_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.BMin
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_BMin(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5f105879);

		UKismetMathLibrary_BMin_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.BMax
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_BMax(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc30a007);

		UKismetMathLibrary_BMax_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Atan2
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Atan2(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa9a53f51);

		UKismetMathLibrary_Atan2_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Atan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Atan(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe83ac401);

		UKismetMathLibrary_Atan_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Asin
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Asin(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2437796e);

		UKismetMathLibrary_Asin_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.And_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_And_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc069d6b3);

		UKismetMathLibrary_And_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_VectorVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Add_VectorVector(const struct FVector& A, const struct FVector& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdf9aef9b);

		UKismetMathLibrary_Add_VectorVector_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_VectorInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Add_VectorInt(const struct FVector& A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x31d51671);

		UKismetMathLibrary_Add_VectorInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_VectorFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UKismetMathLibrary::STATIC_Add_VectorFloat(const struct FVector& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x35e1f6f0);

		UKismetMathLibrary_Add_VectorFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_Vector2DVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Add_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x93f29e47);

		UKismetMathLibrary_Add_Vector2DVector2D_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_Vector2DFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UKismetMathLibrary::STATIC_Add_Vector2DFloat(const struct FVector2D& A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9906174a);

		UKismetMathLibrary_Add_Vector2DFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_TimespanTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FTimespan UKismetMathLibrary::STATIC_Add_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x21c7a09b);

		UKismetMathLibrary_Add_TimespanTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_IntInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Add_IntInt(int A, int B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbf0700cd);

		UKismetMathLibrary_Add_IntInt_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_FloatFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Add_FloatFloat(float A, float B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37f43f4f);

		UKismetMathLibrary_Add_FloatFloat_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_DateTimeTimespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FTimespan               B                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FDateTime               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FDateTime UKismetMathLibrary::STATIC_Add_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5e972377);

		UKismetMathLibrary_Add_DateTimeTimespan_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Add_ByteByte
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  B                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetMathLibrary::STATIC_Add_ByteByte(unsigned char A, unsigned char B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf7879797);

		UKismetMathLibrary_Add_ByteByte_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Acos
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Acos(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x92bd2609);

		UKismetMathLibrary_Acos_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Abs_Int
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetMathLibrary::STATIC_Abs_Int(int A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc1cb7de3);

		UKismetMathLibrary_Abs_Int_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetMathLibrary.Abs
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          A                              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetMathLibrary::STATIC_Abs(float A) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7fb1edcd);

		UKismetMathLibrary_Abs_Params params;
		params.A = A;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.MarkBit
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetNodeHelperLibrary::STATIC_MarkBit(int Index, int* Data) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2bee6aef);

		UKismetNodeHelperLibrary_MarkBit_Params params;
		params.Index = Index;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Data != nullptr)
			*Data = params.Data;
	}


	// Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumBits                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetNodeHelperLibrary::STATIC_HasUnmarkedBit(int Data, int NumBits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x53d37ff);

		UKismetNodeHelperLibrary_HasUnmarkedBit_Params params;
		params.Data = Data;
		params.NumBits = NumBits;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.HasMarkedBit
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumBits                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetNodeHelperLibrary::STATIC_HasMarkedBit(int Data, int NumBits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd280ec);

		UKismetNodeHelperLibrary_HasMarkedBit_Params params;
		params.Data = Data;
		params.NumBits = NumBits;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.GetValidValue
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UEnum*                   Enum                           (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  EnumeratorValue                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetNodeHelperLibrary::STATIC_GetValidValue(class UEnum* Enum, unsigned char EnumeratorValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xff6f5d4e);

		UKismetNodeHelperLibrary_GetValidValue_Params params;
		params.Enum = Enum;
		params.EnumeratorValue = EnumeratorValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StartIdx                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumBits                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bRandom                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetNodeHelperLibrary::STATIC_GetUnmarkedBit(int Data, int StartIdx, int NumBits, bool bRandom) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfaf569b);

		UKismetNodeHelperLibrary_GetUnmarkedBit_Params params;
		params.Data = Data;
		params.StartIdx = StartIdx;
		params.NumBits = NumBits;
		params.bRandom = bRandom;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StartIdx                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumBits                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetNodeHelperLibrary::STATIC_GetRandomUnmarkedBit(int Data, int StartIdx, int NumBits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x81cc7fe4);

		UKismetNodeHelperLibrary_GetRandomUnmarkedBit_Params params;
		params.Data = Data;
		params.StartIdx = StartIdx;
		params.NumBits = NumBits;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StartIdx                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumBits                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetNodeHelperLibrary::STATIC_GetFirstUnmarkedBit(int Data, int StartIdx, int NumBits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbaf7f68f);

		UKismetNodeHelperLibrary_GetFirstUnmarkedBit_Params params;
		params.Data = Data;
		params.StartIdx = StartIdx;
		params.NumBits = NumBits;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.GetEnumeratorValueFromIndex
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UEnum*                   Enum                           (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  EnumeratorIndex                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	unsigned char UKismetNodeHelperLibrary::STATIC_GetEnumeratorValueFromIndex(class UEnum* Enum, unsigned char EnumeratorIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x664446c);

		UKismetNodeHelperLibrary_GetEnumeratorValueFromIndex_Params params;
		params.Enum = Enum;
		params.EnumeratorIndex = EnumeratorIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UEnum*                   Enum                           (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  EnumeratorValue                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetNodeHelperLibrary::STATIC_GetEnumeratorUserFriendlyName(class UEnum* Enum, unsigned char EnumeratorValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2391d5dc);

		UKismetNodeHelperLibrary_GetEnumeratorUserFriendlyName_Params params;
		params.Enum = Enum;
		params.EnumeratorValue = EnumeratorValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.GetEnumeratorName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UEnum*                   Enum                           (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// unsigned char                  EnumeratorValue                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName UKismetNodeHelperLibrary::STATIC_GetEnumeratorName(class UEnum* Enum, unsigned char EnumeratorValue) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xecd5a0c0);

		UKismetNodeHelperLibrary_GetEnumeratorName_Params params;
		params.Enum = Enum;
		params.EnumeratorValue = EnumeratorValue;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetNodeHelperLibrary.ClearBit
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetNodeHelperLibrary::STATIC_ClearBit(int Index, int* Data) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3087d3a1);

		UKismetNodeHelperLibrary_ClearBit_Params params;
		params.Index = Index;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Data != nullptr)
			*Data = params.Data;
	}


	// Function Engine.KismetNodeHelperLibrary.ClearAllBits
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetNodeHelperLibrary::STATIC_ClearAllBits(int* Data) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdfb56fa5);

		UKismetNodeHelperLibrary_ClearAllBits_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Data != nullptr)
			*Data = params.Data;
	}


	// Function Engine.KismetNodeHelperLibrary.BitIsMarked
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// int                            Data                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetNodeHelperLibrary::STATIC_BitIsMarked(int Data, int Index) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6511a1fa);

		UKismetNodeHelperLibrary_BitIsMarked_Params params;
		params.Data = Data;
		params.Index = Index;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetRenderingLibrary.ExportTexture2D
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTexture2D*              Texture                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FilePath                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Filename                       (CPF_Parm, CPF_ZeroConstructor)

	void UKismetRenderingLibrary::STATIC_ExportTexture2D(class UObject* WorldContextObject, class UTexture2D* Texture, const struct FString& FilePath, const struct FString& Filename) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3a59335a);

		UKismetRenderingLibrary_ExportTexture2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Texture = Texture;
		params.FilePath = FilePath;
		params.Filename = Filename;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetRenderingLibrary.ExportRenderTarget
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTextureRenderTarget2D*  TextureRenderTarget            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 FilePath                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Filename                       (CPF_Parm, CPF_ZeroConstructor)

	void UKismetRenderingLibrary::STATIC_ExportRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const struct FString& FilePath, const struct FString& Filename) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc28f05bc);

		UKismetRenderingLibrary_ExportRenderTarget_Params params;
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.FilePath = FilePath;
		params.Filename = Filename;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDrawToRenderTargetContext Context                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)

	void UKismetRenderingLibrary::STATIC_EndDrawCanvasToRenderTarget(class UObject* WorldContextObject, const struct FDrawToRenderTargetContext& Context) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x45b1dcd6);

		UKismetRenderingLibrary_EndDrawCanvasToRenderTarget_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Context = Context;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTextureRenderTarget2D*  TextureRenderTarget            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInterface*      Material                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetRenderingLibrary::STATIC_DrawMaterialToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbbfd6880);

		UKismetRenderingLibrary_DrawMaterialToRenderTarget_Params params;
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.Material = Material;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetRenderingLibrary.CreateRenderTarget2D
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Width                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Height                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTextureRenderTarget2D*  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UTextureRenderTarget2D* UKismetRenderingLibrary::STATIC_CreateRenderTarget2D(class UObject* WorldContextObject, int Width, int Height) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8701b77c);

		UKismetRenderingLibrary_CreateRenderTarget2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Width = Width;
		params.Height = Height;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetRenderingLibrary.ClearRenderTarget2D
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTextureRenderTarget2D*  TextureRenderTarget            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ClearColor                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetRenderingLibrary::STATIC_ClearRenderTarget2D(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const struct FLinearColor& ClearColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x37882819);

		UKismetRenderingLibrary_ClearRenderTarget2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.ClearColor = ClearColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTextureRenderTarget2D*  TextureRenderTarget            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UCanvas*                 Canvas                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               Size                           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FDrawToRenderTargetContext Context                        (CPF_Parm, CPF_OutParm)

	void UKismetRenderingLibrary::STATIC_BeginDrawCanvasToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UCanvas** Canvas, struct FVector2D* Size, struct FDrawToRenderTargetContext* Context) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x27304822);

		UKismetRenderingLibrary_BeginDrawCanvasToRenderTarget_Params params;
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Canvas != nullptr)
			*Canvas = params.Canvas;
		if (Size != nullptr)
			*Size = params.Size;
		if (Context != nullptr)
			*Context = params.Context;
	}


	// Function Engine.KismetStringLibrary.TrimTrailing
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_TrimTrailing(const struct FString& SourceString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2e570ed6);

		UKismetStringLibrary_TrimTrailing_Params params;
		params.SourceString = SourceString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Trim
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Trim(const struct FString& SourceString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc40f172e);

		UKismetStringLibrary_Trim_Params params;
		params.SourceString = SourceString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.ToUpper
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_ToUpper(const struct FString& SourceString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb23f441b);

		UKismetStringLibrary_ToUpper_Params params;
		params.SourceString = SourceString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.ToLower
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_ToLower(const struct FString& SourceString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdde638bc);

		UKismetStringLibrary_ToLower_Params params;
		params.SourceString = SourceString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.TimeSecondsToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          InSeconds                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_TimeSecondsToString(float InSeconds) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x39c923bc);

		UKismetStringLibrary_TimeSecondsToString_Params params;
		params.InSeconds = InSeconds;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.StartsWith
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 InPrefix                       (CPF_Parm, CPF_ZeroConstructor)
	// TEnumAsByte<ESearchCase>       SearchCase                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_StartsWith(const struct FString& SourceString, const struct FString& InPrefix, TEnumAsByte<ESearchCase> SearchCase) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8b2b2711);

		UKismetStringLibrary_StartsWith_Params params;
		params.SourceString = SourceString;
		params.InPrefix = InPrefix;
		params.SearchCase = SearchCase;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Split
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 InStr                          (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 LeftS                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// struct FString                 RightS                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// TEnumAsByte<ESearchCase>       SearchCase                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ESearchDir>        SearchDir                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_Split(const struct FString& SourceString, const struct FString& InStr, TEnumAsByte<ESearchCase> SearchCase, TEnumAsByte<ESearchDir> SearchDir, struct FString* LeftS, struct FString* RightS) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcfc46e9e);

		UKismetStringLibrary_Split_Params params;
		params.SourceString = SourceString;
		params.InStr = InStr;
		params.SearchCase = SearchCase;
		params.SearchDir = SearchDir;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (LeftS != nullptr)
			*LeftS = params.LeftS;
		if (RightS != nullptr)
			*RightS = params.RightS;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.RightPad
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            ChCount                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_RightPad(const struct FString& SourceString, int ChCount) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x43f1a347);

		UKismetStringLibrary_RightPad_Params params;
		params.SourceString = SourceString;
		params.ChCount = ChCount;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.RightChop
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            Count                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_RightChop(const struct FString& SourceString, int Count) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc86f086c);

		UKismetStringLibrary_RightChop_Params params;
		params.SourceString = SourceString;
		params.Count = Count;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Right
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            Count                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Right(const struct FString& SourceString, int Count) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x75ad918);

		UKismetStringLibrary_Right_Params params;
		params.SourceString = SourceString;
		params.Count = Count;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Reverse
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Reverse(const struct FString& SourceString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc840360c);

		UKismetStringLibrary_Reverse_Params params;
		params.SourceString = SourceString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.ReplaceInline
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FString                 SearchText                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReplacementText                (CPF_Parm, CPF_ZeroConstructor)
	// TEnumAsByte<ESearchCase>       SearchCase                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetStringLibrary::STATIC_ReplaceInline(const struct FString& SearchText, const struct FString& ReplacementText, TEnumAsByte<ESearchCase> SearchCase, struct FString* SourceString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85d8ee99);

		UKismetStringLibrary_ReplaceInline_Params params;
		params.SearchText = SearchText;
		params.ReplacementText = ReplacementText;
		params.SearchCase = SearchCase;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (SourceString != nullptr)
			*SourceString = params.SourceString;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Replace
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 From                           (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 To                             (CPF_Parm, CPF_ZeroConstructor)
	// TEnumAsByte<ESearchCase>       SearchCase                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Replace(const struct FString& SourceString, const struct FString& From, const struct FString& To, TEnumAsByte<ESearchCase> SearchCase) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8b28a3e2);

		UKismetStringLibrary_Replace_Params params;
		params.SourceString = SourceString;
		params.From = From;
		params.To = To;
		params.SearchCase = SearchCase;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.ParseIntoArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Delimiter                      (CPF_Parm, CPF_ZeroConstructor)
	// bool                           CullEmptyStrings               (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FString>         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<struct FString> UKismetStringLibrary::STATIC_ParseIntoArray(const struct FString& SourceString, const struct FString& Delimiter, bool CullEmptyStrings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x26254a30);

		UKismetStringLibrary_ParseIntoArray_Params params;
		params.SourceString = SourceString;
		params.Delimiter = Delimiter;
		params.CullEmptyStrings = CullEmptyStrings;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.NotEqual_StrStr
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_NotEqual_StrStr(const struct FString& A, const struct FString& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x455643ec);

		UKismetStringLibrary_NotEqual_StrStr_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.NotEqual_StriStri
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_NotEqual_StriStri(const struct FString& A, const struct FString& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1cbf19a6);

		UKismetStringLibrary_NotEqual_StriStri_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Mid
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            Start                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Count                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Mid(const struct FString& SourceString, int Start, int Count) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x448b1fb0);

		UKismetStringLibrary_Mid_Params params;
		params.SourceString = SourceString;
		params.Start = Start;
		params.Count = Count;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.MatchesWildcard
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Wildcard                       (CPF_Parm, CPF_ZeroConstructor)
	// TEnumAsByte<ESearchCase>       SearchCase                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_MatchesWildcard(const struct FString& SourceString, const struct FString& Wildcard, TEnumAsByte<ESearchCase> SearchCase) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcb78699b);

		UKismetStringLibrary_MatchesWildcard_Params params;
		params.SourceString = SourceString;
		params.Wildcard = Wildcard;
		params.SearchCase = SearchCase;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Len
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 S                              (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetStringLibrary::STATIC_Len(const struct FString& S) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf2aa4223);

		UKismetStringLibrary_Len_Params params;
		params.S = S;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.LeftPad
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            ChCount                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_LeftPad(const struct FString& SourceString, int ChCount) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb2a0e788);

		UKismetStringLibrary_LeftPad_Params params;
		params.SourceString = SourceString;
		params.ChCount = ChCount;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.LeftChop
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            Count                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_LeftChop(const struct FString& SourceString, int Count) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x119a9e01);

		UKismetStringLibrary_LeftChop_Params params;
		params.SourceString = SourceString;
		params.Count = Count;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Left
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            Count                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Left(const struct FString& SourceString, int Count) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa6a0ad35);

		UKismetStringLibrary_Left_Params params;
		params.SourceString = SourceString;
		params.Count = Count;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.JoinStringArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// TArray<struct FString>         SourceArray                    (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FString                 Separator                      (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_JoinStringArray(TArray<struct FString> SourceArray, const struct FString& Separator) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5cc4dadc);

		UKismetStringLibrary_JoinStringArray_Params params;
		params.SourceArray = SourceArray;
		params.Separator = Separator;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.IsNumeric
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_IsNumeric(const struct FString& SourceString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf46175a3);

		UKismetStringLibrary_IsNumeric_Params params;
		params.SourceString = SourceString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.GetSubstring
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            StartIndex                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Length                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_GetSubstring(const struct FString& SourceString, int StartIndex, int Length) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9fcfb7cf);

		UKismetStringLibrary_GetSubstring_Params params;
		params.SourceString = SourceString;
		params.StartIndex = StartIndex;
		params.Length = Length;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.GetCharacterAsNumber
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// int                            Index                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetStringLibrary::STATIC_GetCharacterAsNumber(const struct FString& SourceString, int Index) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4f740e5c);

		UKismetStringLibrary_GetCharacterAsNumber_Params params;
		params.SourceString = SourceString;
		params.Index = Index;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.GetCharacterArrayFromString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// TArray<struct FString>         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	TArray<struct FString> UKismetStringLibrary::STATIC_GetCharacterArrayFromString(const struct FString& SourceString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x53be636d);

		UKismetStringLibrary_GetCharacterArrayFromString_Params params;
		params.SourceString = SourceString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.FindSubstring
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SearchIn                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Substring                      (CPF_Parm, CPF_ZeroConstructor)
	// bool                           bUseCase                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSearchFromEnd                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            StartPosition                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetStringLibrary::STATIC_FindSubstring(const struct FString& SearchIn, const struct FString& Substring, bool bUseCase, bool bSearchFromEnd, int StartPosition) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e652a70);

		UKismetStringLibrary_FindSubstring_Params params;
		params.SearchIn = SearchIn;
		params.Substring = Substring;
		params.bUseCase = bUseCase;
		params.bSearchFromEnd = bSearchFromEnd;
		params.StartPosition = StartPosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.EqualEqual_StrStr
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_EqualEqual_StrStr(const struct FString& A, const struct FString& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xca707053);

		UKismetStringLibrary_EqualEqual_StrStr_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.EqualEqual_StriStri
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 B                              (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_EqualEqual_StriStri(const struct FString& A, const struct FString& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6464a9a1);

		UKismetStringLibrary_EqualEqual_StriStri_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.EndsWith
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 InSuffix                       (CPF_Parm, CPF_ZeroConstructor)
	// TEnumAsByte<ESearchCase>       SearchCase                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_EndsWith(const struct FString& SourceString, const struct FString& InSuffix, TEnumAsByte<ESearchCase> SearchCase) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3062f31c);

		UKismetStringLibrary_EndsWith_Params params;
		params.SourceString = SourceString;
		params.InSuffix = InSuffix;
		params.SearchCase = SearchCase;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.CullArray
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SourceString                   (CPF_Parm, CPF_ZeroConstructor)
	// TArray<struct FString>         inArray                        (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetStringLibrary::STATIC_CullArray(const struct FString& SourceString, TArray<struct FString>* inArray) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcde1c0c1);

		UKismetStringLibrary_CullArray_Params params;
		params.SourceString = SourceString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (inArray != nullptr)
			*inArray = params.inArray;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_VectorToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_VectorToString(const struct FVector& InVec) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf683c29e);

		UKismetStringLibrary_Conv_VectorToString_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_Vector2dToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_Vector2dToString(const struct FVector2D& InVec) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x71b1870);

		UKismetStringLibrary_Conv_Vector2dToString_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_TransformToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              InTrans                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_TransformToString(const struct FTransform& InTrans) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf547af2d);

		UKismetStringLibrary_Conv_TransformToString_Params params;
		params.InTrans = InTrans;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_StringToVector2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FVector2D               OutConvertedVector2D           (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           OutIsValid                     (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetStringLibrary::STATIC_Conv_StringToVector2D(const struct FString& inString, struct FVector2D* OutConvertedVector2D, bool* OutIsValid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1d877808);

		UKismetStringLibrary_Conv_StringToVector2D_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutConvertedVector2D != nullptr)
			*OutConvertedVector2D = params.OutConvertedVector2D;
		if (OutIsValid != nullptr)
			*OutIsValid = params.OutIsValid;
	}


	// Function Engine.KismetStringLibrary.Conv_StringToVector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FVector                 OutConvertedVector             (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           OutIsValid                     (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetStringLibrary::STATIC_Conv_StringToVector(const struct FString& inString, struct FVector* OutConvertedVector, bool* OutIsValid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c02b542);

		UKismetStringLibrary_Conv_StringToVector_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutConvertedVector != nullptr)
			*OutConvertedVector = params.OutConvertedVector;
		if (OutIsValid != nullptr)
			*OutIsValid = params.OutIsValid;
	}


	// Function Engine.KismetStringLibrary.Conv_StringToRotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FRotator                OutConvertedRotator            (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           OutIsValid                     (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetStringLibrary::STATIC_Conv_StringToRotator(const struct FString& inString, struct FRotator* OutConvertedRotator, bool* OutIsValid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8fa45042);

		UKismetStringLibrary_Conv_StringToRotator_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutConvertedRotator != nullptr)
			*OutConvertedRotator = params.OutConvertedRotator;
		if (OutIsValid != nullptr)
			*OutIsValid = params.OutIsValid;
	}


	// Function Engine.KismetStringLibrary.Conv_StringToName
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FName                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FName UKismetStringLibrary::STATIC_Conv_StringToName(const struct FString& inString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8aa2c7a6);

		UKismetStringLibrary_Conv_StringToName_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_StringToInt
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UKismetStringLibrary::STATIC_Conv_StringToInt(const struct FString& inString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x691d8d4e);

		UKismetStringLibrary_Conv_StringToInt_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_StringToFloat
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UKismetStringLibrary::STATIC_Conv_StringToFloat(const struct FString& inString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85d0a563);

		UKismetStringLibrary_Conv_StringToFloat_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_StringToColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FLinearColor            OutConvertedColor              (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           OutIsValid                     (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UKismetStringLibrary::STATIC_Conv_StringToColor(const struct FString& inString, struct FLinearColor* OutConvertedColor, bool* OutIsValid) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x71bc4144);

		UKismetStringLibrary_Conv_StringToColor_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutConvertedColor != nullptr)
			*OutConvertedColor = params.OutConvertedColor;
		if (OutIsValid != nullptr)
			*OutIsValid = params.OutIsValid;
	}


	// Function Engine.KismetStringLibrary.Conv_RotatorToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                InRot                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_RotatorToString(const struct FRotator& InRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9f5545f6);

		UKismetStringLibrary_Conv_RotatorToString_Params params;
		params.InRot = InRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_ObjectToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 InObj                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_ObjectToString(class UObject* InObj) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89239aa6);

		UKismetStringLibrary_Conv_ObjectToString_Params params;
		params.InObj = InObj;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_NameToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_NameToString(const struct FName& InName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6ccbdc2);

		UKismetStringLibrary_Conv_NameToString_Params params;
		params.InName = InName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_IntToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            inInt                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_IntToString(int inInt) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8c0806ea);

		UKismetStringLibrary_Conv_IntToString_Params params;
		params.inInt = inInt;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_FloatToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          inFloat                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_FloatToString(float inFloat) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x30e45637);

		UKismetStringLibrary_Conv_FloatToString_Params params;
		params.inFloat = inFloat;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_ColorToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            InColor                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_ColorToString(const struct FLinearColor& InColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x955c3a2c);

		UKismetStringLibrary_Conv_ColorToString_Params params;
		params.InColor = InColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_ByteToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  InByte                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_ByteToString(unsigned char InByte) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x33b3dfe1);

		UKismetStringLibrary_Conv_ByteToString_Params params;
		params.InByte = InByte;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Conv_BoolToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           InBool                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Conv_BoolToString(bool InBool) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfcb8f2af);

		UKismetStringLibrary_Conv_BoolToString_Params params;
		params.InBool = InBool;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Contains
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 SearchIn                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Substring                      (CPF_Parm, CPF_ZeroConstructor)
	// bool                           bUseCase                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bSearchFromEnd                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetStringLibrary::STATIC_Contains(const struct FString& SearchIn, const struct FString& Substring, bool bUseCase, bool bSearchFromEnd) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd3acaaf5);

		UKismetStringLibrary_Contains_Params params;
		params.SearchIn = SearchIn;
		params.Substring = Substring;
		params.bUseCase = bUseCase;
		params.bSearchFromEnd = bSearchFromEnd;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.Concat_StrStr
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 A                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 B                              (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_Concat_StrStr(const struct FString& A, const struct FString& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfd54278b);

		UKismetStringLibrary_Concat_StrStr_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Vector2d
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FVector2D               InVector2D                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Vector2d(const struct FString& AppendTo, const struct FString& Prefix, const struct FVector2D& InVector2D, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5442f627);

		UKismetStringLibrary_BuildString_Vector2d_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InVector2D = InVector2D;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Vector
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FVector                 InVector                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Vector(const struct FString& AppendTo, const struct FString& Prefix, const struct FVector& InVector, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc9128921);

		UKismetStringLibrary_BuildString_Vector_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InVector = InVector;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Rotator
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FRotator                InRot                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Rotator(const struct FString& AppendTo, const struct FString& Prefix, const struct FRotator& InRot, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x828dc493);

		UKismetStringLibrary_BuildString_Rotator_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InRot = InRot;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Object
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// class UObject*                 InObj                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Object(const struct FString& AppendTo, const struct FString& Prefix, class UObject* InObj, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x83651541);

		UKismetStringLibrary_BuildString_Object_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InObj = InObj;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Name
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Name(const struct FString& AppendTo, const struct FString& Prefix, const struct FName& InName, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb324b005);

		UKismetStringLibrary_BuildString_Name_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InName = InName;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Int
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// int                            inInt                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Int(const struct FString& AppendTo, const struct FString& Prefix, int inInt, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2b2035cf);

		UKismetStringLibrary_BuildString_Int_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.inInt = inInt;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Float
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// float                          inFloat                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Float(const struct FString& AppendTo, const struct FString& Prefix, float inFloat, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcc38e64a);

		UKismetStringLibrary_BuildString_Float_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.inFloat = inFloat;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Color
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FLinearColor            InColor                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Color(const struct FString& AppendTo, const struct FString& Prefix, const struct FLinearColor& InColor, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x769adce9);

		UKismetStringLibrary_BuildString_Color_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InColor = InColor;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetStringLibrary.BuildString_Bool
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 AppendTo                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Prefix                         (CPF_Parm, CPF_ZeroConstructor)
	// bool                           InBool                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Suffix                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetStringLibrary::STATIC_BuildString_Bool(const struct FString& AppendTo, const struct FString& Prefix, bool InBool, const struct FString& Suffix) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe62c655c);

		UKismetStringLibrary_BuildString_Bool_Params params;
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InBool = InBool;
		params.Suffix = Suffix;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.TextTrimTrailing
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   InText                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_TextTrimTrailing(const struct FText& InText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb3892da1);

		UKismetTextLibrary_TextTrimTrailing_Params params;
		params.InText = InText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   InText                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_TextTrimPrecedingAndTrailing(const struct FText& InText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x709bf3a3);

		UKismetTextLibrary_TextTrimPrecedingAndTrailing_Params params;
		params.InText = InText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.TextTrimPreceding
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   InText                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_TextTrimPreceding(const struct FText& InText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x35d3c2e8);

		UKismetTextLibrary_TextTrimPreceding_Params params;
		params.InText = InText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.TextIsTransient
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   InText                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetTextLibrary::STATIC_TextIsTransient(const struct FText& InText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x19fa1b5d);

		UKismetTextLibrary_TextIsTransient_Params params;
		params.InText = InText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.TextIsEmpty
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   InText                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetTextLibrary::STATIC_TextIsEmpty(const struct FText& InText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76f463b0);

		UKismetTextLibrary_TextIsEmpty_Params params;
		params.InText = InText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.TextIsCultureInvariant
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   InText                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetTextLibrary::STATIC_TextIsCultureInvariant(const struct FText& InText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4fe807ab);

		UKismetTextLibrary_TextIsCultureInvariant_Params params;
		params.InText = InText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.NotEqual_TextText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetTextLibrary::STATIC_NotEqual_TextText(const struct FText& A, const struct FText& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8d2d945c);

		UKismetTextLibrary_NotEqual_TextText_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetTextLibrary::STATIC_NotEqual_IgnoreCase_TextText(const struct FText& A, const struct FText& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76ed61cd);

		UKismetTextLibrary_NotEqual_IgnoreCase_TextText_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.GetEmptyText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_GetEmptyText() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x94b7fefa);

		UKismetTextLibrary_GetEmptyText_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Format
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   InPattern                      (CPF_Parm)
	// TArray<struct FFormatArgumentData> InArgs                         (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Format(const struct FText& InPattern, TArray<struct FFormatArgumentData> InArgs) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x65a6bb01);

		UKismetTextLibrary_Format_Params params;
		params.InPattern = InPattern;
		params.InArgs = InArgs;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.FindTextInLocalizationTable
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 Namespace                      (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Key                            (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   OutText                        (CPF_Parm, CPF_OutParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetTextLibrary::STATIC_FindTextInLocalizationTable(const struct FString& Namespace, const struct FString& Key, struct FText* OutText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6356b6d2);

		UKismetTextLibrary_FindTextInLocalizationTable_Params params;
		params.Namespace = Namespace;
		params.Key = Key;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (OutText != nullptr)
			*OutText = params.OutText;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.EqualEqual_TextText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetTextLibrary::STATIC_EqualEqual_TextText(const struct FText& A, const struct FText& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9ea36137);

		UKismetTextLibrary_EqualEqual_TextText_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   A                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FText                   B                              (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UKismetTextLibrary::STATIC_EqualEqual_IgnoreCase_TextText(const struct FText& A, const struct FText& B) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1a8afcc0);

		UKismetTextLibrary_EqualEqual_IgnoreCase_TextText_Params params;
		params.A = A;
		params.B = B;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_VectorToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector                 InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_VectorToText(const struct FVector& InVec) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x458b257e);

		UKismetTextLibrary_Conv_VectorToText_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_Vector2dToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FVector2D               InVec                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_Vector2dToText(const struct FVector2D& InVec) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa74de714);

		UKismetTextLibrary_Conv_Vector2dToText_Params params;
		params.InVec = InVec;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_TransformToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTransform              InTrans                        (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_TransformToText(const struct FTransform& InTrans) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa6339119);

		UKismetTextLibrary_Conv_TransformToText_Params params;
		params.InTrans = InTrans;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_TextToString
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FText                   InText                         (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ReferenceParm)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UKismetTextLibrary::STATIC_Conv_TextToString(const struct FText& InText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfc09c4a0);

		UKismetTextLibrary_Conv_TextToString_Params params;
		params.InText = InText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_StringToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FString                 inString                       (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_StringToText(const struct FString& inString) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd392dda4);

		UKismetTextLibrary_Conv_StringToText_Params params;
		params.inString = inString;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_RotatorToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FRotator                InRot                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_RotatorToText(const struct FRotator& InRot) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf86d23b2);

		UKismetTextLibrary_Conv_RotatorToText_Params params;
		params.InRot = InRot;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_ObjectToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class UObject*                 InObj                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_ObjectToText(class UObject* InObj) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x164b3386);

		UKismetTextLibrary_Conv_ObjectToText_Params params;
		params.InObj = InObj;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_NameToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FName                   InName                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_NameToText(const struct FName& InName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x235cc5d6);

		UKismetTextLibrary_Conv_NameToText_Params params;
		params.InName = InName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_IntToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseGrouping                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_IntToText(int Value, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x77951b5a);

		UKismetTextLibrary_Conv_IntToText_Params params;
		params.Value = Value;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_FloatToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ERoundingMode>     RoundingMode                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseGrouping                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumFractionalDigits        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumFractionalDigits        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_FloatToText(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x57cdee9b);

		UKismetTextLibrary_Conv_FloatToText_Params params;
		params.Value = Value;
		params.RoundingMode = RoundingMode;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		params.MinimumFractionalDigits = MinimumFractionalDigits;
		params.MaximumFractionalDigits = MaximumFractionalDigits;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_ColorToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FLinearColor            InColor                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_ColorToText(const struct FLinearColor& InColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xabcac50);

		UKismetTextLibrary_Conv_ColorToText_Params params;
		params.InColor = InColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_ByteToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// unsigned char                  Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_ByteToText(unsigned char Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1dee9e75);

		UKismetTextLibrary_Conv_ByteToText_Params params;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.Conv_BoolToText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// bool                           InBool                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_Conv_BoolToText(bool InBool) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3c0cf0b);

		UKismetTextLibrary_Conv_BoolToText_Params params;
		params.InBool = InBool;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsTimeZoneTime_DateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               InDateTime                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FString                 InTimeZone                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsTimeZoneTime_DateTime(const struct FDateTime& InDateTime, const struct FString& InTimeZone) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x92d5687e);

		UKismetTextLibrary_AsTimeZoneTime_DateTime_Params params;
		params.InDateTime = InDateTime;
		params.InTimeZone = InTimeZone;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsTimeZoneDateTime_DateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               InDateTime                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FString                 InTimeZone                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsTimeZoneDateTime_DateTime(const struct FDateTime& InDateTime, const struct FString& InTimeZone) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6d205ae2);

		UKismetTextLibrary_AsTimeZoneDateTime_DateTime_Params params;
		params.InDateTime = InDateTime;
		params.InTimeZone = InTimeZone;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsTimeZoneDate_DateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               InDateTime                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FString                 InTimeZone                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsTimeZoneDate_DateTime(const struct FDateTime& InDateTime, const struct FString& InTimeZone) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb9ba261f);

		UKismetTextLibrary_AsTimeZoneDate_DateTime_Params params;
		params.InDateTime = InDateTime;
		params.InTimeZone = InTimeZone;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsTimespan_Timespan
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FTimespan               InTimespan                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsTimespan_Timespan(const struct FTimespan& InTimespan) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9c01cde9);

		UKismetTextLibrary_AsTimespan_Timespan_Params params;
		params.InTimespan = InTimespan;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsTime_DateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               In                             (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsTime_DateTime(const struct FDateTime& In) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x316e36c5);

		UKismetTextLibrary_AsTime_DateTime_Params params;
		params.In = In;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsPercent_Float
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ERoundingMode>     RoundingMode                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseGrouping                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumFractionalDigits        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumFractionalDigits        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsPercent_Float(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfe19ae40);

		UKismetTextLibrary_AsPercent_Float_Params params;
		params.Value = Value;
		params.RoundingMode = RoundingMode;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		params.MinimumFractionalDigits = MinimumFractionalDigits;
		params.MaximumFractionalDigits = MaximumFractionalDigits;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsDateTime_DateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               In                             (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsDateTime_DateTime(const struct FDateTime& In) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb41c92d9);

		UKismetTextLibrary_AsDateTime_DateTime_Params params;
		params.In = In;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsDate_DateTime
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// struct FDateTime               InDateTime                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsDate_DateTime(const struct FDateTime& InDateTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf52f25ac);

		UKismetTextLibrary_AsDate_DateTime_Params params;
		params.InDateTime = InDateTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsCurrencyBase
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            BaseValue                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 CurrencyCode                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsCurrencyBase(int BaseValue, const struct FString& CurrencyCode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1c1ded8a);

		UKismetTextLibrary_AsCurrencyBase_Params params;
		params.BaseValue = BaseValue;
		params.CurrencyCode = CurrencyCode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsCurrency_Integer
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ERoundingMode>     RoundingMode                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseGrouping                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumFractionalDigits        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumFractionalDigits        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 CurrencyCode                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsCurrency_Integer(int Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits, const struct FString& CurrencyCode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6fc13d1a);

		UKismetTextLibrary_AsCurrency_Integer_Params params;
		params.Value = Value;
		params.RoundingMode = RoundingMode;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		params.MinimumFractionalDigits = MinimumFractionalDigits;
		params.MaximumFractionalDigits = MaximumFractionalDigits;
		params.CurrencyCode = CurrencyCode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.KismetTextLibrary.AsCurrency_Float
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<ERoundingMode>     RoundingMode                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bUseGrouping                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumIntegralDigits          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MinimumFractionalDigits        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            MaximumFractionalDigits        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 CurrencyCode                   (CPF_Parm, CPF_ZeroConstructor)
	// struct FText                   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ReturnParm)

	struct FText UKismetTextLibrary::STATIC_AsCurrency_Float(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits, const struct FString& CurrencyCode) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1cf4ad72);

		UKismetTextLibrary_AsCurrency_Float_Params params;
		params.Value = Value;
		params.RoundingMode = RoundingMode;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		params.MinimumFractionalDigits = MinimumFractionalDigits;
		params.MaximumFractionalDigits = MaximumFractionalDigits;
		params.CurrencyCode = CurrencyCode;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MeshVertexPainterKismetLibrary.RemovePaintedVertices
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UStaticMeshComponent*    StaticMeshComponent            (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)

	void UMeshVertexPainterKismetLibrary::STATIC_RemovePaintedVertices(class UStaticMeshComponent* StaticMeshComponent) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xbc196745);

		UMeshVertexPainterKismetLibrary_RemovePaintedVertices_Params params;
		params.StaticMeshComponent = StaticMeshComponent;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesSingleColor
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UStaticMeshComponent*    StaticMeshComponent            (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FLinearColor            FillColor                      (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bConvertToSRGB                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMeshVertexPainterKismetLibrary::STATIC_PaintVerticesSingleColor(class UStaticMeshComponent* StaticMeshComponent, const struct FLinearColor& FillColor, bool bConvertToSRGB) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x446f6b1b);

		UMeshVertexPainterKismetLibrary_PaintVerticesSingleColor_Params params;
		params.StaticMeshComponent = StaticMeshComponent;
		params.FillColor = FillColor;
		params.bConvertToSRGB = bConvertToSRGB;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesLerpAlongAxis
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UStaticMeshComponent*    StaticMeshComponent            (CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FLinearColor            StartColor                     (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FLinearColor            EndColor                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// TEnumAsByte<EVertexPaintAxis>  Axis                           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bConvertToSRGB                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMeshVertexPainterKismetLibrary::STATIC_PaintVerticesLerpAlongAxis(class UStaticMeshComponent* StaticMeshComponent, const struct FLinearColor& StartColor, const struct FLinearColor& EndColor, TEnumAsByte<EVertexPaintAxis> Axis, bool bConvertToSRGB) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x10e8de83);

		UMeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis_Params params;
		params.StaticMeshComponent = StaticMeshComponent;
		params.StartColor = StartColor;
		params.EndColor = EndColor;
		params.Axis = Axis;
		params.bConvertToSRGB = bConvertToSRGB;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerFunctionLibrary.ShowSplashScreen
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UStereoLayerFunctionLibrary::STATIC_ShowSplashScreen() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x61dd638d);

		UStereoLayerFunctionLibrary_ShowSplashScreen_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerFunctionLibrary.SetSplashScreen
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture*                Texture                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               Offset                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShowLoadingMovie              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bShowOnSet                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStereoLayerFunctionLibrary::STATIC_SetSplashScreen(class UTexture* Texture, const struct FVector2D& Scale, const struct FVector2D& Offset, bool bShowLoadingMovie, bool bShowOnSet) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa789aa80);

		UStereoLayerFunctionLibrary_SetSplashScreen_Params params;
		params.Texture = Texture;
		params.Scale = Scale;
		params.Offset = Offset;
		params.bShowLoadingMovie = bShowLoadingMovie;
		params.bShowOnSet = bShowOnSet;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerFunctionLibrary.HideSplashScreen
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)

	void UStereoLayerFunctionLibrary::STATIC_HideSplashScreen() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8ce07e56);

		UStereoLayerFunctionLibrary_HideSplashScreen_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.StereoLayerFunctionLibrary.EnableAutoLoadingSplashScreen
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           InAutoShowEnabled              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UStereoLayerFunctionLibrary::STATIC_EnableAutoLoadingSplashScreen(bool InAutoShowEnabled) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe9963610);

		UStereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen_Params params;
		params.InAutoShowEnabled = InAutoShowEnabled;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.VisualLoggerKismetLibrary.LogText
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Text                           (CPF_Parm, CPF_ZeroConstructor)
	// struct FName                   LogCategory                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UVisualLoggerKismetLibrary::STATIC_LogText(class UObject* WorldContextObject, const struct FString& Text, const struct FName& LogCategory) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc97732f0);

		UVisualLoggerKismetLibrary_LogText_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Text = Text;
		params.LogCategory = LogCategory;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.VisualLoggerKismetLibrary.LogLocation
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 Location                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Text                           (CPF_Parm, CPF_ZeroConstructor)
	// struct FLinearColor            ObjectColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   LogCategory                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UVisualLoggerKismetLibrary::STATIC_LogLocation(class UObject* WorldContextObject, const struct FVector& Location, const struct FString& Text, const struct FLinearColor& ObjectColor, float Radius, const struct FName& LogCategory) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfc929080);

		UVisualLoggerKismetLibrary_LogLocation_Params params;
		params.WorldContextObject = WorldContextObject;
		params.Location = Location;
		params.Text = Text;
		params.ObjectColor = ObjectColor;
		params.Radius = Radius;
		params.LogCategory = LogCategory;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.VisualLoggerKismetLibrary.LogBox
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FBox                    BoxShape                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Text                           (CPF_Parm, CPF_ZeroConstructor)
	// struct FLinearColor            ObjectColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FName                   LogCategory                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UVisualLoggerKismetLibrary::STATIC_LogBox(class UObject* WorldContextObject, const struct FBox& BoxShape, const struct FString& Text, const struct FLinearColor& ObjectColor, const struct FName& LogCategory) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x21f71258);

		UVisualLoggerKismetLibrary_LogBox_Params params;
		params.WorldContextObject = WorldContextObject;
		params.BoxShape = BoxShape;
		params.Text = Text;
		params.ObjectColor = ObjectColor;
		params.LogCategory = LogCategory;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraAnimInst.Stop
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bImmediate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraAnimInst::Stop(bool bImmediate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x22e600b9);

		UCameraAnimInst_Stop_Params params;
		params.bImmediate = bImmediate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraAnimInst.SetScale
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewDuration                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraAnimInst::SetScale(float NewDuration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc5c64f57);

		UCameraAnimInst_SetScale_Params params;
		params.NewDuration = NewDuration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraAnimInst.SetDuration
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// float                          NewDuration                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraAnimInst::SetDuration(float NewDuration) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x86389bbb);

		UCameraAnimInst_SetDuration_Params params;
		params.NewDuration = NewDuration;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraModifier.IsDisabled
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UCameraModifier::IsDisabled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x79ebf9ad);

		UCameraModifier_IsDisabled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CameraModifier.GetViewTarget
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class AActor*                  ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class AActor* UCameraModifier::GetViewTarget() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x45115c73);

		UCameraModifier_GetViewTarget_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CameraModifier.EnableModifier
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCameraModifier::EnableModifier() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x298ab1ff);

		UCameraModifier_EnableModifier_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraModifier.DisableModifier
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bImmediate                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraModifier::DisableModifier(bool bImmediate) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x69b4d1f8);

		UCameraModifier_DisableModifier_Params params;
		params.bImmediate = bImmediate;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CameraModifier.BlueprintModifyPostProcess
	// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintEvent)
	// Parameters:
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          PostProcessBlendWeight         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FPostProcessSettings    PostProcessSettings            (CPF_Parm, CPF_OutParm)

	void UCameraModifier::BlueprintModifyPostProcess(float DeltaTime, float* PostProcessBlendWeight, struct FPostProcessSettings* PostProcessSettings) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd8fc9671);

		UCameraModifier_BlueprintModifyPostProcess_Params params;
		params.DeltaTime = DeltaTime;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (PostProcessBlendWeight != nullptr)
			*PostProcessBlendWeight = params.PostProcessBlendWeight;
		if (PostProcessSettings != nullptr)
			*PostProcessSettings = params.PostProcessSettings;
	}


	// Function Engine.CameraModifier.BlueprintModifyCamera
	// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintEvent)
	// Parameters:
	// float                          DeltaTime                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ViewLocation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                ViewRotation                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          FOV                            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 NewViewLocation                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FRotator                NewViewRotation                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          NewFOV                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCameraModifier::BlueprintModifyCamera(float DeltaTime, const struct FVector& ViewLocation, const struct FRotator& ViewRotation, float FOV, struct FVector* NewViewLocation, struct FRotator* NewViewRotation, float* NewFOV) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x58e372d1);

		UCameraModifier_BlueprintModifyCamera_Params params;
		params.DeltaTime = DeltaTime;
		params.ViewLocation = ViewLocation;
		params.ViewRotation = ViewRotation;
		params.FOV = FOV;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (NewViewLocation != nullptr)
			*NewViewLocation = params.NewViewLocation;
		if (NewViewRotation != nullptr)
			*NewViewRotation = params.NewViewRotation;
		if (NewFOV != nullptr)
			*NewFOV = params.NewFOV;
	}


	// Function Engine.Canvas.K2_TextSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UFont*                   RenderFont                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 RenderText                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FVector2D               Scale                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UCanvas::K2_TextSize(class UFont* RenderFont, const struct FString& RenderText, const struct FVector2D& Scale) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1d7253c9);

		UCanvas_K2_TextSize_Params params;
		params.RenderFont = RenderFont;
		params.RenderText = RenderText;
		params.Scale = Scale;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Canvas.K2_StrLen
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UFont*                   RenderFont                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 RenderText                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FVector2D               ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector2D UCanvas::K2_StrLen(class UFont* RenderFont, const struct FString& RenderText) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x21c86541);

		UCanvas_K2_StrLen_Params params;
		params.RenderFont = RenderFont;
		params.RenderText = RenderText;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Canvas.K2_Project
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector                 WorldLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UCanvas::K2_Project(const struct FVector& WorldLocation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcef91d66);

		UCanvas_K2_Project_Params params;
		params.WorldLocation = WorldLocation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Canvas.K2_DrawTriangle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture*                RenderTexture                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FCanvasUVTri>    Triangles                      (CPF_Parm, CPF_ZeroConstructor)

	void UCanvas::K2_DrawTriangle(class UTexture* RenderTexture, TArray<struct FCanvasUVTri> Triangles) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa3458131);

		UCanvas_K2_DrawTriangle_Params params;
		params.RenderTexture = RenderTexture;
		params.Triangles = Triangles;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_DrawTexture
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture*                RenderTexture                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenPosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenSize                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               CoordinatePosition             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               CoordinateSize                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            RenderColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TEnumAsByte<EBlendMode>        BlendMode                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               PivotPoint                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvas::K2_DrawTexture(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, TEnumAsByte<EBlendMode> BlendMode, float Rotation, const struct FVector2D& PivotPoint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7e95f142);

		UCanvas_K2_DrawTexture_Params params;
		params.RenderTexture = RenderTexture;
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.CoordinatePosition = CoordinatePosition;
		params.CoordinateSize = CoordinateSize;
		params.RenderColor = RenderColor;
		params.BlendMode = BlendMode;
		params.Rotation = Rotation;
		params.PivotPoint = PivotPoint;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_DrawText
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UFont*                   RenderFont                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 RenderText                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FVector2D               ScreenPosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            RenderColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Kerning                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ShadowColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ShadowOffset                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bCentreX                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bCentreY                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           bOutlined                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            OutlineColor                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvas::K2_DrawText(class UFont* RenderFont, const struct FString& RenderText, const struct FVector2D& ScreenPosition, const struct FLinearColor& RenderColor, float Kerning, const struct FLinearColor& ShadowColor, const struct FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, const struct FLinearColor& OutlineColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2348c410);

		UCanvas_K2_DrawText_Params params;
		params.RenderFont = RenderFont;
		params.RenderText = RenderText;
		params.ScreenPosition = ScreenPosition;
		params.RenderColor = RenderColor;
		params.Kerning = Kerning;
		params.ShadowColor = ShadowColor;
		params.ShadowOffset = ShadowOffset;
		params.bCentreX = bCentreX;
		params.bCentreY = bCentreY;
		params.bOutlined = bOutlined;
		params.OutlineColor = OutlineColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_DrawPolygon
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture*                RenderTexture                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenPosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               Radius                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            NumberOfSides                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            RenderColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvas::K2_DrawPolygon(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& Radius, int NumberOfSides, const struct FLinearColor& RenderColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x9f0fc845);

		UCanvas_K2_DrawPolygon_Params params;
		params.RenderTexture = RenderTexture;
		params.ScreenPosition = ScreenPosition;
		params.Radius = Radius;
		params.NumberOfSides = NumberOfSides;
		params.RenderColor = RenderColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_DrawMaterialTriangle
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      RenderMaterial                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// TArray<struct FCanvasUVTri>    Triangles                      (CPF_Parm, CPF_ZeroConstructor)

	void UCanvas::K2_DrawMaterialTriangle(class UMaterialInterface* RenderMaterial, TArray<struct FCanvasUVTri> Triangles) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x297806ea);

		UCanvas_K2_DrawMaterialTriangle_Params params;
		params.RenderMaterial = RenderMaterial;
		params.Triangles = Triangles;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_DrawMaterial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      RenderMaterial                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenPosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenSize                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               CoordinatePosition             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               CoordinateSize                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               PivotPoint                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvas::K2_DrawMaterial(class UMaterialInterface* RenderMaterial, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, float Rotation, const struct FVector2D& PivotPoint) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x86bf882a);

		UCanvas_K2_DrawMaterial_Params params;
		params.RenderMaterial = RenderMaterial;
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.CoordinatePosition = CoordinatePosition;
		params.CoordinateSize = CoordinateSize;
		params.Rotation = Rotation;
		params.PivotPoint = PivotPoint;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_DrawLine
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               ScreenPositionA                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenPositionB                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            RenderColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvas::K2_DrawLine(const struct FVector2D& ScreenPositionA, const struct FVector2D& ScreenPositionB, float Thickness, const struct FLinearColor& RenderColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb997bb3f);

		UCanvas_K2_DrawLine_Params params;
		params.ScreenPositionA = ScreenPositionA;
		params.ScreenPositionB = ScreenPositionB;
		params.Thickness = Thickness;
		params.RenderColor = RenderColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_DrawBox
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               ScreenPosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenSize                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Thickness                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvas::K2_DrawBox(const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, float Thickness) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x6207f8);

		UCanvas_K2_DrawBox_Params params;
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.Thickness = Thickness;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_DrawBorder
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UTexture*                BorderTexture                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTexture*                BackgroundTexture              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTexture*                LeftBorderTexture              (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTexture*                RightBorderTexture             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTexture*                TopBorderTexture               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTexture*                BottomBorderTexture            (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenPosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               ScreenSize                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               CoordinatePosition             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               CoordinateSize                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            RenderColor                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               BorderScale                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               BackgroundScale                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Rotation                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               PivotPoint                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector2D               CornerSize                     (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvas::K2_DrawBorder(class UTexture* BorderTexture, class UTexture* BackgroundTexture, class UTexture* LeftBorderTexture, class UTexture* RightBorderTexture, class UTexture* TopBorderTexture, class UTexture* BottomBorderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, const struct FVector2D& BorderScale, const struct FVector2D& BackgroundScale, float Rotation, const struct FVector2D& PivotPoint, const struct FVector2D& CornerSize) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc4ef99f3);

		UCanvas_K2_DrawBorder_Params params;
		params.BorderTexture = BorderTexture;
		params.BackgroundTexture = BackgroundTexture;
		params.LeftBorderTexture = LeftBorderTexture;
		params.RightBorderTexture = RightBorderTexture;
		params.TopBorderTexture = TopBorderTexture;
		params.BottomBorderTexture = BottomBorderTexture;
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.CoordinatePosition = CoordinatePosition;
		params.CoordinateSize = CoordinateSize;
		params.RenderColor = RenderColor;
		params.BorderScale = BorderScale;
		params.BackgroundScale = BackgroundScale;
		params.Rotation = Rotation;
		params.PivotPoint = PivotPoint;
		params.CornerSize = CornerSize;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.Canvas.K2_Deproject
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FVector2D               ScreenPosition                 (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldOrigin                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldDirection                 (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvas::K2_Deproject(const struct FVector2D& ScreenPosition, struct FVector* WorldOrigin, struct FVector* WorldDirection) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xc1e3d3a5);

		UCanvas_K2_Deproject_Params params;
		params.ScreenPosition = ScreenPosition;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (WorldOrigin != nullptr)
			*WorldOrigin = params.WorldOrigin;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;
	}


	// Function Engine.CurveLinearColor.GetLinearColorValue
	// (FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          InTime                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UCurveLinearColor::GetLinearColorValue(float InTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xcecf0d41);

		UCurveLinearColor_GetLinearColorValue_Params params;
		params.InTime = InTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CurveVector.GetVectorValue
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          InTime                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector UCurveVector::GetVectorValue(float InTime) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2470f8b9);

		UCurveVector_GetVectorValue_Params params;
		params.InTime = InTime;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlayerInput.SetMouseSensitivity
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// float                          Sensitivity                    (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPlayerInput::SetMouseSensitivity(float Sensitivity) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x199e8600);

		UPlayerInput_SetMouseSensitivity_Params params;
		params.Sensitivity = Sensitivity;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerInput.SetBind
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   BindName                       (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Command                        (CPF_Parm, CPF_ZeroConstructor)

	void UPlayerInput::SetBind(const struct FName& BindName, const struct FString& Command) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa166f4cb);

		UPlayerInput_SetBind_Params params;
		params.BindName = BindName;
		params.Command = Command;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerInput.InvertAxisKey
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FKey                    AxisKey                        (CPF_ConstParm, CPF_Parm)

	void UPlayerInput::InvertAxisKey(const struct FKey& AxisKey) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd303b44a);

		UPlayerInput_InvertAxisKey_Params params;
		params.AxisKey = AxisKey;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerInput.InvertAxis
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FName                   AxisName                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UPlayerInput::InvertAxis(const struct FName& AxisName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1eae6b55);

		UPlayerInput_InvertAxis_Params params;
		params.AxisName = AxisName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.PlayerInput.ClearSmoothing
	// (FUNC_Final, FUNC_Exec, FUNC_Native, FUNC_Public)

	void UPlayerInput::ClearSmoothing() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x4a614c5d);

		UPlayerInput_ClearSmoothing_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.LevelStreaming.IsStreamingStatePending
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ULevelStreaming::IsStreamingStatePending() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x46c65bcf);

		ULevelStreaming_IsStreamingStatePending_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.LevelStreaming.IsLevelVisible
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ULevelStreaming::IsLevelVisible() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfea4b8a1);

		ULevelStreaming_IsLevelVisible_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.LevelStreaming.IsLevelLoaded
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool ULevelStreaming::IsLevelLoaded() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x76fde72a);

		ULevelStreaming_IsLevelLoaded_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.LevelStreaming.GetLevelScriptActor
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// class ALevelScriptActor*       ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class ALevelScriptActor* ULevelStreaming::GetLevelScriptActor() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe21d0161);

		ULevelStreaming_GetLevelScriptActor_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.LevelStreaming.CreateInstance
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FString                 UniqueInstanceName             (CPF_Parm, CPF_ZeroConstructor)
	// class ULevelStreaming*         ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class ULevelStreaming* ULevelStreaming::CreateInstance(const struct FString& UniqueInstanceName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd26004a0);

		ULevelStreaming_CreateInstance_Params params;
		params.UniqueInstanceName = UniqueInstanceName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.LevelStreamingKismet.LoadLevelInstance
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 LevelName                      (CPF_Parm, CPF_ZeroConstructor)
	// struct FVector                 Location                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// struct FRotator                Rotation                       (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm, CPF_IsPlainOldData)
	// bool                           bOutSuccess                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class ULevelStreamingKismet*   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class ULevelStreamingKismet* ULevelStreamingKismet::STATIC_LoadLevelInstance(class UObject* WorldContextObject, const struct FString& LevelName, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2718fa33);

		ULevelStreamingKismet_LoadLevelInstance_Params params;
		params.WorldContextObject = WorldContextObject;
		params.LevelName = LevelName;
		params.Location = Location;
		params.Rotation = Rotation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (bOutSuccess != nullptr)
			*bOutSuccess = params.bOutSuccess;

		return params.ReturnValue;
	}


	// Function Engine.MaterialInstanceDynamic.SetVectorParameterValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMaterialInstanceDynamic::SetVectorParameterValue(const struct FName& ParameterName, const struct FLinearColor& Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xff144e93);

		UMaterialInstanceDynamic_SetVectorParameterValue_Params params;
		params.ParameterName = ParameterName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialInstanceDynamic.SetTextureParameterValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTexture*                Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMaterialInstanceDynamic::SetTextureParameterValue(const struct FName& ParameterName, class UTexture* Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x15efe797);

		UMaterialInstanceDynamic_SetTextureParameterValue_Params params;
		params.ParameterName = ParameterName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialInstanceDynamic.SetScalarParameterValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Value                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMaterialInstanceDynamic::SetScalarParameterValue(const struct FName& ParameterName, float Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5c70a7da);

		UMaterialInstanceDynamic_SetScalarParameterValue_Params params;
		params.ParameterName = ParameterName;
		params.Value = Value;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInstance*       SourceA                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UMaterialInstance*       SourceB                        (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          Alpha                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMaterialInstanceDynamic::K2_InterpolateMaterialInstanceParams(class UMaterialInstance* SourceA, class UMaterialInstance* SourceB, float Alpha) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xdab6eb55);

		UMaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams_Params params;
		params.SourceA = SourceA;
		params.SourceB = SourceB;
		params.Alpha = Alpha;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FLinearColor UMaterialInstanceDynamic::K2_GetVectorParameterValue(const struct FName& ParameterName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x52468451);

		UMaterialInstanceDynamic_K2_GetVectorParameterValue_Params params;
		params.ParameterName = ParameterName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UTexture*                ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UTexture* UMaterialInstanceDynamic::K2_GetTextureParameterValue(const struct FName& ParameterName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x8b3e3e45);

		UMaterialInstanceDynamic_K2_GetTextureParameterValue_Params params;
		params.ParameterName = ParameterName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// struct FName                   ParameterName                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UMaterialInstanceDynamic::K2_GetScalarParameterValue(const struct FName& ParameterName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x1183a4cc);

		UMaterialInstanceDynamic_K2_GetScalarParameterValue_Params params;
		params.ParameterName = ParameterName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInterface*      Source                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMaterialInstanceDynamic::K2_CopyMaterialInstanceParameters(class UMaterialInterface* Source) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x85e42d41);

		UMaterialInstanceDynamic_K2_CopyMaterialInstanceParameters_Params params;
		params.Source = Source;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialInstanceDynamic.CopyParameterOverrides
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UMaterialInstance*       MaterialInstance               (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMaterialInstanceDynamic::CopyParameterOverrides(class UMaterialInstance* MaterialInstance) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x467bf681);

		UMaterialInstanceDynamic_CopyParameterOverrides_Params params;
		params.MaterialInstance = MaterialInstance;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.MaterialInstanceDynamic.CopyInterpParameters
	// (FUNC_Final, FUNC_Native, FUNC_Public)
	// Parameters:
	// class UMaterialInstance*       Source                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UMaterialInstanceDynamic::CopyInterpParameters(class UMaterialInstance* Source) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xab097047);

		UMaterialInstanceDynamic_CopyInterpParameters_Params params;
		params.Source = Source;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationPath.IsValid
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavigationPath::IsValid() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xddfc9358);

		UNavigationPath_IsValid_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationPath.IsStringPulled
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavigationPath::IsStringPulled() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x33212f4b);

		UNavigationPath_IsStringPulled_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationPath.IsPartial
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UNavigationPath::IsPartial() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x21f3741d);

		UNavigationPath_IsPartial_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationPath.GetPathLength
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UNavigationPath::GetPathLength() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5226fd2f);

		UNavigationPath_GetPathLength_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationPath.GetPathCost
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// float                          ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	float UNavigationPath::GetPathCost() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x921a8748);

		UNavigationPath_GetPathCost_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationPath.GetDebugString
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UNavigationPath::GetDebugString() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x89ce4f9c);

		UNavigationPath_GetDebugString_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.NavigationPath.EnableRecalculationOnInvalidation
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// TEnumAsByte<ENavigationOptionFlag> DoRecalculation                (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavigationPath::EnableRecalculationOnInvalidation(TEnumAsByte<ENavigationOptionFlag> DoRecalculation) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x17658180);

		UNavigationPath_EnableRecalculationOnInvalidation_Params params;
		params.DoRecalculation = DoRecalculation;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.NavigationPath.EnableDebugDrawing
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// bool                           bShouldDrawDebugData           (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FLinearColor            PathColor                      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UNavigationPath::EnableDebugDrawing(bool bShouldDrawDebugData, const struct FLinearColor& PathColor) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb3a83576);

		UNavigationPath_EnableDebugDrawing_Params params;
		params.bShouldDrawDebugData = bShouldDrawDebugData;
		params.PathColor = PathColor;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TwitterIntegrationBase.TwitterRequest
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms)
	// Parameters:
	// struct FString                 URL                            (CPF_Parm, CPF_ZeroConstructor)
	// TArray<struct FString>         ParamKeysAndValues             (CPF_ConstParm, CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReferenceParm)
	// TEnumAsByte<ETwitterRequestMethod> RequestMethod                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            AccountIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UTwitterIntegrationBase::TwitterRequest(const struct FString& URL, TArray<struct FString> ParamKeysAndValues, TEnumAsByte<ETwitterRequestMethod> RequestMethod, int AccountIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xfb508cb9);

		UTwitterIntegrationBase_TwitterRequest_Params params;
		params.URL = URL;
		params.ParamKeysAndValues = ParamKeysAndValues;
		params.RequestMethod = RequestMethod;
		params.AccountIndex = AccountIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TwitterIntegrationBase.ShowTweetUI
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 InitialMessage                 (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 URL                            (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 Picture                        (CPF_Parm, CPF_ZeroConstructor)
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UTwitterIntegrationBase::ShowTweetUI(const struct FString& InitialMessage, const struct FString& URL, const struct FString& Picture) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x228db2a3);

		UTwitterIntegrationBase_ShowTweetUI_Params params;
		params.InitialMessage = InitialMessage;
		params.URL = URL;
		params.Picture = Picture;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TwitterIntegrationBase.Init
	// (FUNC_Native, FUNC_Public)

	void UTwitterIntegrationBase::Init() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xe69c1817);

		UTwitterIntegrationBase_Init_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.TwitterIntegrationBase.GetNumAccounts
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UTwitterIntegrationBase::GetNumAccounts() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xf3426685);

		UTwitterIntegrationBase_GetNumAccounts_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TwitterIntegrationBase.GetAccountName
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// int                            AccountIndex                   (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UTwitterIntegrationBase::GetAccountName(int AccountIndex) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x3d54eb8d);

		UTwitterIntegrationBase_GetAccountName_Params params;
		params.AccountIndex = AccountIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TwitterIntegrationBase.CanShowTweetUI
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UTwitterIntegrationBase::CanShowTweetUI() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5d91b1f7);

		UTwitterIntegrationBase_CanShowTweetUI_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.TwitterIntegrationBase.AuthorizeAccounts
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// bool                           ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	bool UTwitterIntegrationBase::AuthorizeAccounts() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb5175042);

		UTwitterIntegrationBase_AuthorizeAccounts_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlatformInterfaceWebResponse.GetNumHeaders
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UPlatformInterfaceWebResponse::GetNumHeaders() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x50fbaca6);

		UPlatformInterfaceWebResponse_GetNumHeaders_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlatformInterfaceWebResponse.GetHeaderValue
	// (FUNC_Native, FUNC_Public)
	// Parameters:
	// struct FString                 HeaderName                     (CPF_Parm, CPF_ZeroConstructor)
	// struct FString                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm)

	struct FString UPlatformInterfaceWebResponse::GetHeaderValue(const struct FString& HeaderName) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x426f275e);

		UPlatformInterfaceWebResponse_GetHeaderValue_Params params;
		params.HeaderName = HeaderName;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.PlatformInterfaceWebResponse.GetHeader
	// (FUNC_Native, FUNC_Public, FUNC_HasOutParms)
	// Parameters:
	// int                            HeaderIndex                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FString                 Header                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)
	// struct FString                 Value                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor)

	void UPlatformInterfaceWebResponse::GetHeader(int HeaderIndex, struct FString* Header, struct FString* Value) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xa5e1e99f);

		UPlatformInterfaceWebResponse_GetHeader_Params params;
		params.HeaderIndex = HeaderIndex;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Header != nullptr)
			*Header = params.Header;
		if (Value != nullptr)
			*Value = params.Value;
	}


	// Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable)
	// Parameters:
	// class USkeletalMeshComponent*  SkelComp                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FVector                 WorldLocation                  (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// struct FVector                 WorldNormal                    (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void USkeletalMeshSocket::InitializeSocketFromLocation(class USkeletalMeshComponent* SkelComp, const struct FVector& WorldLocation, const struct FVector& WorldNormal) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5d071ae0);

		USkeletalMeshSocket_InitializeSocketFromLocation_Params params;
		params.SkelComp = SkelComp;
		params.WorldLocation = WorldLocation;
		params.WorldNormal = WorldNormal;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.SkeletalMeshSocket.GetSocketLocation
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// class USkeletalMeshComponent*  SkelComp                       (CPF_ConstParm, CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData)
	// struct FVector                 ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FVector USkeletalMeshSocket::GetSocketLocation(class USkeletalMeshComponent* SkelComp) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x7b66fede);

		USkeletalMeshSocket_GetSocketLocation_Params params;
		params.SkelComp = SkelComp;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StaticMesh.GetNumSections
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            InLOD                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UStaticMesh::GetNumSections(int InLOD) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x19204cdc);

		UStaticMesh_GetNumSections_Params params;
		params.InLOD = InLOD;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StaticMesh.GetNumLODs
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UStaticMesh::GetNumLODs() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x2461da84);

		UStaticMesh_GetNumLODs_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StaticMesh.GetBounds
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FBoxSphereBounds        ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FBoxSphereBounds UStaticMesh::GetBounds() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x113e9ccb);

		UStaticMesh_GetBounds_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.StaticMesh.GetBoundingBox
	// (FUNC_Final, FUNC_RequiredAPI, FUNC_Native, FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// struct FBox                    ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	struct FBox UStaticMesh::GetBoundingBox() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb98aa993);

		UStaticMesh_GetBoundingBox_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Texture2D.Blueprint_GetSizeY
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UTexture2D::Blueprint_GetSizeY() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xae0deb48);

		UTexture2D_Blueprint_GetSizeY_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.Texture2D.Blueprint_GetSizeX
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintPure, FUNC_Const)
	// Parameters:
	// int                            ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	int UTexture2D::Blueprint_GetSizeX() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xd41065b1);

		UTexture2D_Blueprint_GetSizeX_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


	// Function Engine.CanvasRenderTarget2D.UpdateResource
	// (FUNC_Native, FUNC_Public, FUNC_BlueprintCallable)

	void UCanvasRenderTarget2D::UpdateResource() {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x5299f4a3);

		UCanvasRenderTarget2D_UpdateResource_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CanvasRenderTarget2D.ReceiveUpdate
	// (FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
	// Parameters:
	// class UCanvas*                 Canvas                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Width                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Height                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvasRenderTarget2D::ReceiveUpdate(class UCanvas* Canvas, int Width, int Height) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0xb9f7dcd4);

		UCanvasRenderTarget2D_ReceiveUpdate_Params params;
		params.Canvas = Canvas;
		params.Width = Width;
		params.Height = Height;

		auto flags = fn->FunctionFlags;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;
	}


	// Function Engine.CanvasRenderTarget2D.GetSize
	// (FUNC_Final, FUNC_Native, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintPure)
	// Parameters:
	// int                            Width                          (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Height                         (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData)

	void UCanvasRenderTarget2D::GetSize(int* Width, int* Height) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x29e05aff);

		UCanvasRenderTarget2D_GetSize_Params params;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		if (Width != nullptr)
			*Width = params.Width;
		if (Height != nullptr)
			*Height = params.Height;
	}


	// Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D
	// (FUNC_Final, FUNC_Native, FUNC_Static, FUNC_Public, FUNC_BlueprintCallable)
	// Parameters:
	// class UObject*                 WorldContextObject             (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UClass*                  CanvasRenderTarget2DClass      (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Width                          (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// int                            Height                         (CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData)
	// class UCanvasRenderTarget2D*   ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_IsPlainOldData)

	class UCanvasRenderTarget2D* UCanvasRenderTarget2D::STATIC_CreateCanvasRenderTarget2D(class UObject* WorldContextObject, class UClass* CanvasRenderTarget2DClass, int Width, int Height) {
		static UFunction* fn = nullptr;
		if (!fn) fn = UObject::FindObject<UFunction>(0x935d467d);

		UCanvasRenderTarget2D_CreateCanvasRenderTarget2D_Params params;
		params.WorldContextObject = WorldContextObject;
		params.CanvasRenderTarget2DClass = CanvasRenderTarget2DClass;
		params.Width = Width;
		params.Height = Height;

		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x400;

		UObject::ProcessEvent(fn, &params);

		fn->FunctionFlags = flags;

		return params.ReturnValue;
	}


}

#ifdef _MSC_VER
#pragma pack(pop)
#endif
